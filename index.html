<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>å¼•ç”¨çœŸä¼ªå¿«é€Ÿæ ¡éªŒï¼ˆOpenAlex + Crossrefï¼‰</title>
    <style>
      :root {
        --primary: #4f46e5;
        --primary-light: #818cf8;
        --success: #10b981;
        --warning: #f59e0b;
        --danger: #ef4444;
        --bg: #f8fafc;
        --card-bg: #ffffff;
        --text: #1e293b;
        --text-muted: #64748b;
        --border: #e2e8f0;
        --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1),
          0 2px 4px -2px rgb(0 0 0 / 0.1);
        --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1),
          0 4px 6px -4px rgb(0 0 0 / 0.1);
      }

      * {
        box-sizing: border-box;
      }

      body {
        font-family: system-ui, -apple-system, "Segoe UI", Roboto, Helvetica,
          Arial, sans-serif;
        max-width: 1200px;
        margin: 0 auto;
        padding: 24px 16px;
        line-height: 1.6;
        background: var(--bg);
        color: var(--text);
      }

      .header {
        text-align: center;
        margin-bottom: 32px;
      }

      .header h1 {
        font-size: 28px;
        font-weight: 700;
        background: linear-gradient(
          135deg,
          var(--primary) 0%,
          var(--primary-light) 100%
        );
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
        margin: 0 0 12px 0;
      }

      .header p {
        color: var(--text-muted);
        font-size: 14px;
        max-width: 700px;
        margin: 0 auto;
      }

      .card {
        background: var(--card-bg);
        border-radius: 16px;
        padding: 24px;
        box-shadow: var(--shadow);
        margin-bottom: 20px;
        border: 1px solid var(--border);
      }

      .card-title {
        font-size: 16px;
        font-weight: 600;
        margin: 0 0 16px 0;
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .input-section {
        display: grid;
        grid-template-columns: 1fr 360px;
        gap: 20px;
      }

      @media (max-width: 768px) {
        .input-section {
          grid-template-columns: 1fr;
        }
      }

      label {
        display: block;
        font-size: 14px;
        font-weight: 500;
        margin-bottom: 8px;
        color: var(--text);
      }

      textarea,
      input[type="text"],
      input[type="email"] {
        width: 100%;
        padding: 12px 16px;
        border: 2px solid var(--border);
        border-radius: 12px;
        font-size: 14px;
        transition: all 0.2s ease;
        background: var(--card-bg);
        font-family: inherit;
      }

      textarea:focus,
      input:focus {
        outline: none;
        border-color: var(--primary);
        box-shadow: 0 0 0 3px rgba(79, 70, 229, 0.1);
      }

      textarea {
        resize: vertical;
        min-height: 180px;
      }

      .hint {
        font-size: 12px;
        color: var(--text-muted);
        margin-top: 8px;
      }

      .btn {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        gap: 8px;
        padding: 12px 24px;
        border: none;
        border-radius: 12px;
        font-size: 15px;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.25s ease;
      }

      .btn-primary {
        background: linear-gradient(
          135deg,
          var(--primary) 0%,
          var(--primary-light) 100%
        );
        color: white;
        box-shadow: 0 4px 14px 0 rgba(79, 70, 229, 0.35);
      }

      .btn-primary:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 20px 0 rgba(79, 70, 229, 0.45);
      }

      .btn-primary:active {
        transform: translateY(0);
      }

      .btn-primary:disabled {
        opacity: 0.6;
        cursor: not-allowed;
        transform: none;
      }

      .btn-extract {
        background: linear-gradient(135deg, #06b6d4 0%, #22d3ee 100%);
        color: white;
        box-shadow: 0 4px 14px 0 rgba(6, 182, 212, 0.35);
      }

      .btn-extract:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 20px 0 rgba(6, 182, 212, 0.45);
      }

      .btn-extract:active {
        transform: translateY(0);
      }

      .btn-success {
        background: linear-gradient(135deg, var(--success) 0%, #34d399 100%);
        color: white;
        box-shadow: 0 4px 14px 0 rgba(16, 185, 129, 0.35);
      }

      .btn-success:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 20px 0 rgba(16, 185, 129, 0.45);
      }

      .btn-success:active {
        transform: translateY(0);
      }

      .btn-copy {
        background: linear-gradient(135deg, #f97316 0%, #fb923c 100%);
        color: white;
        box-shadow: 0 4px 14px 0 rgba(249, 115, 22, 0.35);
      }

      .btn-copy:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 20px 0 rgba(249, 115, 22, 0.45);
      }

      .btn-copy:active {
        transform: translateY(0);
      }

      .btn-secondary {
        background: var(--card-bg);
        color: var(--text);
        border: 2px solid var(--border);
      }

      .btn-secondary:hover {
        background: var(--bg);
        border-color: #cbd5e1;
      }

      .btn-secondary:active {
        transform: scale(0.98);
      }

      .btn-clear {
        background: linear-gradient(135deg, #64748b 0%, #94a3b8 100%);
        color: white;
        box-shadow: 0 4px 14px 0 rgba(100, 116, 139, 0.35);
      }

      .btn-clear:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 20px 0 rgba(100, 116, 139, 0.45);
      }

      .btn-clear:active {
        transform: translateY(0);
      }

      .btn-info {
        background: linear-gradient(135deg, #0ea5e9 0%, #38bdf8 100%);
        color: white;
        box-shadow: 0 4px 14px 0 rgba(14, 165, 233, 0.35);
      }

      .btn-info:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 20px 0 rgba(14, 165, 233, 0.45);
      }

      .btn-info:active {
        transform: translateY(0);
      }

      .btn-github {
        background: linear-gradient(135deg, #374151 0%, #4b5563 100%);
        color: white;
        box-shadow: 0 4px 14px 0 rgba(55, 65, 81, 0.35);
      }

      .btn-github:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 20px 0 rgba(55, 65, 81, 0.45);
      }

      .btn-github:active {
        transform: translateY(0);
      }

      .actions {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
        margin-top: 16px;
      }

      /* Progress Bar */
      .progress-container {
        display: none;
        margin-bottom: 20px;
      }

      .progress-container.active {
        display: block;
      }

      .progress-bar {
        height: 8px;
        background: var(--border);
        border-radius: 4px;
        overflow: hidden;
      }

      .progress-fill {
        height: 100%;
        background: linear-gradient(
          90deg,
          var(--primary),
          var(--primary-light)
        );
        border-radius: 4px;
        transition: width 0.3s ease;
        width: 0%;
      }

      .progress-text {
        display: flex;
        justify-content: space-between;
        font-size: 13px;
        color: var(--text-muted);
        margin-top: 8px;
      }

      /* Summary Stats */
      .summary {
        display: none;
        grid-template-columns: repeat(4, 1fr);
        gap: 16px;
        margin-bottom: 20px;
      }

      .summary.active {
        display: grid;
      }

      @media (max-width: 600px) {
        .summary {
          grid-template-columns: repeat(2, 1fr);
        }
      }

      .stat-card {
        background: var(--card-bg);
        border-radius: 12px;
        padding: 16px;
        text-align: center;
        border: 1px solid var(--border);
        box-shadow: var(--shadow);
      }

      .stat-value {
        font-size: 28px;
        font-weight: 700;
      }

      .stat-label {
        font-size: 13px;
        color: var(--text-muted);
        margin-top: 4px;
      }

      .stat-card.total .stat-value {
        color: var(--primary);
      }
      .stat-card.high .stat-value {
        color: var(--success);
      }
      .stat-card.medium .stat-value {
        color: var(--warning);
      }
      .stat-card.low .stat-value {
        color: var(--danger);
      }

      /* Result Items */
      .result-item {
        background: var(--card-bg);
        border-radius: 12px;
        margin-bottom: 16px;
        border: 1px solid var(--border);
        box-shadow: var(--shadow);
        animation: slideIn 0.3s ease;
        position: relative;
      }

      @keyframes slideIn {
        from {
          opacity: 0;
          transform: translateY(10px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      .result-header {
        padding: 16px 20px;
        display: flex;
        align-items: center;
        gap: 12px;
        cursor: pointer;
        user-select: none;
        transition: background 0.2s;
        border-radius: 12px;
        background: var(--card-bg);
      }

      .result-item.expanded .result-header {
        border-radius: 12px 12px 0 0;
      }

      .result-header:hover {
        background: var(--bg);
      }

      .result-index {
        width: 32px;
        height: 32px;
        border-radius: 8px;
        background: var(--bg);
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: 600;
        font-size: 14px;
        color: var(--text-muted);
        flex-shrink: 0;
      }

      .result-title {
        flex: 1;
        font-size: 14px;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }

      .result-score {
        padding: 6px 12px;
        border-radius: 20px;
        font-size: 13px;
        font-weight: 600;
        flex-shrink: 0;
        transition: all 0.2s ease;
        cursor: help;
        display: inline-flex;
        align-items: center;
        gap: 6px;
      }

      .result-score::before {
        content: "";
        width: 8px;
        height: 8px;
        border-radius: 50%;
        flex-shrink: 0;
      }

      .result-score.high {
        background: rgba(16, 185, 129, 0.1);
        color: var(--success);
      }

      .result-score.high::before {
        background: linear-gradient(135deg, var(--success) 0%, #34d399 100%);
        box-shadow: 0 0 6px rgba(16, 185, 129, 0.4);
      }

      .result-score.medium {
        background: rgba(245, 158, 11, 0.1);
        color: var(--warning);
      }

      .result-score.medium::before {
        background: linear-gradient(135deg, var(--warning) 0%, #fbbf24 100%);
        box-shadow: 0 0 6px rgba(245, 158, 11, 0.4);
      }

      .result-score.low {
        background: rgba(239, 68, 68, 0.1);
        color: var(--danger);
      }

      .result-score.low::before {
        background: linear-gradient(135deg, var(--danger) 0%, #f87171 100%);
        box-shadow: 0 0 6px rgba(239, 68, 68, 0.4);
      }

      .result-toggle {
        width: 24px;
        height: 24px;
        display: flex;
        align-items: center;
        justify-content: center;
        color: var(--text-muted);
        transition: transform 0.2s;
      }

      .result-item.expanded .result-toggle {
        transform: rotate(180deg);
      }

      .result-details {
        display: none;
        padding: 0 20px 20px;
        border-top: 1px solid var(--border);
        border-radius: 0 0 12px 12px;
        background: var(--card-bg);
      }

      .result-item.expanded .result-details {
        display: block;
      }

      .detail-section {
        margin-top: 16px;
      }

      .detail-section h4 {
        font-size: 14px;
        font-weight: 600;
        margin: 0 0 12px 0;
        color: var(--text);
      }

      .detail-grid {
        display: grid;
        grid-template-columns: 120px 1fr;
        gap: 8px 16px;
        font-size: 13px;
      }

      .detail-label {
        color: var(--text-muted);
      }

      .detail-value {
        color: var(--text);
        word-break: break-word;
      }

      .detail-value a {
        color: var(--primary);
        text-decoration: none;
      }

      .detail-value a:hover {
        text-decoration: underline;
      }

      .source-badge {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        padding: 6px 12px;
        border-radius: 8px;
        font-size: 12px;
        font-weight: 600;
        margin-right: 8px;
        letter-spacing: 0.3px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.06);
        transition: all 0.2s ease;
      }

      .source-badge::before {
        content: "";
        width: 8px;
        height: 8px;
        border-radius: 50%;
        flex-shrink: 0;
      }

      .source-badge.openalex {
        background: linear-gradient(
          135deg,
          rgba(79, 70, 229, 0.12) 0%,
          rgba(129, 140, 248, 0.12) 100%
        );
        color: var(--primary);
        border: 1px solid rgba(79, 70, 229, 0.2);
      }

      .source-badge.openalex::before {
        background: linear-gradient(
          135deg,
          var(--primary) 0%,
          var(--primary-light) 100%
        );
        box-shadow: 0 0 6px rgba(79, 70, 229, 0.4);
      }

      .source-badge.crossref {
        background: linear-gradient(
          135deg,
          rgba(245, 158, 11, 0.12) 0%,
          rgba(251, 191, 36, 0.12) 100%
        );
        color: #b45309;
        border: 1px solid rgba(245, 158, 11, 0.25);
      }

      .source-badge.crossref::before {
        background: linear-gradient(135deg, var(--warning) 0%, #fbbf24 100%);
        box-shadow: 0 0 6px rgba(245, 158, 11, 0.4);
      }

      .score-tooltip-wrapper:hover .source-badge {
        transform: translateY(-1px);
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
      }

      /* Tooltip æ ·å¼ */
      .score-tooltip-wrapper {
        position: relative;
        display: inline-flex;
        align-items: center;
        gap: 10px;
        cursor: help;
        padding: 4px 0;
      }

      .score-tooltip {
        position: absolute;
        bottom: calc(100% + 10px);
        left: 0;
        transform: translateX(0);
        background: linear-gradient(135deg, #1e293b 0%, #334155 100%);
        color: white;
        padding: 14px 16px;
        border-radius: 12px;
        font-size: 12px;
        white-space: nowrap;
        opacity: 0;
        visibility: hidden;
        transition: all 0.25s ease;
        z-index: 1000;
        box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2),
          0 4px 10px rgba(0, 0, 0, 0.1);
        min-width: 240px;
        border: 1px solid rgba(255, 255, 255, 0.1);
        pointer-events: none;
      }

      .score-tooltip::after {
        content: "";
        position: absolute;
        top: 100%;
        left: 24px;
        transform: translateX(0);
        border: 8px solid transparent;
        border-top-color: #334155;
      }

      .score-tooltip-wrapper:hover .score-tooltip {
        opacity: 1;
        visibility: visible;
        transform: translateY(-4px);
      }

      .score-tooltip-row {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 5px 0;
        border-bottom: 1px solid rgba(255, 255, 255, 0.08);
      }

      .score-tooltip-row:last-child {
        border-bottom: none;
        padding-top: 10px;
        margin-top: 6px;
        border-top: 1px solid rgba(255, 255, 255, 0.2);
        font-weight: 600;
      }

      .score-tooltip-label {
        color: rgba(255, 255, 255, 0.65);
        font-size: 11px;
      }

      .score-tooltip-value {
        font-family: "SF Mono", "Monaco", "Inconsolata", monospace;
        font-size: 11px;
        padding: 2px 6px;
        border-radius: 4px;
        background: rgba(255, 255, 255, 0.08);
      }

      .score-tooltip-value.good {
        color: #34d399;
        background: rgba(52, 211, 153, 0.15);
      }

      .score-tooltip-value.medium {
        color: #fbbf24;
        background: rgba(251, 191, 36, 0.15);
      }

      .score-tooltip-value.bad {
        color: #f87171;
        background: rgba(248, 113, 113, 0.15);
      }

      .score-inline {
        font-size: 13px;
        color: var(--text-muted);
        font-weight: 500;
        background: var(--bg);
        padding: 4px 10px;
        border-radius: 6px;
        border: 1px solid var(--border);
      }

      /* æŠ˜å å¤´éƒ¨çš„ tooltip ç‰¹æ®Šå®šä½ */
      .result-score-wrapper {
        padding: 0;
      }

      .result-score-wrapper .score-tooltip {
        left: auto;
        right: 0;
        transform: translateX(0);
      }

      .result-score-wrapper .score-tooltip::after {
        left: auto;
        right: 24px;
      }

      .result-score-wrapper:hover .result-score {
        transform: translateY(-1px);
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      }

      .empty-state {
        text-align: center;
        padding: 60px 20px;
        color: var(--text-muted);
      }

      .empty-state svg {
        width: 64px;
        height: 64px;
        margin-bottom: 16px;
        opacity: 0.5;
      }

      .loading-spinner {
        display: inline-block;
        width: 16px;
        height: 16px;
        border: 2px solid rgba(255, 255, 255, 0.3);
        border-radius: 50%;
        border-top-color: white;
        animation: spin 0.8s linear infinite;
      }

      @keyframes spin {
        to {
          transform: rotate(360deg);
        }
      }

      .processing-item {
        background: linear-gradient(
          90deg,
          var(--bg) 25%,
          var(--card-bg) 50%,
          var(--bg) 75%
        );
        background-size: 200% 100%;
        animation: shimmer 1.5s infinite;
        border-radius: 12px;
        padding: 16px 20px;
        margin-bottom: 16px;
        border: 1px solid var(--border);
      }

      @keyframes shimmer {
        0% {
          background-position: 200% 0;
        }
        100% {
          background-position: -200% 0;
        }
      }

      /* Verdict bar */
      .verdict-bar {
        display: flex;
        gap: 8px;
        margin-top: 12px;
      }

      .verdict-segment {
        flex: 1;
        height: 4px;
        border-radius: 2px;
        background: var(--border);
      }

      .verdict-segment.active.high {
        background: var(--success);
      }
      .verdict-segment.active.medium {
        background: var(--warning);
      }
      .verdict-segment.active.low {
        background: var(--danger);
      }

      /* Detail actions */
      .detail-actions {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
      }

      .btn-small {
        padding: 9px 18px;
        font-size: 13px;
        gap: 6px;
        border-radius: 10px;
      }

      .export-section {
        display: none;
        align-items: center;
        justify-content: center;
        gap: 16px;
        margin: 20px 0;
        flex-wrap: wrap;
      }

      .export-section.active {
        display: flex;
      }

      .export-selector {
        display: flex;
        background: var(--bg);
        border-radius: 10px;
        padding: 4px;
        border: 2px solid var(--success);
        box-shadow: 0 4px 12px 0 rgba(16, 185, 129, 0.15);
      }

      .export-option {
        padding: 10px 24px;
        border-radius: 8px;
        font-size: 14px;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.25s ease;
        color: var(--text-muted);
        user-select: none;
        position: relative;
      }

      .export-option:hover {
        color: var(--text);
        background: rgba(16, 185, 129, 0.1);
      }

      .export-option.active {
        background: linear-gradient(135deg, var(--success) 0%, #34d399 100%);
        color: white;
        box-shadow: 0 2px 8px 0 rgba(16, 185, 129, 0.3);
      }

      .toast {
        position: fixed;
        bottom: 80px;
        left: 50%;
        transform: translateX(-50%) translateY(100px);
        background: linear-gradient(
          135deg,
          var(--primary) 0%,
          var(--primary-light) 100%
        );
        color: white;
        padding: 14px 28px;
        border-radius: 12px;
        font-size: 15px;
        font-weight: 500;
        opacity: 0;
        transition: all 0.3s ease;
        z-index: 1000;
        box-shadow: 0 8px 24px 0 rgba(79, 70, 229, 0.4);
      }

      .toast.show {
        transform: translateX(-50%) translateY(0);
        opacity: 1;
      }

      /* å›¾æ ‡æŒ‰é’® */
      .icon-btn {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        width: 36px;
        height: 36px;
        border: 1px solid var(--border);
        border-radius: 10px;
        background: var(--card-bg);
        color: var(--text-muted);
        cursor: pointer;
        transition: all 0.2s ease;
      }

      .icon-btn:hover {
        background: var(--bg);
        color: var(--text);
        border-color: #cbd5e1;
        transform: translateY(-1px);
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
      }

      .icon-btn:active {
        transform: translateY(0);
      }

      .helper-btns {
        display: flex;
        gap: 8px;
        margin-top: 12px;
      }

      /* å¼¹çª—æ ·å¼ */
      .modal-overlay {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.5);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 2000;
        opacity: 0;
        visibility: hidden;
        transition: all 0.3s ease;
        backdrop-filter: blur(4px);
      }

      .modal-overlay.show {
        opacity: 1;
        visibility: visible;
      }

      .modal {
        background: var(--card-bg);
        border-radius: 16px;
        box-shadow: 0 20px 50px rgba(0, 0, 0, 0.2);
        max-width: 600px;
        width: 90%;
        max-height: 80vh;
        overflow: hidden;
        transform: scale(0.9) translateY(20px);
        transition: all 0.3s ease;
      }

      .modal-overlay.show .modal {
        transform: scale(1) translateY(0);
      }

      .modal-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 20px 24px;
        border-bottom: 1px solid var(--border);
        background: linear-gradient(
          135deg,
          var(--primary) 0%,
          var(--primary-light) 100%
        );
        color: white;
      }

      .modal-header h3 {
        margin: 0;
        font-size: 18px;
        font-weight: 600;
      }

      .modal-close {
        width: 32px;
        height: 32px;
        border: none;
        background: rgba(255, 255, 255, 0.2);
        border-radius: 8px;
        color: white;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.2s ease;
      }

      .modal-close:hover {
        background: rgba(255, 255, 255, 0.3);
      }

      .modal-body {
        padding: 24px;
        overflow-y: auto;
        max-height: calc(80vh - 80px);
      }

      .score-table {
        width: 100%;
        border-collapse: collapse;
        font-size: 14px;
      }

      .score-table th,
      .score-table td {
        padding: 12px 16px;
        text-align: left;
        border-bottom: 1px solid var(--border);
      }

      .score-table th {
        background: var(--bg);
        font-weight: 600;
        color: var(--text);
      }

      .score-table tr:last-child td {
        border-bottom: none;
      }

      .score-table .weight {
        color: var(--primary);
        font-weight: 600;
      }

      .verdict-table {
        margin-top: 20px;
      }

      .verdict-table .high {
        color: var(--success);
      }
      .verdict-table .medium {
        color: var(--warning);
      }
      .verdict-table .low {
        color: var(--danger);
      }

      .formula-box {
        background: var(--bg);
        border-radius: 10px;
        padding: 16px;
        margin: 16px 0;
        font-family: "SF Mono", Monaco, monospace;
        font-size: 13px;
        color: var(--text);
        border: 1px solid var(--border);
      }

      .formula-box code {
        color: var(--primary);
        font-weight: 600;
      }

      /* åŒåˆ—å¸ƒå±€ */
      .sources-grid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 16px;
        margin-top: 16px;
      }

      @media (max-width: 768px) {
        .sources-grid {
          grid-template-columns: 1fr;
        }
      }

      .source-card {
        background: var(--bg);
        border-radius: 12px;
        padding: 16px;
        border: 1px solid var(--border);
      }

      .source-card h4 {
        margin: 0 0 12px 0;
        font-size: 14px;
        display: flex;
        align-items: center;
        justify-content: space-between;
        flex-wrap: wrap;
        gap: 8px;
      }

      .source-card .detail-grid {
        font-size: 12px;
      }

      .source-card .detail-label {
        font-size: 11px;
      }

      .link-badge {
        display: inline-flex;
        align-items: center;
        gap: 4px;
        padding: 4px 10px;
        border-radius: 6px;
        font-size: 11px;
        font-weight: 500;
        text-decoration: none;
        transition: all 0.2s ease;
        background: rgba(79, 70, 229, 0.1);
        color: var(--primary);
        border: 1px solid rgba(79, 70, 229, 0.2);
      }

      .link-badge:hover {
        background: rgba(79, 70, 229, 0.15);
        transform: translateY(-1px);
        text-decoration: none;
      }

      .link-badge svg {
        width: 12px;
        height: 12px;
      }

      /* æ ¼å¼ç¤ºä¾‹æ ·å¼ */
      .format-example {
        margin-bottom: 20px;
        padding-bottom: 16px;
        border-bottom: 1px solid var(--border);
      }

      .format-example:last-of-type {
        border-bottom: none;
        margin-bottom: 0;
        padding-bottom: 0;
      }

      .format-example h4 {
        margin: 0 0 10px 0;
        font-size: 14px;
        color: var(--text);
      }

      .example-box {
        background: var(--bg);
        border-radius: 8px;
        padding: 12px 14px;
        margin-bottom: 8px;
        border: 1px solid var(--border);
        overflow-x: auto;
      }

      .example-box:last-child {
        margin-bottom: 0;
      }

      .example-box code {
        font-family: "SF Mono", Monaco, Consolas, "Courier New", monospace;
        font-size: 12px;
        color: var(--text);
        white-space: pre-wrap;
        word-break: break-all;
      }
    </style>
  </head>
  <body>
    <div class="header">
      <h1>å¼•ç”¨çœŸä¼ªå¿«é€Ÿæ ¡éªŒ</h1>
      <p>
        é€šè¿‡ OpenAlex ä¸ Crossref
        åŒæ•°æ®æºäº¤å‰éªŒè¯ï¼Œæ™ºèƒ½è§£æå¼•ç”¨å­—æ®µå¹¶è¯„ä¼°å¯ä¿¡åº¦ã€‚æ”¯æŒ GB/T
        7714ã€APAã€MLAã€IEEEã€Chicagoã€Vancouver
        ç­‰å¤šç§æ ¼å¼ï¼Œè‡ªåŠ¨è¯†åˆ«å¹¶å®¹é”™è§£æã€‚
      </p>
    </div>

    <div class="card">
      <div class="input-section">
        <div>
          <label for="citation">ç²˜è´´å¼•ç”¨æ¡ç›®ï¼ˆæ”¯æŒå¤šæ¡ï¼Œæ¯è¡Œä¸€æ¡ï¼‰</label>
          <textarea
            id="citation"
            placeholder='åœ¨æ­¤ç²˜è´´å¼•ç”¨æ¡ç›®ï¼Œæ¯è¡Œä¸€æ¡ã€‚æ”¯æŒå¤šç§æ ¼å¼ï¼š&#10;&#10;ä¸­æ–‡ GB/T 7714: å¼ ä¸‰. è®ºæ–‡æ ‡é¢˜[J]. æœŸåˆŠå, 2020, 10(2): 1-20.&#10;APA: Author, A. A. (2020). Title. Journal, 10(2), 1-20.&#10;IEEE: A. Author, "Title," Journal, vol. 10, no. 2, pp. 1-20, 2020.&#10;MLA: Author. "Title." Journal 10.2 (2020): 1-20.&#10;Vancouver: Author. Title. Journal. 2020;10(2):1-20.&#10;&#10;æ ¼å¼ä¹±äº†ä¹Ÿæ²¡å…³ç³»ï¼Œç³»ç»Ÿä¼šæ™ºèƒ½è¯†åˆ«ï¼'
          ></textarea>
          <div class="hint">
            ğŸ’¡ æç¤ºï¼šæ”¯æŒ GB/T 7714ã€APAã€MLAã€IEEEã€Chicagoã€Vancouver
            ç­‰æ ¼å¼ã€‚æ¯è¡Œä¸€æ¡ï¼Œæ ¼å¼ä¸è§„èŒƒä¹Ÿèƒ½æ™ºèƒ½è§£æã€‚
          </div>
        </div>
        <div>
          <label for="mailto">è”ç³»é‚®ç®±ï¼ˆå¯é€‰ï¼‰</label>
          <input type="email" id="mailto" placeholder="you@example.com" />
          <div class="hint">
            æä¾›é‚®ç®±å¯è¿›å…¥ OpenAlex/Crossref çš„ polite poolï¼Œè·å¾—æ›´ç¨³å®šçš„å“åº”ã€‚
          </div>

          <div class="actions">
            <button
              id="run"
              class="btn btn-primary"
              title="è°ƒç”¨ OpenAlex å’Œ Crossref API æ ¡éªŒå¼•ç”¨çœŸå®æ€§"
            >
              å¼€å§‹æ ¡éªŒ
            </button>
            <button
              id="extractBib"
              class="btn btn-extract"
              title="ç›´æ¥è§£æå¼•ç”¨ç”Ÿæˆ BibTeXï¼Œä¸è°ƒç”¨ API"
            >
              ç”Ÿæˆ BibTeX
            </button>
            <button id="clear" class="btn btn-clear" title="æ¸…ç©ºè¾“å…¥å’Œç»“æœ">
              æ¸…ç©º
            </button>
          </div>

          <div class="helper-btns">
            <button
              id="showFormatGuide"
              class="btn btn-success btn-small"
              title="æŸ¥çœ‹æ”¯æŒçš„æ ¼å¼"
            >
              <svg
                width="14"
                height="14"
                viewBox="0 0 24 24"
                fill="none"
                stroke="currentColor"
                stroke-width="2.5"
              >
                <path
                  d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"
                ></path>
                <polyline points="14 2 14 8 20 8"></polyline>
                <line x1="16" y1="13" x2="8" y2="13"></line>
                <line x1="16" y1="17" x2="8" y2="17"></line>
                <polyline points="10 9 9 9 8 9"></polyline>
              </svg>
              æ ¼å¼ç¤ºä¾‹
            </button>
            <button
              id="showScoreRules"
              class="btn btn-info btn-small"
              title="æŸ¥çœ‹æ‰“åˆ†æ ‡å‡†"
            >
              <svg
                width="14"
                height="14"
                viewBox="0 0 24 24"
                fill="none"
                stroke="currentColor"
                stroke-width="2.5"
              >
                <circle cx="12" cy="12" r="10"></circle>
                <path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"></path>
                <line x1="12" y1="17" x2="12.01" y2="17"></line>
              </svg>
              æ‰“åˆ†æ ‡å‡†
            </button>
            <button
              id="feedback"
              class="btn btn-github btn-small"
              title="åé¦ˆé—®é¢˜"
            >
              <svg
                width="14"
                height="14"
                viewBox="0 0 24 24"
                fill="none"
                stroke="currentColor"
                stroke-width="2.5"
              >
                <path
                  d="M21 11.5a8.38 8.38 0 0 1-.9 3.8 8.5 8.5 0 0 1-7.6 4.7 8.38 8.38 0 0 1-3.8-.9L3 21l1.9-5.7a8.38 8.38 0 0 1-.9-3.8 8.5 8.5 0 0 1 4.7-7.6 8.38 8.38 0 0 1 3.8-.9h.5a8.48 8.48 0 0 1 8 8v.5z"
                ></path>
              </svg>
              é—®é¢˜åé¦ˆ
            </button>
          </div>
        </div>
      </div>
    </div>

    <div id="progress" class="progress-container">
      <div class="card" style="padding: 16px 20px">
        <div class="progress-bar">
          <div class="progress-fill" id="progressFill"></div>
        </div>
        <div class="progress-text">
          <span id="progressStatus">æ­£åœ¨æ ¡éªŒ...</span>
          <span id="progressCount">0 / 0</span>
        </div>
      </div>
    </div>

    <div id="summary" class="summary">
      <div class="stat-card total">
        <div class="stat-value" id="statTotal">0</div>
        <div class="stat-label">æ€»æ¡ç›®</div>
      </div>
      <div class="stat-card high">
        <div class="stat-value" id="statHigh">0</div>
        <div class="stat-label">é«˜å¯ä¿¡</div>
      </div>
      <div class="stat-card medium">
        <div class="stat-value" id="statMedium">0</div>
        <div class="stat-label">ä¸­å¯ä¿¡</div>
      </div>
      <div class="stat-card low">
        <div class="stat-value" id="statLow">0</div>
        <div class="stat-label">ä½å¯ä¿¡</div>
      </div>
    </div>

    <div id="exportSection" class="export-section">
      <div class="export-selector">
        <div class="export-option active" data-value="all">å…¨éƒ¨</div>
        <div class="export-option" data-value="high">é«˜å¯ä¿¡</div>
      </div>
      <button id="exportBib" class="btn btn-primary" title="ä¸‹è½½ BibTeX æ–‡ä»¶">
        <svg
          width="16"
          height="16"
          viewBox="0 0 24 24"
          fill="none"
          stroke="currentColor"
          stroke-width="2.5"
        >
          <path d="M21 15v4a2 2 0 01-2 2H5a2 2 0 01-2-2v-4"></path>
          <polyline points="7 10 12 15 17 10"></polyline>
          <line x1="12" y1="15" x2="12" y2="3"></line>
        </svg>
        ä¸‹è½½ BibTeX
      </button>
      <button id="copyBib" class="btn btn-copy" title="å¤åˆ¶ BibTeX åˆ°å‰ªè´´æ¿">
        <svg
          width="16"
          height="16"
          viewBox="0 0 24 24"
          fill="none"
          stroke="currentColor"
          stroke-width="2.5"
        >
          <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
          <path d="M5 15H4a2 2 0 01-2-2V4a2 2 0 012-2h9a2 2 0 012 2v1"></path>
        </svg>
        å¤åˆ¶ BibTeX
      </button>
    </div>

    <div id="results"></div>

    <div id="toast" class="toast">å·²å¤åˆ¶åˆ°å‰ªè´´æ¿</div>

    <!-- æ‰“åˆ†æ ‡å‡†å¼¹çª— -->
    <div id="scoreRulesModal" class="modal-overlay">
      <div class="modal">
        <div class="modal-header">
          <h3>æ‰“åˆ†æ ‡å‡†è¯´æ˜</h3>
          <button class="modal-close" onclick="closeScoreRulesModal()">
            <svg
              width="18"
              height="18"
              viewBox="0 0 24 24"
              fill="none"
              stroke="currentColor"
              stroke-width="2"
            >
              <line x1="18" y1="6" x2="6" y2="18"></line>
              <line x1="6" y1="6" x2="18" y2="18"></line>
            </svg>
          </button>
        </div>
        <div class="modal-body">
          <h4 style="margin: 0 0 12px 0; color: var(--text)">å­—æ®µæƒé‡</h4>
          <table class="score-table">
            <thead>
              <tr>
                <th>å­—æ®µ</th>
                <th>æƒé‡</th>
                <th>è®¡ç®—æ–¹å¼</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>æ ‡é¢˜</td>
                <td class="weight">45%</td>
                <td>Jaccard ç›¸ä¼¼åº¦</td>
              </tr>
              <tr>
                <td>ä½œè€…</td>
                <td class="weight">15%</td>
                <td>å§“æ°åŒ¹é… + Jaccard</td>
              </tr>
              <tr>
                <td>æœŸåˆŠ</td>
                <td class="weight">12%</td>
                <td>ç¼–è¾‘è·ç¦» + å‰ç¼€åŒ¹é…</td>
              </tr>
              <tr>
                <td>å¹´ä»½</td>
                <td class="weight">10%</td>
                <td>ç²¾ç¡®åŒ¹é… (0/1)</td>
              </tr>
              <tr>
                <td>å·å·</td>
                <td class="weight">6%</td>
                <td>ç²¾ç¡®åŒ¹é… (0/1)</td>
              </tr>
              <tr>
                <td>æœŸå·</td>
                <td class="weight">4%</td>
                <td>ç²¾ç¡®åŒ¹é… (0/1)</td>
              </tr>
              <tr>
                <td>é¦–é¡µ</td>
                <td class="weight">4%</td>
                <td>ç²¾ç¡®åŒ¹é… (0/1)</td>
              </tr>
              <tr>
                <td>æœ«é¡µ</td>
                <td class="weight">4%</td>
                <td>ç²¾ç¡®åŒ¹é… (0/1)</td>
              </tr>
            </tbody>
          </table>

          <h4 style="margin: 20px 0 12px 0; color: var(--text)">
            ç»¼åˆè¯„åˆ†å…¬å¼
          </h4>
          <div class="formula-box">
            <code>ç»¼åˆåˆ†</code> = max(OA, CR) Ã— <code>0.6</code> + min(OA, CR) Ã—
            <code>0.4</code>
            <div
              style="margin-top: 8px; font-size: 11px; color: var(--text-muted)"
            >
              OA = OpenAlex å¾—åˆ†ï¼ŒCR = Crossref å¾—åˆ†
            </div>
          </div>

          <h4 style="margin: 20px 0 12px 0; color: var(--text)">å¯ä¿¡åº¦ç­‰çº§</h4>
          <table class="score-table verdict-table">
            <thead>
              <tr>
                <th>ç­‰çº§</th>
                <th>åˆ†æ•°èŒƒå›´</th>
                <th>è¯´æ˜</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td class="high">é«˜å¯ä¿¡</td>
                <td>â‰¥ 0.78</td>
                <td>å¼ºåŒ¹é…ï¼Œå¼•ç”¨åŸºæœ¬å¯ä¿¡</td>
              </tr>
              <tr>
                <td class="medium">ä¸­å¯ä¿¡</td>
                <td>0.55 - 0.78</td>
                <td>éƒ¨åˆ†åŒ¹é…ï¼Œå»ºè®®æ ¸å¯¹</td>
              </tr>
              <tr>
                <td class="low">ä½å¯ä¿¡</td>
                <td>&lt; 0.55</td>
                <td>åŒ¹é…åº¦ä½ï¼Œå¯èƒ½ä¼ªé€ </td>
              </tr>
            </tbody>
          </table>

          <h4 style="margin: 20px 0 12px 0; color: var(--text)">ç‰¹æ®Šå¤„ç†</h4>
          <ul
            style="
              margin: 0;
              padding-left: 20px;
              color: var(--text-muted);
              font-size: 14px;
              line-height: 1.8;
            "
          >
            <li>
              <strong>æœŸåˆŠç¼©å†™</strong>ï¼šæ”¯æŒ "Opt. Express" åŒ¹é… "Optics
              Express"
            </li>
            <li>
              <strong>ä½œè€…ç¼©å†™</strong>ï¼šæ”¯æŒ "G. Lazarev" åŒ¹é… "Gleb Lazarev"
            </li>
            <li>
              <strong>DOI ä¼˜å…ˆ</strong>ï¼šå¦‚æä¾› DOIï¼Œå°†ç²¾ç¡®æŸ¥è¯¢è€Œéæ¨¡ç³Šæœç´¢
            </li>
          </ul>
        </div>
      </div>
    </div>

    <!-- æ ¼å¼ç¤ºä¾‹å¼¹çª— -->
    <div id="formatGuideModal" class="modal-overlay">
      <div class="modal" style="max-width: 800px">
        <div
          class="modal-header"
          style="background: linear-gradient(135deg, #10b981 0%, #34d399 100%)"
        >
          <h3>ğŸ“š æ”¯æŒçš„å‚è€ƒæ–‡çŒ®æ ¼å¼</h3>
          <button class="modal-close" onclick="closeFormatGuideModal()">
            <svg
              width="18"
              height="18"
              viewBox="0 0 24 24"
              fill="none"
              stroke="currentColor"
              stroke-width="2"
            >
              <line x1="18" y1="6" x2="6" y2="18"></line>
              <line x1="6" y1="6" x2="18" y2="18"></line>
            </svg>
          </button>
        </div>
        <div class="modal-body">
          <p
            style="
              color: var(--text-muted);
              margin: 0 0 20px 0;
              font-size: 14px;
            "
          >
            ç³»ç»Ÿæ”¯æŒæ™ºèƒ½è§£æå¤šç§å¸¸è§å‚è€ƒæ–‡çŒ®æ ¼å¼ã€‚å³ä½¿æ ¼å¼ä¸å®Œå…¨è§„èŒƒï¼Œä¹Ÿèƒ½å°½é‡è¯†åˆ«å…³é”®ä¿¡æ¯ã€‚
          </p>

          <div class="format-example">
            <h4>ğŸ‡¨ğŸ‡³ ä¸­æ–‡ GB/T 7714 æ ¼å¼</h4>
            <div class="example-box">
              <code>å¼ ä¸‰, æå››. äººå·¥æ™ºèƒ½åœ¨åŒ»å­¦å½±åƒä¸­çš„åº”ç”¨ç ”ç©¶[J]. è®¡ç®—æœºå­¦æŠ¥, 2020, 43(5): 1024-1035.</code>
            </div>
            <div class="example-box">
              <code>ç‹äº”. æ·±åº¦å­¦ä¹ åŸç†ä¸å®è·µ[M]. åŒ—äº¬: æ¸…åå¤§å­¦å‡ºç‰ˆç¤¾, 2019: 56-78.</code>
            </div>
          </div>

          <div class="format-example">
            <h4>ğŸ“˜ APA æ ¼å¼ (ç¾å›½å¿ƒç†å­¦ä¼š)</h4>
            <div class="example-box">
              <code>Smith, J. A., & Johnson, B. C. (2020). Deep learning in medical imaging. Nature Medicine, 26(3), 317-325.</code>
            </div>
          </div>

          <div class="format-example">
            <h4>ğŸ“— MLA æ ¼å¼ (ç°ä»£è¯­è¨€åä¼š)</h4>
            <div class="example-box">
              <code>Smith, John A. "Deep Learning in Medical Imaging." Nature Medicine 26.3 (2020): 317-325.</code>
            </div>
          </div>

          <div class="format-example">
            <h4>âš¡ IEEE æ ¼å¼</h4>
            <div class="example-box">
              <code>J. A. Smith, "Deep learning in medical imaging," Nature Medicine, vol. 26, no. 3, pp. 317-325, 2020.</code>
            </div>
          </div>

          <div class="format-example">
            <h4>ğŸ“™ Chicago æ ¼å¼</h4>
            <div class="example-box">
              <code>Smith, John A. "Deep Learning in Medical Imaging." Nature Medicine 26, no. 3 (2020): 317-325.</code>
            </div>
          </div>

          <div class="format-example">
            <h4>ğŸ¥ Vancouver æ ¼å¼ (åŒ»å­¦)</h4>
            <div class="example-box">
              <code>Smith JA, Johnson BC. Deep learning in medical imaging. Nature Medicine. 2020;26(3):317-325.</code>
            </div>
          </div>

          <div class="format-example">
            <h4>ğŸ“‹ Harvard æ ¼å¼</h4>
            <div class="example-box">
              <code>Smith, J.A. (2020) Deep learning in medical imaging. Nature Medicine, 26(3), pp. 317-325.</code>
            </div>
          </div>

          <div
            style="
              background: rgba(79, 70, 229, 0.08);
              border-radius: 12px;
              padding: 16px;
              margin-top: 20px;
              border: 1px solid rgba(79, 70, 229, 0.15);
            "
          >
            <h4
              style="margin: 0 0 10px 0; color: var(--primary); font-size: 14px"
            >
              ğŸ’¡ æ™ºèƒ½å®¹é”™æç¤º
            </h4>
            <ul
              style="
                margin: 0;
                padding-left: 20px;
                color: var(--text-muted);
                font-size: 13px;
                line-height: 1.8;
              "
            >
              <li>è‡ªåŠ¨è¯†åˆ«å¹¶ç§»é™¤å¼€å¤´çš„åºå·ï¼ˆå¦‚ [1]ã€1.ã€1) ç­‰ï¼‰</li>
              <li>å…¼å®¹å„ç§å¼•å·æ ¼å¼ï¼ˆ"" ã€Œã€ ã€Šã€‹ï¼‰</li>
              <li>å…¼å®¹å„ç§ç ´æŠ˜å·ï¼ˆ- â€“ â€” âˆ’ï¼‰</li>
              <li>æ ¼å¼ä¸è§„èŒƒæ—¶è‡ªåŠ¨å°è¯•æ™ºèƒ½è§£æ</li>
              <li>æä¾› DOI å¯è·å¾—æœ€ç²¾ç¡®çš„åŒ¹é…ç»“æœ</li>
            </ul>
          </div>
        </div>
      </div>
    </div>

    <script>
      /** ---------- å·¥å…·å‡½æ•° ---------- */
      function norm(s) {
        return (s || "")
          .toLowerCase()
          .replace(/[\[\]\(\)\{\},.:;'"`~!@#$%^&*_+=<>?/\\|-]/g, " ")
          .replace(/\s+/g, " ")
          .trim();
      }

      function tokens(s) {
        return new Set(norm(s).split(" ").filter(Boolean));
      }

      function jaccard(a, b) {
        const A = tokens(a),
          B = tokens(b);
        if (A.size === 0 || B.size === 0) return 0;
        let inter = 0;
        for (const t of A) if (B.has(t)) inter++;
        const union = A.size + B.size - inter;
        return inter / union;
      }

      // ç¼–è¾‘è·ç¦»ï¼ˆLevenshtein Distanceï¼‰
      function levenshtein(s1, s2) {
        const m = s1.length,
          n = s2.length;
        if (m === 0) return n;
        if (n === 0) return m;

        const dp = Array.from({ length: m + 1 }, () => Array(n + 1).fill(0));
        for (let i = 0; i <= m; i++) dp[i][0] = i;
        for (let j = 0; j <= n; j++) dp[0][j] = j;

        for (let i = 1; i <= m; i++) {
          for (let j = 1; j <= n; j++) {
            const cost = s1[i - 1] === s2[j - 1] ? 0 : 1;
            dp[i][j] = Math.min(
              dp[i - 1][j] + 1, // åˆ é™¤
              dp[i][j - 1] + 1, // æ’å…¥
              dp[i - 1][j - 1] + cost // æ›¿æ¢
            );
          }
        }
        return dp[m][n];
      }

      // å½’ä¸€åŒ–ç¼–è¾‘è·ç¦»ç›¸ä¼¼åº¦ï¼ˆ0-1ï¼Œ1ä¸ºå®Œå…¨ç›¸åŒï¼‰
      function editSimilarity(a, b) {
        if (!a || !b) return 0;
        const s1 = norm(a),
          s2 = norm(b);
        if (s1 === s2) return 1;
        if (s1.length === 0 || s2.length === 0) return 0;
        const dist = levenshtein(s1, s2);
        const maxLen = Math.max(s1.length, s2.length);
        return 1 - dist / maxLen;
      }

      // æœŸåˆŠåç›¸ä¼¼åº¦ï¼ˆç»“åˆå¤šç§ç­–ç•¥ï¼ŒåŠ æƒç»„åˆï¼‰
      function journalSimilarity(input, api) {
        if (!input || !api) return 0;

        // é¢„å¤„ç†ï¼šç§»é™¤ç‚¹å·ã€ç»Ÿä¸€å°å†™ã€å»é™¤å¤šä½™ç©ºæ ¼
        const cleanInput = input
          .toLowerCase()
          .replace(/\./g, "")
          .replace(/\s+/g, " ")
          .trim();
        const cleanApi = api
          .toLowerCase()
          .replace(/\./g, "")
          .replace(/\s+/g, " ")
          .trim();

        // å®Œå…¨åŒ¹é…
        if (cleanInput === cleanApi) return 1;

        const inputWords = cleanInput.split(" ").filter(Boolean);
        const apiWords = cleanApi.split(" ").filter(Boolean);

        // å‰ç¼€åŒ¹é…ï¼ˆæ›´ä¸¥æ ¼ï¼šè¦æ±‚å‰ç¼€é•¿åº¦è‡³å°‘3ä¸ªå­—ç¬¦ï¼Œä¸”åŒ¹é…æ¯”ä¾‹é«˜ï¼‰
        let prefixMatches = 0;
        let totalChecked = 0;
        for (const iw of inputWords) {
          if (iw.length < 2) continue; // è·³è¿‡å¤ªçŸ­çš„è¯
          totalChecked++;
          for (const aw of apiWords) {
            // è¦æ±‚å‰ç¼€é•¿åº¦è‡³å°‘ä¸ºè¾ƒçŸ­è¯çš„60%
            const minPrefixLen = Math.max(
              3,
              Math.floor(Math.min(iw.length, aw.length) * 0.6)
            );
            if (aw.startsWith(iw) || iw.startsWith(aw)) {
              const commonLen = Math.min(iw.length, aw.length);
              if (commonLen >= minPrefixLen) {
                prefixMatches++;
                break;
              }
            }
          }
        }
        // è¦æ±‚è‡³å°‘80%çš„è¯åŒ¹é…æˆåŠŸ
        const prefixScore =
          totalChecked > 0 && prefixMatches / totalChecked >= 0.8
            ? prefixMatches / Math.max(inputWords.length, apiWords.length)
            : 0;

        // ç¼–è¾‘è·ç¦»ç›¸ä¼¼åº¦
        const editScore = editSimilarity(cleanInput, cleanApi);

        // Jaccard ç›¸ä¼¼åº¦
        const jaccardScore = jaccard(input, api);

        // åŠ æƒç»„åˆï¼šç¼–è¾‘è·ç¦»æƒé‡æœ€é«˜ï¼Œå‰ç¼€åŒ¹é…æ¬¡ä¹‹ï¼ŒJaccard ä½œä¸ºè¡¥å……
        // å¦‚æœå‰ç¼€åŒ¹é…æˆåŠŸç‡é«˜ï¼Œç»™äºˆé¢å¤–åŠ æˆ
        const weightedScore =
          editScore * 0.5 + prefixScore * 0.3 + jaccardScore * 0.2;

        // å¦‚æœæŸä¸ªç­–ç•¥å¾—åˆ†ç‰¹åˆ«é«˜ï¼ˆ>0.9ï¼‰ï¼Œå¯ä»¥é€‚å½“æå‡æ€»åˆ†
        const maxScore = Math.max(prefixScore, editScore, jaccardScore);
        if (maxScore > 0.9) {
          return Math.min(1, weightedScore * 0.7 + maxScore * 0.3);
        }

        return weightedScore;
      }

      // ä½œè€…ç›¸ä¼¼åº¦ï¼ˆå¤„ç†ç¼©å†™æƒ…å†µï¼ŒåŠ æƒç»„åˆï¼‰
      function authorSimilarity(inputAuthors, apiAuthors) {
        if (!inputAuthors?.length || !apiAuthors) return 0;

        const inputStr = Array.isArray(inputAuthors)
          ? inputAuthors.join(" ")
          : inputAuthors;
        const apiStr = apiAuthors;

        // æå–å§“æ°ï¼ˆé€šå¸¸æ˜¯æœ€åä¸€ä¸ªè¯æˆ–é€—å·å‰çš„è¯ï¼‰
        const extractLastNames = (str) => {
          // åˆ†å‰²ä½œè€…ï¼Œå¤„ç† "and" å’Œé€—å·
          const authors = str
            .split(/,\s*(?:and\s+)?|\s+and\s+/i)
            .filter(Boolean);
          return authors
            .map((a) => {
              const parts = a.trim().split(/\s+/);
              // å¦‚æœæ˜¯ "Lastname, Firstname" æ ¼å¼
              if (a.includes(",")) {
                return parts[0].replace(",", "").toLowerCase();
              }
              // å¦åˆ™å–æœ€åä¸€ä¸ªè¯ä½œä¸ºå§“æ°
              return parts[parts.length - 1].toLowerCase();
            })
            .filter((n) => n.length > 1);
        };

        const inputLastNames = extractLastNames(inputStr);
        const apiLastNames = extractLastNames(apiStr);

        // å§“æ°åŒ¹é…
        let lastNameMatches = 0;
        let partialMatches = 0;
        for (const iln of inputLastNames) {
          for (const aln of apiLastNames) {
            // å®Œå…¨åŒ¹é…
            if (iln === aln) {
              lastNameMatches++;
              break;
            }
            // å‰ç¼€åŒ¹é…æˆ–é«˜ç¼–è¾‘ç›¸ä¼¼åº¦ï¼ˆéƒ¨åˆ†åŒ¹é…ï¼Œç»™äºˆè¾ƒä½åˆ†æ•°ï¼‰
            if (
              (iln.length >= 3 && aln.startsWith(iln)) ||
              (aln.length >= 3 && iln.startsWith(aln)) ||
              editSimilarity(iln, aln) > 0.8
            ) {
              partialMatches++;
              break;
            }
          }
        }

        const totalAuthors = Math.max(
          inputLastNames.length,
          apiLastNames.length
        );
        // å®Œå…¨åŒ¹é…å¾—æ»¡åˆ†ï¼Œéƒ¨åˆ†åŒ¹é…å¾— 0.7 åˆ†
        const lastNameScore =
          totalAuthors > 0
            ? (lastNameMatches + partialMatches * 0.7) / totalAuthors
            : 0;

        // åŸå§‹ Jaccard ä½œä¸ºè¡¥å……
        const jaccardScore = jaccard(inputStr, apiStr);

        // åŠ æƒç»„åˆï¼šå§“æ°åŒ¹é…æƒé‡é«˜ï¼ŒJaccard ä½œä¸ºè¡¥å……
        return lastNameScore * 0.7 + jaccardScore * 0.3;
      }

      function pickBest(items, scoreFn) {
        let best = null,
          bestScore = -1,
          bestDetails = null;
        for (const it of items) {
          const result = scoreFn(it);
          const sc = typeof result === "object" ? result.total : result;
          const details = typeof result === "object" ? result.details : null;
          if (sc > bestScore) {
            best = it;
            bestScore = sc;
            bestDetails = details;
          }
        }
        return { best, bestScore, bestDetails };
      }

      function esc(s) {
        return (s ?? "").toString().replace(
          /[&<>"']/g,
          (m) =>
            ({
              "&": "&amp;",
              "<": "&lt;",
              ">": "&gt;",
              '"': "&quot;",
              "'": "&#39;",
            }[m])
        );
      }

      /** ---------- BibTeX ç”Ÿæˆ ---------- */
      // ä»…åŸºäºè§£æçš„å¼•ç”¨ç”Ÿæˆ BibTeXï¼ˆä¸è°ƒç”¨ APIï¼‰
      function generateBibTeXFromParsed(parsed) {
        const type = parsed.journal ? "article" : "book";
        const year = parsed.year || "n.d.";
        const title = parsed.title || "";
        const journal = parsed.journal || "";
        const volume = parsed.volume || "";
        const number = parsed.issue || "";
        const pages =
          parsed.firstPage && parsed.lastPage
            ? `${parsed.firstPage}--${parsed.lastPage}`
            : parsed.firstPage || "";

        const doi = parsed.doi || "";
        const url = doi ? `https://doi.org/${doi}` : "";

        // å¤„ç†ä½œè€…
        const authors = (parsed.authors || []).map((a) => {
          // å‡è®¾ä½œè€…å·²ç»æ˜¯å§“æ°æ ¼å¼ï¼Œç›´æ¥ä½¿ç”¨
          return a;
        });

        const authorStr = authors.length > 0 ? authors.join(" and\n  ") : "";

        // ç”Ÿæˆ citation key
        let firstAuthor = authors[0] || "Unknown";
        const firstWord = (title || "").split(/\s+/)[0] || "";
        const cleanWord = firstWord.replace(/[^a-zA-Z0-9]/g, "");
        const citeKey = `${firstAuthor}${year}${cleanWord}`;

        let bibtex = `@${type}{${citeKey},
`;

        if (authorStr)
          bibtex += `  author = {${authorStr}},
`;
        if (title)
          bibtex += `  title = {${title}},
`;
        if (journal)
          bibtex += `  journal = {${journal}},
`;
        if (year)
          bibtex += `  year = {${year}},
`;
        if (volume)
          bibtex += `  volume = {${volume}},
`;
        if (number)
          bibtex += `  number = {${number}},
`;
        if (pages)
          bibtex += `  pages = {${pages}},
`;
        if (doi)
          bibtex += `  doi = {${doi}},
`;
        if (url)
          bibtex += `  url = {${url}},
`;

        // ç§»é™¤æœ«å°¾é€—å·
        bibtex = bibtex.replace(/,\n$/, "\n");
        bibtex += "}";

        return bibtex;
      }

      // ä» OpenAlex/Crossref æ•°æ®ç”Ÿæˆ BibTeX
      function generateBibTeX(result) {
        const { parsed, oaBest, crBest } = result;
        const oa = oaBest?.best;
        const cr = crBest?.best;

        // ä¼˜å…ˆä½¿ç”¨ API è¿”å›çš„åŸå§‹ BibTeX
        const rawBib = oa?.biblio?.raw || cr?.["bibliographic-metadata"]?.raw;
        if (
          rawBib &&
          typeof rawBib === "string" &&
          rawBib.trim().startsWith("@")
        ) {
          // æå– citation key
          const entryMatch = rawBib.match(/@(\w+)\s*\{([^,]+),/);
          if (entryMatch) {
            return rawBib.trim();
          }
        }

        // è‡ªè¡Œæ„å»º BibTeX
        const type = parsed.journal ? "article" : "book";
        const year =
          oa?.publication_year ||
          cr?.issued?.["date-parts"]?.[0]?.[0] ||
          parsed.year ||
          "n.d.";
        const title = oa?.title || cr?.title?.[0] || parsed.title || "";

        // æå–ä½œè€…
        let authors = [];
        if (oa?.authorships) {
          authors = oa.authorships.map((a) => {
            const name = a.author?.display_name || "";
            const parts = name.trim().split(/\s+/);
            if (parts.length >= 2) {
              const last = parts[parts.length - 1];
              const first = parts.slice(0, -1).join(" ");
              return `${last}, ${first}`;
            }
            return name;
          });
        } else if (cr?.author) {
          authors = cr.author
            .map((a) => {
              const family = a.family || "";
              const given = a.given || "";
              return family ? (given ? `${family}, ${given}` : family) : "";
            })
            .filter(Boolean);
        } else if (parsed.authors?.length) {
          authors = parsed.authors;
        }

        const authorStr = authors.length > 0 ? authors.join(" and\n  ") : "";

        const journal =
          oa?.primary_location?.source?.display_name ||
          cr?.["container-title"]?.[0] ||
          parsed.journal ||
          "";

        const volume = oa?.biblio?.volume || cr?.volume || parsed.volume || "";
        const number = oa?.biblio?.issue || cr?.issue || parsed.issue || "";
        const pages =
          oa?.biblio?.first_page && oa?.biblio?.last_page
            ? `${oa.biblio.first_page}--${oa.biblio.last_page}`
            : cr?.page || parsed.firstPage
            ? parsed.firstPage && parsed.lastPage
              ? `${parsed.firstPage}--${parsed.lastPage}`
              : cr?.page || ""
            : "";

        const doi = oa?.doi || cr?.DOI || parsed.doi || "";
        const url = oa?.id || (doi ? `https://doi.org/${doi}` : "");

        // ç”Ÿæˆ citation key: ç¬¬ä¸€ä½œè€…å§“æ°+å¹´ä»½+é¦–è¯
        let firstAuthor = authors[0] || "";
        if (firstAuthor.includes(",")) {
          firstAuthor = firstAuthor.split(",")[0].trim();
        }
        const firstWord = (title || "").split(/\s+/)[0] || "";
        const cleanWord = firstWord.replace(/[^a-zA-Z0-9]/g, "");
        const citeKey = `${firstAuthor}${year}${cleanWord}`;

        let bibtex = `@${type}{${citeKey},
`;

        if (authorStr)
          bibtex += `  author = {${authorStr}},
`;
        if (title)
          bibtex += `  title = {${title}},
`;
        if (journal)
          bibtex += `  journal = {${journal}},
`;
        if (year)
          bibtex += `  year = {${year}},
`;
        if (volume)
          bibtex += `  volume = {${volume}},
`;
        if (number)
          bibtex += `  number = {${number}},
`;
        if (pages)
          bibtex += `  pages = {${pages}},
`;
        if (doi)
          bibtex += `  doi = {${doi}},
`;
        if (url)
          bibtex += `  url = {${url}},
`;

        // ç§»é™¤æœ«å°¾é€—å·
        bibtex = bibtex.replace(/,\n$/, "\n");
        bibtex += "}";

        return bibtex;
      }

      // å¤åˆ¶åˆ°å‰ªè´´æ¿
      async function copyToClipboard(text) {
        try {
          await navigator.clipboard.writeText(text);
          return true;
        } catch (e) {
          // å›é€€æ–¹æ¡ˆ
          const textarea = document.createElement("textarea");
          textarea.value = text;
          textarea.style.position = "fixed";
          textarea.style.opacity = "0";
          document.body.appendChild(textarea);
          textarea.select();
          try {
            document.execCommand("copy");
            document.body.removeChild(textarea);
            return true;
          } catch (e2) {
            document.body.removeChild(textarea);
            return false;
          }
        }
      }

      // ä¸‹è½½æ–‡ä»¶
      function downloadFile(content, filename) {
        const blob = new Blob([content], { type: "text/plain;charset=utf-8" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }

      /** ---------- è§£æå¼•ç”¨ ---------- */
      function parseCitation(raw) {
        // é¢„å¤„ç†ï¼šæ ‡å‡†åŒ–è¾“å…¥
        let s = raw.trim();
        // ç§»é™¤å¼€å¤´çš„åºå·å¦‚ [1], 1., 1)
        s = s.replace(/^\s*\[?\d+[\].):\s]+/, "");
        // æ ‡å‡†åŒ–å„ç§ç©ºç™½å­—ç¬¦
        s = s
          .replace(/[\r\n\t]+/g, " ")
          .replace(/\s+/g, " ")
          .trim();
        // æ ‡å‡†åŒ–å„ç§å¼•å·
        s = s.replace(/[""â€â€ŸÂ«Â»]/g, '"').replace(/[''â€šâ€›]/g, "'");
        // æ ‡å‡†åŒ–å„ç§ç ´æŠ˜å·/è¿å­—ç¬¦
        s = s.replace(/[â€“â€”âˆ’â€â€‘â€’â€•]/g, "-");

        // 1. æå–å¹´ä»½ï¼ˆæ”¯æŒå¤šç§æ ¼å¼ï¼š(2019), 2019, [2019]ï¼‰
        let year = null;
        const yearPatterns = [
          /\((\d{4})\)/, // (2019)
          /\[(\d{4})\]/, // [2019]
          /,\s*(\d{4})\s*[,.:;]/, // , 2019,
          /,\s*(\d{4})\s*$/, // ç»“å°¾çš„å¹´ä»½
          /\b(19|20)\d{2}\b/, // ä»»æ„ä½ç½®çš„4ä½å¹´ä»½
        ];
        for (const pat of yearPatterns) {
          const m = s.match(pat);
          if (m) {
            const y = parseInt(m[1] || m[0], 10);
            if (y >= 1900 && y <= 2100) {
              year = y;
              break;
            }
          }
        }

        // 2. æå– DOIï¼ˆæ›´å®½æ¾çš„åŒ¹é…ï¼‰
        const doiMatch = s.match(/\b(10\.\d{4,9}\/[^\s,;"\]>]+)/i);
        const doi = doiMatch ? doiMatch[1].replace(/[.,;>\]]+$/, "") : null;

        // 3. æ£€æµ‹å¼•ç”¨æ ¼å¼ç±»å‹
        const hasChineseMarker =
          /\[(J|M|C|D|N|R|S|P|DB|CP|EB|OL|Z|A|G|K)\]/i.test(s);
        const hasQuotedTitle = /"[^"]{5,}"|ã€Œ[^ã€]{5,}ã€|ã€Š[^ã€‹]{5,}ã€‹/.test(s);
        const hasIEEEStyle =
          /\bvol\.\s*\d+/i.test(s) ||
          /\bno\.\s*\d+/i.test(s) ||
          /\bpp\.\s*\d+/i.test(s);
        const hasAPAStyle =
          /^[A-Z][^()]+,\s*[A-Z]\.\s*[A-Z]?\.?\s*(?:\(|\[)?\d{4}(?:\)|\])?\./.test(
            s
          );
        const hasVancouverStyle =
          /;\s*\d{4}\s*[;:]/i.test(s) || /\.\s*\d{4}\s*;\s*\d+/.test(s);

        let title = null;
        let journal = null;
        let authors = [];
        let volume = null,
          issue = null;
        let firstPage = null,
          lastPage = null;
        let publisher = null;

        // =========== æ ¼å¼æ£€æµ‹ä¸è§£æ ===========

        if (hasChineseMarker) {
          // ===== ä¸­æ–‡ GB/T 7714 æ ¼å¼è§£æ =====
          // æ ¼å¼ï¼šä½œè€…. æ ‡é¢˜[J]. æœŸåˆŠå, å¹´ä»½, å·(æœŸ): é¡µç .
          const result = parseChineseGBFormat(s);
          title = result.title;
          journal = result.journal;
          authors = result.authors;
          volume = result.volume;
          issue = result.issue;
          firstPage = result.firstPage;
          lastPage = result.lastPage;
          publisher = result.publisher;
        } else if (hasIEEEStyle) {
          // ===== IEEE æ ¼å¼è§£æ =====
          // æ ¼å¼ï¼šA. Author, "Title," Journal, vol. X, no. X, pp. X-X, Year.
          const result = parseIEEEFormat(s);
          title = result.title;
          journal = result.journal;
          authors = result.authors;
          volume = result.volume;
          issue = result.issue;
          firstPage = result.firstPage;
          lastPage = result.lastPage;
        } else if (hasQuotedTitle) {
          // ===== å¸¦å¼•å·æ ‡é¢˜çš„æ ¼å¼ï¼ˆMLA, Chicago ç­‰ï¼‰=====
          const result = parseQuotedTitleFormat(s);
          title = result.title;
          journal = result.journal;
          authors = result.authors;
          volume = result.volume;
          issue = result.issue;
          firstPage = result.firstPage;
          lastPage = result.lastPage;
        } else if (hasAPAStyle) {
          // ===== APA æ ¼å¼è§£æ =====
          // æ ¼å¼ï¼šAuthor, A. A. (Year). Title. Journal, Volume(Issue), Pages.
          const result = parseAPAFormat(s);
          title = result.title;
          journal = result.journal;
          authors = result.authors;
          volume = result.volume;
          issue = result.issue;
          firstPage = result.firstPage;
          lastPage = result.lastPage;
        } else if (hasVancouverStyle) {
          // ===== Vancouver æ ¼å¼è§£æ =====
          // æ ¼å¼ï¼šAuthor. Title. Journal. Year;Volume(Issue):Pages.
          const result = parseVancouverFormat(s);
          title = result.title;
          journal = result.journal;
          authors = result.authors;
          volume = result.volume;
          issue = result.issue;
          firstPage = result.firstPage;
          lastPage = result.lastPage;
        } else {
          // ===== é€šç”¨æ™ºèƒ½è§£æ =====
          const result = parseGenericFormat(s);
          title = result.title;
          journal = result.journal;
          authors = result.authors;
          volume = result.volume;
          issue = result.issue;
          firstPage = result.firstPage;
          lastPage = result.lastPage;
        }

        // =========== åå¤„ç†å’Œè¡¥å……æå– ===========

        // å¦‚æœè¿˜æ²¡æœ‰æå–åˆ°å·æœŸé¡µç ï¼Œä½¿ç”¨é€šç”¨æ­£åˆ™
        if (!volume || !firstPage) {
          const extracted = extractVolumeIssuePage(s);
          if (!volume && extracted.volume) volume = extracted.volume;
          if (!issue && extracted.issue) issue = extracted.issue;
          if (!firstPage && extracted.firstPage)
            firstPage = extracted.firstPage;
          if (!lastPage && extracted.lastPage) lastPage = extracted.lastPage;
        }

        // æ¸…ç†å’Œæ ‡å‡†åŒ–
        if (title) {
          title = cleanTitle(title);
        }
        if (journal) {
          journal = cleanJournal(journal);
        }
        if (authors.length > 0) {
          authors = cleanAuthors(authors);
        }

        // å¦‚æœæ ‡é¢˜ä¸ºç©ºæˆ–å¤ªçŸ­ï¼Œå°è¯•ä»åŸæ–‡æå–æœ€é•¿çš„æœ‰æ„ä¹‰ç‰‡æ®µ
        if (!title || title.length < 10) {
          title = extractTitleFallback(s, authors, journal) || title;
        }

        return {
          raw: s,
          year,
          doi,
          title,
          journal,
          volume,
          issue,
          firstPage,
          lastPage,
          authors,
          publisher,
        };
      }

      // ===== ä¸­æ–‡ GB/T 7714 æ ¼å¼è§£æ =====
      function parseChineseGBFormat(s) {
        let title = null,
          journal = null,
          authors = [],
          volume = null,
          issue = null;
        let firstPage = null,
          lastPage = null,
          publisher = null;

        // åŒ¹é…æ–‡çŒ®ç±»å‹æ ‡è®°
        const typeMatch = s.match(/\[([JMCDNRSPZA]|DB|CP|EB|OL)\]/i);
        const typeIdx = typeMatch ? s.indexOf(typeMatch[0]) : -1;

        if (typeIdx !== -1) {
          const beforeType = s.slice(0, typeIdx);
          const afterType = s.slice(typeIdx + typeMatch[0].length);

          // æ ‡é¢˜ï¼šç¬¬ä¸€ä¸ªå¥å·ååˆ°ç±»å‹æ ‡è®°å‰
          const firstDotIdx = beforeType.indexOf(". ");
          if (firstDotIdx !== -1) {
            title = beforeType.slice(firstDotIdx + 2).trim();
          } else {
            // å°è¯•ç”¨ä¸­æ–‡å¥å·
            const cnDotIdx = beforeType.indexOf("ã€‚");
            if (cnDotIdx !== -1) {
              title = beforeType.slice(cnDotIdx + 1).trim();
            } else {
              // æ²¡æœ‰æ˜ç¡®çš„å¥å·åˆ†éš”ï¼Œå°è¯•æŒ‰é€—å·åˆ†å‰²
              const parts = beforeType.split(/[,ï¼Œ]/);
              if (parts.length > 1) {
                authors = [parts[0].trim()];
                title = parts.slice(1).join(",").trim();
              }
            }
          }

          // ä½œè€…ï¼šç¬¬ä¸€ä¸ªå¥å·å‰
          const authorPart =
            firstDotIdx !== -1
              ? beforeType.slice(0, firstDotIdx)
              : beforeType.split(/[,ï¼Œ]/)[0];
          if (authorPart) {
            authors = parseChineseAuthors(authorPart);
          }

          // æœŸåˆŠ/å‡ºç‰ˆä¿¡æ¯
          // æœŸåˆŠæ ¼å¼ï¼š. æœŸåˆŠå, å¹´ä»½, å·(æœŸ): é¡µç 
          // ä¹¦ç±æ ¼å¼ï¼š. å‡ºç‰ˆåœ°: å‡ºç‰ˆç¤¾, å¹´ä»½: é¡µç 
          const journalMatch = afterType.match(/\.\s*([^,ï¼Œ.ã€‚]+?)(?:[,ï¼Œ]|$)/);
          if (journalMatch) {
            const jName = journalMatch[1].trim();
            // åˆ¤æ–­æ˜¯æœŸåˆŠè¿˜æ˜¯å‡ºç‰ˆç¤¾
            if (/å‡ºç‰ˆ|Press|Publisher/i.test(jName)) {
              publisher = jName;
            } else {
              journal = jName;
            }
          }
        } else {
          // æ²¡æœ‰ç±»å‹æ ‡è®°ï¼Œå°è¯•é€šç”¨ä¸­æ–‡æ ¼å¼è§£æ
          // æŒ‰å¥å·åˆ†å‰²
          const parts = s.split(/[.ã€‚]/);
          if (parts.length >= 2) {
            authors = parseChineseAuthors(parts[0]);
            title = parts[1]?.trim();
            if (parts.length >= 3) {
              journal = parts[2]?.split(/[,ï¼Œ]/)[0]?.trim();
            }
          }
        }

        // å·æœŸï¼šæ”¯æŒå¤šç§æ ¼å¼
        // æ ¼å¼1: å¹´ä»½, å·(æœŸ)
        const vi1 = s.match(/[,ï¼Œ]\s*\d{4}\s*[,ï¼Œ]\s*(\d+)\s*\(\s*(\d+)\s*\)/);
        // æ ¼å¼2: å¹´ä»½, å·
        const vi2 = s.match(/[,ï¼Œ]\s*\d{4}\s*[,ï¼Œ]\s*(\d+)\s*(?:[:ï¼š]|$)/);
        // æ ¼å¼3: å·(æœŸ)
        const vi3 = s.match(/[,ï¼Œ]\s*(\d+)\s*\(\s*(\d+)\s*\)\s*[:ï¼š]/);

        if (vi1) {
          volume = vi1[1];
          issue = vi1[2];
        } else if (vi3) {
          volume = vi3[1];
          issue = vi3[2];
        } else if (vi2) {
          volume = vi2[1];
        }

        // é¡µç 
        const pageMatch = s.match(/[:ï¼š]\s*(\d+)\s*[-â€“â€”]\s*(\d+)/);
        if (pageMatch) {
          firstPage = pageMatch[1];
          lastPage = pageMatch[2];
        } else {
          // å•é¡µ
          const singlePage = s.match(/[:ï¼š]\s*(\d+)\s*[.ã€‚]?\s*$/);
          if (singlePage) firstPage = singlePage[1];
        }

        return {
          title,
          journal,
          authors,
          volume,
          issue,
          firstPage,
          lastPage,
          publisher,
        };
      }

      // è§£æä¸­æ–‡ä½œè€…
      function parseChineseAuthors(authorStr) {
        if (!authorStr) return [];

        // ç§»é™¤ "ç­‰" "et al"
        authorStr = authorStr
          .replace(/[,ï¼Œ]?\s*ç­‰\s*$/i, "")
          .replace(/et\s+al\.?/gi, "");

        // æŒ‰é€—å·å’Œ"å’Œ"åˆ†å‰²
        const parts = authorStr.split(/[,ï¼Œ]|\s+å’Œ\s+|\s+and\s+/i);

        return parts.map((p) => p.trim()).filter((p) => p && p.length >= 2);
      }

      function parseIEEEFormat(s) {
        let title = null,
          journal = null,
          authors = [],
          volume = null,
          issue = null;
        let firstPage = null,
          lastPage = null;

        const titleMatch = s.match(/"([^"]+)"/);
        if (titleMatch) {
          title = titleMatch[1].replace(/[,ï¼Œ.]$/, "").trim();

          const beforeQuote = s.slice(0, s.indexOf('"')).trim();
          authors = parseWesternAuthors(beforeQuote.replace(/[,ï¼Œ]\s*$/, ""));

          // æœŸåˆŠå’Œå·æœŸåœ¨å¼•å·å
          let afterQuote = s
            .slice(s.indexOf('"', s.indexOf('"') + 1) + 1)
            .trim();
          afterQuote = afterQuote.replace(/^[,ï¼Œ]\s*/, "");

          // æœŸåˆŠåï¼ˆvol. æˆ– no. æˆ–å¹´ä»½å‰çš„éƒ¨åˆ†ï¼‰
          const journalMatch = afterQuote.match(
            /^([^,]+?)(?:\s*[,ï¼Œ]\s*(?:vol\.|no\.|\d{4}))/i
          );
          if (journalMatch) {
            journal = journalMatch[1].trim();
          }
        }

        // vol. X
        const volMatch = s.match(/vol\.\s*(\d+)/i);
        if (volMatch) volume = volMatch[1];

        // no. X
        const noMatch = s.match(/no\.\s*(\d+)/i);
        if (noMatch) issue = noMatch[1];

        // pp. X-X æˆ– pp. X
        const ppMatch = s.match(/pp?\.\s*(\d+)\s*[-â€“â€”]?\s*(\d+)?/i);
        if (ppMatch) {
          firstPage = ppMatch[1];
          lastPage = ppMatch[2] || null;
        }

        return { title, journal, authors, volume, issue, firstPage, lastPage };
      }

      // ===== å¸¦å¼•å·æ ‡é¢˜æ ¼å¼ï¼ˆMLA, Chicago ç­‰ï¼‰=====
      function parseQuotedTitleFormat(s) {
        let title = null,
          journal = null,
          authors = [],
          volume = null,
          issue = null;
        let firstPage = null,
          lastPage = null;

        // æŸ¥æ‰¾å¼•å·ä¸­çš„æ ‡é¢˜
        // æ”¯æŒå¤šç§å¼•å·ï¼š""  ã€Œã€ ã€Šã€‹
        let titleMatch = s.match(/"([^"]{5,})"/);
        if (!titleMatch) titleMatch = s.match(/ã€Œ([^ã€]{5,})ã€/);
        if (!titleMatch) titleMatch = s.match(/ã€Š([^ã€‹]{5,})ã€‹/);

        if (titleMatch) {
          title = titleMatch[1].replace(/[,ï¼Œ.ã€‚]$/, "").trim();
          const quoteStart = s.indexOf(titleMatch[0]);
          const quoteEnd = quoteStart + titleMatch[0].length;

          // ä½œè€…ï¼ˆå¼•å·å‰ï¼‰
          let beforeQuote = s.slice(0, quoteStart).trim();
          beforeQuote = beforeQuote.replace(/[,ï¼Œ.ã€‚]\s*$/, "");
          if (beforeQuote) {
            authors = parseWesternAuthors(beforeQuote);
          }

          // å¼•å·åçš„å†…å®¹
          let afterQuote = s.slice(quoteEnd).trim();
          afterQuote = afterQuote.replace(/^[,ï¼Œ.ã€‚]\s*/, "");

          // å°è¯•å¤šç§æœŸåˆŠåŒ¹é…æ¨¡å¼
          // æ¨¡å¼1: Journal Vol, Pages (Year)
          const p1 = afterQuote.match(
            /^([A-Za-z][A-Za-z.\s&]+?)\s+(\d+)\s*[,ï¼Œ]\s*(\d+)\s*[-â€“â€”]\s*(\d+)\s*\(\d{4}\)/
          );
          // æ¨¡å¼2: Journal, Vol(Issue), Pages
          const p2 = afterQuote.match(
            /^([A-Za-z][A-Za-z.\s&,]+?)\s*[,ï¼Œ]\s*(\d+)\s*\(\s*(\d+)\s*\)\s*[,ï¼Œ:ï¼š]\s*(\d+)\s*[-â€“â€”]\s*(\d+)/
          );
          // æ¨¡å¼3: Journal Vol.Issue (Year): Pages
          const p3 = afterQuote.match(
            /^([A-Za-z][A-Za-z.\s&]+?)\s+(\d+)\.(\d+)\s*\(\d{4}\)\s*[:ï¼š]\s*(\d+)\s*[-â€“â€”]\s*(\d+)/
          );
          // æ¨¡å¼4: Journal (Year) Vol: Pages
          const p4 = afterQuote.match(
            /^([A-Za-z][A-Za-z.\s&]+?)\s*\(\d{4}\)\s*(\d+)\s*[:ï¼š]\s*(\d+)\s*[-â€“â€”]?\s*(\d+)?/
          );

          if (p1) {
            journal = p1[1].trim();
            volume = p1[2];
            firstPage = p1[3];
            lastPage = p1[4];
          } else if (p2) {
            journal = p2[1].trim();
            volume = p2[2];
            issue = p2[3];
            firstPage = p2[4];
            lastPage = p2[5];
          } else if (p3) {
            journal = p3[1].trim();
            volume = p3[2];
            issue = p3[3];
            firstPage = p3[4];
            lastPage = p3[5];
          } else if (p4) {
            journal = p4[1].trim();
            volume = p4[2];
            firstPage = p4[3];
            lastPage = p4[4];
          } else {
            // å°è¯•æå–æœŸåˆŠåï¼ˆåˆ°æ•°å­—æˆ–é€—å·ä¸ºæ­¢ï¼‰
            const jMatch = afterQuote.match(
              /^([A-Za-z][A-Za-z.\s&]+?)(?:\s+\d|[,ï¼Œ]|\()/
            );
            if (jMatch) {
              journal = jMatch[1].trim();
            }
          }
        }

        return { title, journal, authors, volume, issue, firstPage, lastPage };
      }

      // ===== APA æ ¼å¼è§£æ =====
      function parseAPAFormat(s) {
        let title = null,
          journal = null,
          authors = [],
          volume = null,
          issue = null;
        let firstPage = null,
          lastPage = null;

        // APA: Author, A. A., & Author, B. B. (Year). Title. Journal, Volume(Issue), Pages. doi

        // æŸ¥æ‰¾å¹´ä»½ä½ç½®
        const yearMatch = s.match(/\((\d{4})\)\./);
        if (yearMatch) {
          const yearIdx = s.indexOf(yearMatch[0]);

          // ä½œè€…ï¼ˆå¹´ä»½å‰ï¼‰
          const authorPart = s.slice(0, yearIdx).trim();
          authors = parseWesternAuthors(authorPart);

          // å¹´ä»½åçš„å†…å®¹
          const afterYear = s.slice(yearIdx + yearMatch[0].length).trim();

          // æŒ‰å¥å·åˆ†å‰²
          const parts = afterYear.split(/\.\s+/);

          if (parts.length >= 1) {
            // ç¬¬ä¸€éƒ¨åˆ†æ˜¯æ ‡é¢˜
            title = parts[0].trim();
          }

          if (parts.length >= 2) {
            // ç¬¬äºŒéƒ¨åˆ†æ˜¯æœŸåˆŠä¿¡æ¯
            const journalPart = parts[1];
            // Journal, Volume(Issue), Pages
            const jMatch = journalPart.match(
              /^([^,]+),\s*(\d+)(?:\((\d+)\))?,?\s*(\d+)?\s*[-â€“â€”]?\s*(\d+)?/
            );
            if (jMatch) {
              journal = jMatch[1].trim();
              volume = jMatch[2];
              issue = jMatch[3] || null;
              firstPage = jMatch[4] || null;
              lastPage = jMatch[5] || null;
            } else {
              // åªæœ‰æœŸåˆŠå
              journal = journalPart.split(",")[0].trim();
            }
          }
        } else {
          // æ²¡æœ‰æ ‡å‡†çš„å¹´ä»½æ ¼å¼ï¼Œå°è¯•é€šç”¨è§£æ
          return parseGenericFormat(s);
        }

        return { title, journal, authors, volume, issue, firstPage, lastPage };
      }

      // ===== Vancouver æ ¼å¼è§£æ =====
      function parseVancouverFormat(s) {
        let title = null,
          journal = null,
          authors = [],
          volume = null,
          issue = null;
        let firstPage = null,
          lastPage = null;

        // Vancouver: Author. Title. Journal. Year;Volume(Issue):Pages.

        // æŒ‰å¥å·åˆ†å‰²
        const parts = s.split(/\.\s+/);

        if (parts.length >= 2) {
          // ç¬¬ä¸€éƒ¨åˆ†ï¼šä½œè€…
          authors = parseWesternAuthors(parts[0]);

          // ç¬¬äºŒéƒ¨åˆ†ï¼šæ ‡é¢˜
          if (parts.length >= 2) {
            title = parts[1].trim();
          }

          // ç¬¬ä¸‰éƒ¨åˆ†ï¼šæœŸåˆŠå’Œå…ƒæ•°æ®
          if (parts.length >= 3) {
            const journalPart = parts[2];
            // Journal. Year;Vol(Issue):Pages
            const jMatch = journalPart.match(
              /^([^.;]+?)(?:\.\s*|\s+)?\d{4}\s*;\s*(\d+)(?:\((\d+)\))?:?\s*(\d+)?\s*[-â€“â€”]?\s*(\d+)?/
            );
            if (jMatch) {
              journal = jMatch[1].trim();
              volume = jMatch[2];
              issue = jMatch[3] || null;
              firstPage = jMatch[4] || null;
              lastPage = jMatch[5] || null;
            } else {
              // æœŸåˆŠåï¼ˆåˆ°å¹´ä»½æˆ–åˆ†å·å‰ï¼‰
              journal = journalPart.split(/\s*[.;]\s*|\s+\d{4}/)[0].trim();
            }
          }
        }

        // è¡¥å……æå–å·æœŸé¡µç 
        const viMatch = s.match(/(\d{4})\s*;\s*(\d+)\s*(?:\(\s*(\d+)\s*\))?/);
        if (viMatch && !volume) {
          volume = viMatch[2];
          issue = viMatch[3] || null;
        }

        const ppMatch = s.match(/[:]\s*(\d+)\s*[-â€“â€”]\s*(\d+)/);
        if (ppMatch && !firstPage) {
          firstPage = ppMatch[1];
          lastPage = ppMatch[2];
        }

        return { title, journal, authors, volume, issue, firstPage, lastPage };
      }

      // ===== é€šç”¨æ™ºèƒ½è§£æ =====
      function parseGenericFormat(s) {
        let title = null,
          journal = null,
          authors = [],
          volume = null,
          issue = null;
        let firstPage = null,
          lastPage = null;

        // ç­–ç•¥ï¼šæŒ‰å¥å·åˆ†å‰²ï¼Œå¯å‘å¼åˆ¤æ–­å„éƒ¨åˆ†
        const parts = s.split(/\.\s+/);

        if (parts.length === 1) {
          // æ²¡æœ‰å¥å·åˆ†å‰²ï¼Œå°è¯•æŒ‰é€—å·åˆ†æ
          return parseCommaSeparatedFormat(s);
        }

        // åˆ†ææ¯ä¸ªéƒ¨åˆ†
        const analyzed = parts.map(analyzePart);

        // æ‰¾ä½œè€…ï¼ˆé€šå¸¸æ˜¯ç¬¬ä¸€éƒ¨åˆ†ï¼Œä¸”åŒ…å«äººåç‰¹å¾ï¼‰
        if (analyzed[0]?.type === "author" || looksLikeAuthors(parts[0])) {
          authors = parseWesternAuthors(parts[0]);
        }

        // æ‰¾æ ‡é¢˜ï¼ˆé€šå¸¸æ˜¯æœ€é•¿çš„éƒ¨åˆ†ï¼Œæˆ–ç¬¬äºŒéƒ¨åˆ†ï¼‰
        let maxLen = 0,
          titleIdx = -1;
        for (let i = 0; i < parts.length; i++) {
          // è·³è¿‡ä½œè€…éƒ¨åˆ†å’Œæ˜æ˜¾çš„æœŸåˆŠä¿¡æ¯éƒ¨åˆ†
          if (i === 0 && authors.length > 0) continue;
          if (/^\d+\s*\(?\d*\)?\s*[:;,]/.test(parts[i])) continue; // å·æœŸä¿¡æ¯
          if (parts[i].length > maxLen && !looksLikeJournal(parts[i])) {
            maxLen = parts[i].length;
            titleIdx = i;
          }
        }
        if (titleIdx >= 0) {
          title = parts[titleIdx].trim();
        }

        // æ‰¾æœŸåˆŠï¼ˆé€šå¸¸åœ¨æ ‡é¢˜åï¼ŒåŒ…å«æœŸåˆŠç‰¹å¾ï¼‰
        for (let i = titleIdx + 1; i < parts.length; i++) {
          if (looksLikeJournal(parts[i]) && !journal) {
            const jMatch = parts[i].match(/^([^,\d]+)/);
            if (jMatch) {
              journal = jMatch[1].trim();
            }
            break;
          }
        }

        // å¦‚æœè¿˜æ²¡æ‰¾åˆ°æ ‡é¢˜ï¼Œç”¨ç¬¬äºŒéƒ¨åˆ†
        if (!title && parts.length >= 2) {
          title = parts[1].trim();
        }

        // å¦‚æœæ²¡æ‰¾åˆ°æœŸåˆŠï¼Œç”¨ç¬¬ä¸‰éƒ¨åˆ†
        if (!journal && parts.length >= 3) {
          const jMatch = parts[2].match(/^([^,\d]+)/);
          if (jMatch) {
            journal = jMatch[1].trim();
          }
        }

        return { title, journal, authors, volume, issue, firstPage, lastPage };
      }

      // æŒ‰é€—å·åˆ†å‰²çš„æ ¼å¼
      function parseCommaSeparatedFormat(s) {
        let title = null,
          journal = null,
          authors = [],
          volume = null,
          issue = null;
        let firstPage = null,
          lastPage = null;

        const parts = s.split(/,\s*/);

        // ç¬¬ä¸€éƒ¨åˆ†é€šå¸¸æ˜¯ä½œè€…æˆ–æ ‡é¢˜
        if (parts.length >= 1) {
          if (looksLikeAuthors(parts[0])) {
            authors = parseWesternAuthors(parts[0]);
            if (parts.length >= 2) title = parts[1];
          } else {
            title = parts[0];
          }
        }

        return { title, journal, authors, volume, issue, firstPage, lastPage };
      }

      // åˆ¤æ–­æ˜¯å¦åƒä½œè€…
      function looksLikeAuthors(s) {
        if (!s) return false;
        // åŒ…å« "and" æˆ–å¤šä¸ªé€—å·åˆ†éš”çš„åå­—
        if (/\s+and\s+/i.test(s)) return true;
        // åŒ…å«ç¼©å†™å A. B.
        if (/[A-Z]\.\s*[A-Z]?\.?/.test(s)) return true;
        // å§“, å æ ¼å¼
        if (/^[A-Z][a-z]+,\s*[A-Z]/.test(s)) return true;
        // ä¸­æ–‡ä½œè€…
        if (/^[\u4e00-\u9fa5]{2,4}(?:[,ï¼Œ][\u4e00-\u9fa5]{2,4})*/.test(s))
          return true;
        return false;
      }

      // åˆ¤æ–­æ˜¯å¦åƒæœŸåˆŠ
      function looksLikeJournal(s) {
        if (!s) return false;
        // åŒ…å«å…¸å‹æœŸåˆŠè¯æ±‡
        if (
          /\b(Journal|Review|Letters|Proceedings|Trans|Conf|Ann|Sci|Research)\b/i.test(
            s
          )
        )
          return true;
        // åŒ…å«ç¼©å†™ (å¸¦ç‚¹çš„å•è¯)
        if (/[A-Z][a-z]*\.\s*[A-Z]/.test(s)) return true;
        // åŒ…å«å·æœŸä¿¡æ¯
        if (/\d+\s*\(\d+\)/.test(s)) return true;
        return false;
      }

      // åˆ†æå¥å­ç±»å‹
      function analyzePart(s) {
        if (looksLikeAuthors(s)) return { type: "author", content: s };
        if (looksLikeJournal(s)) return { type: "journal", content: s };
        return { type: "unknown", content: s };
      }

      // è§£æè¥¿æ–¹ä½œè€…å
      function parseWesternAuthors(s) {
        if (!s) return [];

        // æ¸…ç†
        s = s
          .replace(/et\s+al\.?/gi, "")
          .replace(/\s*&\s*/g, " and ")
          .replace(/[,ï¼Œ]\s*$/, "")
          .trim();

        // æŒ‰ and/é€—å· åˆ†å‰²
        // æ³¨æ„ï¼šé€—å·å¯èƒ½åœ¨åå­—å†…éƒ¨ï¼ˆLastname, Firstnameï¼‰ï¼Œéœ€è¦ç‰¹æ®Šå¤„ç†

        let authors = [];

        // æ£€æµ‹æ˜¯å¦æ˜¯ "Lastname, Firstname" æ ¼å¼
        if (/^[A-Z][a-z]+,\s*[A-Z]/.test(s)) {
          // å…ˆæŒ‰ and åˆ†å‰²
          const andParts = s.split(/\s+and\s+/i);
          for (const part of andParts) {
            // æ¯ä¸ªéƒ¨åˆ†å¯èƒ½æœ‰å¤šä¸ªä½œè€…ç”¨åˆ†å·åˆ†éš”
            const semicolonParts = part.split(/;\s*/);
            for (const sp of semicolonParts) {
              if (sp.trim()) authors.push(sp.trim());
            }
          }
        } else {
          // æ™®é€šæ ¼å¼ï¼šæŒ‰ and å’Œé€—å·åˆ†å‰²
          authors = s
            .split(/,\s*(?:and\s+)?|\s+and\s+/i)
            .map((a) => a.trim())
            .filter(Boolean);
        }

        return authors.filter((a) => a.length >= 2);
      }

      // æå–å·æœŸé¡µç ï¼ˆé€šç”¨ï¼‰
      function extractVolumeIssuePage(s) {
        let volume = null,
          issue = null,
          firstPage = null,
          lastPage = null;

        // æ¨¡å¼1: Vol(Issue)
        const vi1 = s.match(/(\d+)\s*\(\s*(\d+)\s*\)/);
        if (vi1) {
          volume = vi1[1];
          issue = vi1[2];
        }

        // æ¨¡å¼2: vol. X, no. Y
        const vi2 = s.match(/vol\.\s*(\d+)/i);
        if (vi2 && !volume) volume = vi2[1];
        const vi3 = s.match(/no\.\s*(\d+)/i);
        if (vi3) issue = vi3[1];

        // æ¨¡å¼3: Vol.Issue
        const vi4 = s.match(/\b(\d+)\.(\d+)\b/);
        if (vi4 && !volume) {
          volume = vi4[1];
          issue = vi4[2];
        }

        // é¡µç æ¨¡å¼
        // pp. X-Y æˆ– p. X
        const pp1 = s.match(/pp?\.\s*(\d+)\s*[-â€“â€”]\s*(\d+)/i);
        if (pp1) {
          firstPage = pp1[1];
          lastPage = pp1[2];
        }

        // : X-Y
        const pp2 = s.match(/[:ï¼š]\s*(\d+)\s*[-â€“â€”]\s*(\d+)/);
        if (pp2 && !firstPage) {
          firstPage = pp2[1];
          lastPage = pp2[2];
        }

        // é€šç”¨ X-Y (æ’é™¤å¹´ä»½èŒƒå›´)
        const pp3 = s.match(/\b(\d{1,5})\s*[-â€“â€”]\s*(\d{1,5})\b/);
        if (pp3 && !firstPage) {
          const n1 = parseInt(pp3[1], 10);
          const n2 = parseInt(pp3[2], 10);
          // æ’é™¤å¹´ä»½èŒƒå›´ (1900-2100)
          if (!(n1 >= 1900 && n1 <= 2100 && n2 >= 1900 && n2 <= 2100)) {
            firstPage = pp3[1];
            lastPage = pp3[2];
          }
        }

        return { volume, issue, firstPage, lastPage };
      }

      // æ¸…ç†æ ‡é¢˜
      function cleanTitle(title) {
        if (!title) return null;
        return title
          .replace(/\s+/g, " ")
          .replace(/^["'"ã€Œã€Š]+/, "")
          .replace(/["'"ã€ã€‹]+$/, "")
          .replace(/[,ï¼Œ.ã€‚]+$/, "")
          .trim();
      }

      // æ¸…ç†æœŸåˆŠå
      function cleanJournal(journal) {
        if (!journal) return null;
        return journal
          .replace(/\s+/g, " ")
          .replace(/[,ï¼Œ.ã€‚:ï¼š]+$/, "")
          .replace(/^\s*in\s+/i, "")
          .trim();
      }

      // æ¸…ç†ä½œè€…åˆ—è¡¨
      function cleanAuthors(authors) {
        return authors
          .map((a) => a.replace(/[,ï¼Œ.ã€‚]+$/, "").trim())
          .filter((a) => a && a.length >= 2 && !/^\d+$/.test(a));
      }

      // æ ‡é¢˜å›é€€æå–
      function extractTitleFallback(s, authors, journal) {
        // ç§»é™¤ä½œè€…å’ŒæœŸåˆŠéƒ¨åˆ†ï¼Œå‰©ä¸‹çš„å¯èƒ½æ˜¯æ ‡é¢˜
        let remaining = s;

        for (const author of authors) {
          remaining = remaining.replace(author, "");
        }
        if (journal) {
          remaining = remaining.replace(journal, "");
        }

        // ç§»é™¤å¹´ä»½ã€å·æœŸã€é¡µç 
        remaining = remaining
          .replace(/\(?\d{4}\)?/g, "")
          .replace(/\d+\s*\(\d+\)/g, "")
          .replace(/\d+\s*[-â€“â€”]\s*\d+/g, "")
          .replace(/vol\.\s*\d+/gi, "")
          .replace(/no\.\s*\d+/gi, "")
          .replace(/pp?\.\s*\d+/gi, "");

        // æ¸…ç†æ ‡ç‚¹å’Œå¤šä½™ç©ºæ ¼
        remaining = remaining
          .replace(/[,ï¼Œ.ã€‚;ï¼›:ï¼š\[\]()ï¼ˆï¼‰]+/g, " ")
          .replace(/\s+/g, " ")
          .trim();

        // å¦‚æœå‰©ä½™å†…å®¹è¶³å¤Ÿé•¿ï¼Œå¯èƒ½æ˜¯æ ‡é¢˜
        if (remaining.length >= 15) {
          return remaining;
        }

        return null;
      }

      /** ---------- API æŸ¥è¯¢ ---------- */
      async function queryOpenAlex(p, mailto) {
        let url = new URL("https://api.openalex.org/works");
        url.searchParams.set("per-page", "25");
        if (mailto) url.searchParams.set("mailto", mailto);

        if (p.doi) {
          url.searchParams.set("filter", `doi:${p.doi.toLowerCase()}`);
        } else {
          url.searchParams.set("search", p.title || p.raw);
          if (p.year)
            url.searchParams.set("filter", `publication_year:${p.year}`);
        }

        const r = await fetch(url.toString());
        if (!r.ok) throw new Error("OpenAlex è¯·æ±‚å¤±è´¥: " + r.status);
        return await r.json();
      }

      async function queryCrossref(p, mailto) {
        // âœ… DOIï¼šç²¾ç¡®å–å›
        if (p.doi) {
          const doiEnc = encodeURIComponent(p.doi.toLowerCase());
          const url = new URL(`https://api.crossref.org/works/${doiEnc}`);
          if (mailto) url.searchParams.set("mailto", mailto);

          const r = await fetch(url.toString(), {
            headers: { Accept: "application/json" },
          });
          if (!r.ok) throw new Error("Crossref DOI ç²¾ç¡®æŸ¥è¯¢å¤±è´¥: " + r.status);

          const one = await r.json();
          // ç»Ÿä¸€æˆä½ ç°æœ‰çš„è¿”å›ç»“æ„ï¼šcr.message.items
          return { message: { items: [one.message] } };
        }

        // åŸæ¥çš„ï¼šæ¨¡ç³Šæ£€ç´¢
        let url = new URL("https://api.crossref.org/works");
        url.searchParams.set("rows", "50");
        if (mailto) url.searchParams.set("mailto", mailto);

        if (p.title) url.searchParams.set("query.bibliographic", p.title);
        if (p.journal) url.searchParams.set("query.container-title", p.journal);
        if (p.authors && p.authors[0])
          url.searchParams.set("query.author", p.authors[0]);
        if (p.year)
          url.searchParams.set(
            "filter",
            `from-pub-date:${p.year}-01-01,until-pub-date:${p.year}-12-31`
          );

        const r = await fetch(url.toString(), {
          headers: { Accept: "application/json" },
        });
        if (!r.ok) throw new Error("Crossref è¯·æ±‚å¤±è´¥: " + r.status);
        return await r.json();
      }

      /** ---------- æ‰“åˆ† ---------- */
      function scoreOpenAlexWork(p, w) {
        const t = jaccard(p.title, w.title || "");
        const y = p.year && w.publication_year === p.year ? 1 : 0;
        const j = journalSimilarity(
          p.journal,
          w.primary_location?.source?.display_name || ""
        );
        const v =
          p.volume &&
          w.biblio?.volume &&
          String(w.biblio.volume) === String(p.volume)
            ? 1
            : 0;
        const i =
          p.issue &&
          w.biblio?.issue &&
          String(w.biblio.issue) === String(p.issue)
            ? 1
            : 0;
        const fp =
          p.firstPage &&
          w.biblio?.first_page &&
          String(w.biblio.first_page) === String(p.firstPage)
            ? 1
            : 0;
        const lp =
          p.lastPage &&
          w.biblio?.last_page &&
          String(w.biblio.last_page) === String(p.lastPage)
            ? 1
            : 0;

        const workAuthors = (w.authorships || [])
          .map((a) => a.author?.display_name || "")
          .join(" ");
        const a = authorSimilarity(p.authors, workAuthors);

        const total =
          0.45 * t +
          0.15 * a +
          0.12 * j +
          0.1 * y +
          0.06 * v +
          0.04 * i +
          0.04 * fp +
          0.04 * lp;

        // è¿”å›è¯¦ç»†è¯„åˆ†ä¿¡æ¯
        return {
          total,
          details: {
            title: { score: t, weight: 0.45, weighted: 0.45 * t },
            author: { score: a, weight: 0.15, weighted: 0.15 * a },
            journal: { score: j, weight: 0.12, weighted: 0.12 * j },
            year: { score: y, weight: 0.1, weighted: 0.1 * y },
            volume: { score: v, weight: 0.06, weighted: 0.06 * v },
            issue: { score: i, weight: 0.04, weighted: 0.04 * i },
            firstPage: { score: fp, weight: 0.04, weighted: 0.04 * fp },
            lastPage: { score: lp, weight: 0.04, weighted: 0.04 * lp },
          },
        };
      }

      function scoreCrossrefItem(p, it) {
        const title = it.title && it.title[0] ? it.title[0] : "";
        const container =
          it["container-title"] && it["container-title"][0]
            ? it["container-title"][0]
            : "";
        const issuedYear = it.issued?.["date-parts"]?.[0]?.[0];

        const t = jaccard(p.title, title);
        const j = journalSimilarity(p.journal, container);
        const y = p.year && issuedYear === p.year ? 1 : 0;

        const crAuthors = (it.author || [])
          .map((a) => {
            const family = a.family || "";
            const given = a.given || "";
            return family ? (given ? `${given} ${family}` : family) : "";
          })
          .filter(Boolean)
          .join(" ");
        const a = authorSimilarity(p.authors, crAuthors);

        const v =
          p.volume && it.volume && String(it.volume) === String(p.volume)
            ? 1
            : 0;
        const i =
          p.issue && it.issue && String(it.issue) === String(p.issue) ? 1 : 0;
        const page = it.page || "";
        const fp = p.firstPage && page.includes(p.firstPage) ? 1 : 0;
        const lp = p.lastPage && page.includes(p.lastPage) ? 1 : 0;

        const total =
          0.45 * t +
          0.15 * a +
          0.12 * j +
          0.1 * y +
          0.06 * v +
          0.04 * i +
          0.04 * fp +
          0.04 * lp;

        // è¿”å›è¯¦ç»†è¯„åˆ†ä¿¡æ¯
        return {
          total,
          details: {
            title: { score: t, weight: 0.45, weighted: 0.45 * t },
            author: { score: a, weight: 0.15, weighted: 0.15 * a },
            journal: { score: j, weight: 0.12, weighted: 0.12 * j },
            year: { score: y, weight: 0.1, weighted: 0.1 * y },
            volume: { score: v, weight: 0.06, weighted: 0.06 * v },
            issue: { score: i, weight: 0.04, weighted: 0.04 * i },
            firstPage: { score: fp, weight: 0.04, weighted: 0.04 * fp },
            lastPage: { score: lp, weight: 0.04, weighted: 0.04 * lp },
          },
        };
      }

      function getVerdict(score) {
        if (score >= 0.78)
          return { level: "high", text: "é«˜å¯ä¿¡", desc: "å¼ºåŒ¹é…" };
        if (score >= 0.55)
          return { level: "medium", text: "ä¸­å¯ä¿¡", desc: "éœ€æ ¸å¯¹" };
        return { level: "low", text: "ä½å¯ä¿¡", desc: "å¯èƒ½ä¼ªé€ " };
      }

      /** ---------- å•æ¡æ ¡éªŒ ---------- */
      async function verifySingle(raw, mailto) {
        const p = parseCitation(raw);

        const [oa, cr] = await Promise.all([
          queryOpenAlex(p, mailto).catch((e) => ({ __error: e.message })),
          queryCrossref(p, mailto).catch((e) => ({ __error: e.message })),
        ]);

        const oaItems = oa?.results || [];
        const crItems = cr?.message?.items || [];

        const oaBest = pickBest(oaItems, (w) => scoreOpenAlexWork(p, w));
        const crBest = pickBest(crItems, (it) => scoreCrossrefItem(p, it));

        const oaScore = oaBest?.best ? oaBest.bestScore : 0;
        const crScore = crBest?.best ? crBest.bestScore : 0;
        const combined =
          Math.max(oaScore, crScore) * 0.6 + Math.min(oaScore, crScore) * 0.4;

        // ç”Ÿæˆç»¼åˆè¯„åˆ†è¯¦æƒ…
        const combinedDetails = {
          openAlex: {
            score: oaScore,
            weight: oaScore >= crScore ? 0.6 : 0.4,
            weighted: oaScore >= crScore ? oaScore * 0.6 : oaScore * 0.4,
          },
          crossref: {
            score: crScore,
            weight: crScore > oaScore ? 0.6 : 0.4,
            weighted: crScore > oaScore ? crScore * 0.6 : crScore * 0.4,
          },
        };

        return {
          raw,
          parsed: p,
          oaBest,
          crBest,
          oaScore,
          crScore,
          combined,
          combinedDetails,
          verdict: getVerdict(combined),
        };
      }

      /** ---------- UI æ¸²æŸ“ ---------- */
      // ç”Ÿæˆè¯„åˆ†è¯¦æƒ… tooltip HTML
      function renderScoreTooltip(details) {
        if (!details) return "";

        const labels = {
          title: "æ ‡é¢˜",
          author: "ä½œè€…",
          journal: "æœŸåˆŠ",
          year: "å¹´ä»½",
          volume: "å·å·",
          issue: "æœŸå·",
          firstPage: "é¦–é¡µ",
          lastPage: "æœ«é¡µ",
        };

        const getScoreClass = (score) => {
          if (score >= 0.8) return "good";
          if (score >= 0.5) return "medium";
          return "bad";
        };

        let rows = "";
        let total = 0;
        for (const [key, val] of Object.entries(details)) {
          total += val.weighted;
          rows += `
      <div class="score-tooltip-row">
        <span class="score-tooltip-label">${labels[key]} (${(
            val.weight * 100
          ).toFixed(0)}%)</span>
        <span class="score-tooltip-value ${getScoreClass(
          val.score
        )}">${val.score.toFixed(3)} â†’ ${val.weighted.toFixed(3)}</span>
      </div>
    `;
        }
        rows += `
    <div class="score-tooltip-row">
      <span class="score-tooltip-label">æ€»åˆ†</span>
      <span class="score-tooltip-value ${getScoreClass(total)}">${total.toFixed(
          3
        )}</span>
    </div>
  `;

        return `<div class="score-tooltip">${rows}</div>`;
      }

      // ç”Ÿæˆç»¼åˆè¯„åˆ† tooltip HTML
      function renderCombinedTooltip(combinedDetails, oaDetails, crDetails) {
        if (!combinedDetails) return "";

        const getScoreClass = (score) => {
          if (score >= 0.78) return "good";
          if (score >= 0.55) return "medium";
          return "bad";
        };

        const oaScore = combinedDetails.openAlex.score;
        const crScore = combinedDetails.crossref.score;
        const combined =
          combinedDetails.openAlex.weighted + combinedDetails.crossref.weighted;

        // åˆ¤æ–­å“ªä¸ªæ˜¯ä¸»è¦æ¥æº
        const oaIsMain = oaScore >= crScore;

        let rows = `
    <div class="score-tooltip-row" style="padding-bottom: 8px; margin-bottom: 4px; border-bottom: 1px solid rgba(255,255,255,0.15);">
      <span class="score-tooltip-label" style="font-weight: 600; color: rgba(255,255,255,0.9);">
        <span style="display: inline-block; width: 8px; height: 8px; border-radius: 50%; background: linear-gradient(135deg, #10b981, #34d399); margin-right: 6px; box-shadow: 0 0 6px rgba(16, 185, 129, 0.4);"></span>
        ç»¼åˆè¯„åˆ†å…¬å¼
      </span>
      <span class="score-tooltip-value" style="background: transparent; font-size: 10px;">maxÃ—0.6 + minÃ—0.4</span>
    </div>
    <div class="score-tooltip-row">
      <span class="score-tooltip-label">
        <span style="display: inline-block; width: 6px; height: 6px; border-radius: 50%; background: linear-gradient(135deg, #4f46e5, #818cf8); margin-right: 6px;"></span>
        OpenAlex ${oaIsMain ? "(ä¸»)" : "(æ¬¡)"}
      </span>
      <span class="score-tooltip-value ${getScoreClass(
        oaScore
      )}">${oaScore.toFixed(3)} Ã— ${
          oaIsMain ? "0.6" : "0.4"
        } = ${combinedDetails.openAlex.weighted.toFixed(3)}</span>
    </div>
    <div class="score-tooltip-row">
      <span class="score-tooltip-label">
        <span style="display: inline-block; width: 6px; height: 6px; border-radius: 50%; background: linear-gradient(135deg, #f59e0b, #fbbf24); margin-right: 6px;"></span>
        Crossref ${!oaIsMain ? "(ä¸»)" : "(æ¬¡)"}
      </span>
      <span class="score-tooltip-value ${getScoreClass(
        crScore
      )}">${crScore.toFixed(3)} Ã— ${
          !oaIsMain ? "0.6" : "0.4"
        } = ${combinedDetails.crossref.weighted.toFixed(3)}</span>
    </div>
    <div class="score-tooltip-row">
      <span class="score-tooltip-label">ç»¼åˆå¾—åˆ†</span>
      <span class="score-tooltip-value ${getScoreClass(
        combined
      )}">${combined.toFixed(3)}</span>
    </div>
  `;

        return `<div class="score-tooltip" style="min-width: 280px;">${rows}</div>`;
      }

      function renderResult(result, index) {
        const {
          raw,
          parsed,
          oaBest,
          crBest,
          oaScore,
          crScore,
          combined,
          combinedDetails,
          verdict,
        } = result;
        const oa = oaBest?.best;
        const cr = crBest?.best;
        const oaDetails = oaBest?.bestDetails;
        const crDetails = crBest?.bestDetails;

        return `
    <div class="result-item" data-index="${index}">
      <div class="result-header" onclick="toggleResult(${index})">
        <div class="result-index">${index + 1}</div>
        <div class="result-title">${esc(parsed.title || raw.slice(0, 80))}</div>
        <div class="score-tooltip-wrapper result-score-wrapper" onclick="event.stopPropagation()">
          <div class="result-score ${verdict.level}">${
          verdict.text
        } ${combined.toFixed(2)}</div>
          ${renderCombinedTooltip(combinedDetails, oaDetails, crDetails)}
        </div>
        <div class="result-toggle">
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <polyline points="6 9 12 15 18 9"></polyline>
          </svg>
        </div>
      </div>
      <div class="result-details">
        <div class="detail-section">
          <h4>è§£æå­—æ®µ</h4>
          <div class="detail-grid">
            <div class="detail-label">åŸå§‹å¼•ç”¨</div>
            <div class="detail-value" style="font-size:12px;color:var(--text-muted)">${esc(
              raw
            )}</div>
            <div class="detail-label">æ ‡é¢˜</div>
            <div class="detail-value">${esc(parsed.title || "-")}</div>
            <div class="detail-label">ä½œè€…</div>
            <div class="detail-value">${esc(
              (parsed.authors || []).join(", ") || "-"
            )}</div>
            <div class="detail-label">æœŸåˆŠ/å‡ºç‰ˆç¤¾</div>
            <div class="detail-value">${esc(parsed.journal || "-")}</div>
            <div class="detail-label">å¹´ä»½</div>
            <div class="detail-value">${esc(parsed.year || "-")}</div>
            <div class="detail-label">å·(æœŸ):é¡µç </div>
            <div class="detail-value">${esc(parsed.volume || "-")}(${esc(
          parsed.issue || "-"
        )}):${esc(parsed.firstPage || "-")}-${esc(parsed.lastPage || "-")}</div>
            <div class="detail-label">DOI</div>
            <div class="detail-value">${esc(parsed.doi || "æœªæä¾›")}</div>
          </div>
        </div>

        <div class="sources-grid">
          <div class="source-card">
            <h4>
              <div class="score-tooltip-wrapper">
                <span class="source-badge openalex">OpenAlex</span>
                <span class="score-inline">åŒ¹é…åˆ† ${oaScore.toFixed(3)}</span>
                ${renderScoreTooltip(oaDetails)}
              </div>
              ${
                oa
                  ? `<a href="${esc(oa.id)}" target="_blank" class="link-badge">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path>
                  <polyline points="15 3 21 3 21 9"></polyline>
                  <line x1="10" y1="14" x2="21" y2="3"></line>
                </svg>
                è¯¦æƒ…
              </a>`
                  : ""
              }
            </h4>
            ${
              oa
                ? `
              <div class="detail-grid">
                <div class="detail-label">æ ‡é¢˜</div>
                <div class="detail-value">${esc(oa.title || "-")}</div>
                <div class="detail-label">æ¥æº</div>
                <div class="detail-value">${esc(
                  oa.primary_location?.source?.display_name || "-"
                )}</div>
                <div class="detail-label">å¹´ä»½</div>
                <div class="detail-value">${esc(
                  oa.publication_year || "-"
                )}</div>
                <div class="detail-label">å·æœŸé¡µ</div>
                <div class="detail-value">${esc(
                  oa.biblio?.volume || "-"
                )}(${esc(oa.biblio?.issue || "-")}):${esc(
                    oa.biblio?.first_page || "-"
                  )}-${esc(oa.biblio?.last_page || "-")}</div>
                <div class="detail-label">DOI</div>
                <div class="detail-value">${
                  oa.doi
                    ? `<a href="https://doi.org/${esc(
                        oa.doi.replace("https://doi.org/", "")
                      )}" target="_blank">${esc(oa.doi)}</a>`
                    : "-"
                }</div>
              </div>
            `
                : `<div style="color:var(--text-muted);font-size:13px;padding:20px 0;text-align:center;">æœªæ‰¾åˆ°åŒ¹é…ç»“æœ</div>`
            }
          </div>

          <div class="source-card">
            <h4>
              <div class="score-tooltip-wrapper">
                <span class="source-badge crossref">Crossref</span>
                <span class="score-inline">åŒ¹é…åˆ† ${crScore.toFixed(3)}</span>
                ${renderScoreTooltip(crDetails)}
              </div>
            </h4>
            ${
              cr
                ? `
              <div class="detail-grid">
                <div class="detail-label">æ ‡é¢˜</div>
                <div class="detail-value">${esc(
                  (cr.title && cr.title[0]) || "-"
                )}</div>
                <div class="detail-label">æœŸåˆŠ</div>
                <div class="detail-value">${esc(
                  (cr["container-title"] && cr["container-title"][0]) || "-"
                )}</div>
                <div class="detail-label">å¹´ä»½</div>
                <div class="detail-value">${esc(
                  cr.issued?.["date-parts"]?.[0]?.[0] || "-"
                )}</div>
                <div class="detail-label">å·æœŸé¡µ</div>
                <div class="detail-value">${esc(cr.volume || "-")}(${esc(
                    cr.issue || "-"
                  )}):${esc(cr.page || "-")}</div>
                <div class="detail-label">DOI</div>
                <div class="detail-value">${
                  cr.DOI
                    ? `<a href="https://doi.org/${esc(
                        cr.DOI
                      )}" target="_blank">${esc(cr.DOI)}</a>`
                    : "-"
                }</div>
              </div>
            `
                : `<div style="color:var(--text-muted);font-size:13px;padding:20px 0;text-align:center;">æœªæ‰¾åˆ°åŒ¹é…ç»“æœ</div>`
            }
          </div>
        </div>

        <div class="detail-section">
          <div class="detail-actions">
            <button class="btn btn-extract btn-small" onclick="copyBibTeX(${index}, this)" title="å¤åˆ¶æ­¤æ¡ç›®çš„ BibTeX">
              <svg width="13" height="13" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5">
                <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                <path d="M5 15H4a2 2 0 01-2-2V4a2 2 0 012-2h9a2 2 0 012 2v1"></path>
              </svg>
              å¤åˆ¶ BibTeX
            </button>
          </div>
        </div>
      </div>
    </div>
  `;
      }

      function toggleResult(index) {
        const item = document.querySelector(
          `.result-item[data-index="${index}"]`
        );
        if (item) item.classList.toggle("expanded");
      }

      function updateStats(results) {
        const total = results.length;
        const high = results.filter((r) => r.verdict.level === "high").length;
        const medium = results.filter(
          (r) => r.verdict.level === "medium"
        ).length;
        const low = results.filter((r) => r.verdict.level === "low").length;

        document.getElementById("statTotal").textContent = total;
        document.getElementById("statHigh").textContent = high;
        document.getElementById("statMedium").textContent = medium;
        document.getElementById("statLow").textContent = low;
        document.getElementById("summary").classList.add("active");

        // æ˜¾ç¤ºå¯¼å‡ºåŒºåŸŸ
        if (total > 0) {
          document.getElementById("exportSection").classList.add("active");
        }

        // ä¿å­˜ç»“æœåˆ°å…¨å±€å˜é‡ä¾›å¯¼å‡ºä½¿ç”¨
        window.currentResults = results;

        // æ ¡éªŒå®Œæˆåï¼Œå¦‚æœæœ‰é«˜å¯ä¿¡æ¡ç›®ï¼Œé»˜è®¤é€‰æ‹©"é«˜å¯ä¿¡"
        if (!window.extractedMode && high > 0) {
          exportMode = "high";
          document
            .querySelectorAll(".export-option")
            .forEach((o) => o.classList.remove("active"));
          document
            .querySelector(".export-option[data-value='high']")
            .classList.add("active");
        } else {
          switchToAll();
        }
      }

      function updateProgress(current, total, status) {
        const percent = total > 0 ? (current / total) * 100 : 0;
        document.getElementById("progressFill").style.width = percent + "%";
        document.getElementById(
          "progressCount"
        ).textContent = `${current} / ${total}`;
        document.getElementById("progressStatus").textContent = status;
      }

      /** ---------- ä¸»é€»è¾‘ ---------- */
      document.getElementById("run").addEventListener("click", async () => {
        const btn = document.getElementById("run");
        const resultsDiv = document.getElementById("results");
        const progressDiv = document.getElementById("progress");
        const summaryDiv = document.getElementById("summary");

        const rawText = document.getElementById("citation").value;
        const mailto = document.getElementById("mailto").value.trim();

        // è§£æå¤šè¡Œï¼Œè¿‡æ»¤ç©ºè¡Œ
        const lines = rawText
          .split("\n")
          .map((l) => l.trim())
          .filter(Boolean);

        if (lines.length === 0) {
          resultsDiv.innerHTML = `
      <div class="card empty-state">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
          <path d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"/>
        </svg>
        <div>è¯·è¾“å…¥è‡³å°‘ä¸€æ¡å¼•ç”¨</div>
      </div>
    `;
          return;
        }

        // é‡ç½®UI
        btn.disabled = true;
        const originalText = btn.textContent;
        btn.innerHTML = `<span class="loading-spinner"></span> æ ¡éªŒä¸­...`;
        resultsDiv.innerHTML = "";
        summaryDiv.classList.remove("active");
        progressDiv.classList.add("active");
        updateProgress(0, lines.length, "å‡†å¤‡ä¸­...");

        // æ¸…é™¤æå–æ¨¡å¼ï¼Œæ ¡éªŒå®Œæˆåå°†ä½¿ç”¨æ ¡éªŒç»“æœç”Ÿæˆ BibTeX
        window.extractedMode = false;

        const results = [];

        for (let i = 0; i < lines.length; i++) {
          updateProgress(i, lines.length, `æ­£åœ¨æ ¡éªŒç¬¬ ${i + 1} æ¡...`);

          // æ˜¾ç¤ºå¤„ç†ä¸­å ä½
          resultsDiv.innerHTML += `<div class="processing-item" id="processing-${i}">æ­£åœ¨æ ¡éªŒï¼š${esc(
            lines[i].slice(0, 60)
          )}...</div>`;

          try {
            const result = await verifySingle(lines[i], mailto);
            results.push(result);

            // æ›¿æ¢å ä½ä¸ºçœŸå®ç»“æœ
            const placeholder = document.getElementById(`processing-${i}`);
            if (placeholder) {
              placeholder.outerHTML = renderResult(result, i);
            }
          } catch (e) {
            results.push({
              raw: lines[i],
              parsed: parseCitation(lines[i]),
              oaBest: null,
              crBest: null,
              oaScore: 0,
              crScore: 0,
              combined: 0,
              verdict: { level: "low", text: "é”™è¯¯", desc: e.message },
            });

            const placeholder = document.getElementById(`processing-${i}`);
            if (placeholder) {
              placeholder.outerHTML = renderResult(
                results[results.length - 1],
                i
              );
            }
          }

          // æ·»åŠ å°å»¶è¿Ÿé¿å…è¯·æ±‚è¿‡å¿«
          if (i < lines.length - 1) {
            await new Promise((r) => setTimeout(r, 300));
          }
        }

        updateProgress(lines.length, lines.length, "æ ¡éªŒå®Œæˆ");
        updateStats(results);

        btn.disabled = false;
        btn.textContent = originalText;

        // éšè—è¿›åº¦æ¡
        setTimeout(() => {
          progressDiv.classList.remove("active");
        }, 1000);
      });

      document.getElementById("clear").addEventListener("click", () => {
        document.getElementById("citation").value = "";
        document.getElementById("results").innerHTML = "";
        document.getElementById("summary").classList.remove("active");
        document.getElementById("progress").classList.remove("active");
        document.getElementById("exportSection").classList.remove("active");
        window.currentResults = [];
      });

      /** ---------- BibTeX å¯¼å‡ºåŠŸèƒ½ ---------- */
      // æ˜¾ç¤ºæç¤ºæ¶ˆæ¯
      function showToast(message) {
        const toast = document.getElementById("toast");
        toast.textContent = message;
        toast.classList.add("show");
        setTimeout(() => toast.classList.remove("show"), 2000);
      }

      // å¯¼å‡ºæ¨¡å¼ï¼šall æˆ– high
      let exportMode = "all";

      // é€‰æ‹©å™¨åˆ‡æ¢
      document.querySelectorAll(".export-option").forEach((option) => {
        option.addEventListener("click", () => {
          document
            .querySelectorAll(".export-option")
            .forEach((o) => o.classList.remove("active"));
          option.classList.add("active");
          exportMode = option.dataset.value;
        });
      });

      // åˆ‡æ¢åˆ°å…¨éƒ¨æ¨¡å¼
      function switchToAll() {
        exportMode = "all";
        document
          .querySelectorAll(".export-option")
          .forEach((o) => o.classList.remove("active"));
        document
          .querySelector(".export-option[data-value='all']")
          .classList.add("active");
      }

      // è·å–è¦å¯¼å‡ºçš„ç»“æœå’Œæ™ºèƒ½æç¤ºä¿¡æ¯
      function getResultsForExport() {
        const results = window.currentResults || [];
        if (results.length === 0)
          return { results: [], message: "æš‚æ— ç»“æœ", needSwitch: false };

        // æå–æ¨¡å¼ä¸‹æ²¡æœ‰é«˜å¯ä¿¡æ¦‚å¿µ
        if (window.extractedMode && results[0]?.isExtracted) {
          if (exportMode === "high") {
            return {
              results: [],
              message: "æœªç»è¿‡æ ¡éªŒï¼Œæ— é«˜å¯ä¿¡æ¡ç›®",
              needSwitch: true,
            };
          }
          return { results, message: "", needSwitch: false };
        }

        if (exportMode === "high") {
          const highResults = results.filter((r) => r.verdict.level === "high");
          if (highResults.length === 0) {
            const medium = results.filter(
              (r) => r.verdict.level === "medium"
            ).length;
            const low = results.filter((r) => r.verdict.level === "low").length;
            if (medium > 0 || low > 0) {
              return {
                results: [],
                message: `æ— é«˜å¯ä¿¡æ¡ç›®ï¼ˆ${medium}ä¸­å¯ä¿¡/${low}ä½å¯ä¿¡ï¼‰`,
                needSwitch: true,
              };
            }
            return { results: [], message: "æ— é«˜å¯ä¿¡æ¡ç›®", needSwitch: true };
          }
          return { results: highResults, message: "", needSwitch: false };
        }

        return { results, message: "", needSwitch: false };
      }

      // ç”Ÿæˆ BibTeX å­—ç¬¦ä¸²
      function generateBibTeXString(results) {
        if (results.length === 0) return "";

        const isExtractedMode = window.extractedMode && results[0]?.isExtracted;
        return results
          .map((r) =>
            isExtractedMode
              ? generateBibTeXFromParsed(r.parsed)
              : generateBibTeX(r)
          )
          .join("\n\n");
      }

      // ä¸‹è½½ BibTeX
      document.getElementById("exportBib").addEventListener("click", () => {
        const { results, message, needSwitch } = getResultsForExport();
        if (results.length === 0) {
          showToast(message);
          if (needSwitch) switchToAll();
          return;
        }

        const allBibtex = generateBibTeXString(results);
        const filename = `citations_${new Date()
          .toISOString()
          .slice(0, 10)}.bib`;
        downloadFile(allBibtex, filename);
        showToast(`å·²ä¸‹è½½ ${results.length} æ¡ BibTeX`);
      });

      // å¤åˆ¶ BibTeX
      document.getElementById("copyBib").addEventListener("click", async () => {
        const { results, message, needSwitch } = getResultsForExport();
        if (results.length === 0) {
          showToast(message);
          if (needSwitch) switchToAll();
          return;
        }

        const allBibtex = generateBibTeXString(results);
        const success = await copyToClipboard(allBibtex);

        if (success) {
          showToast(`å·²å¤åˆ¶ ${results.length} æ¡ BibTeX`);
        } else {
          showToast("å¤åˆ¶å¤±è´¥ï¼Œè¯·é‡è¯•");
        }
      });

      // å¤åˆ¶å•ä¸ª BibTeXï¼ˆç»“æœé¡¹å†…ï¼‰
      async function copyBibTeX(index, button) {
        const results = window.currentResults || [];
        if (!results[index]) return;

        const isExtracted = window.extractedMode && results[index]?.isExtracted;
        const bibtex = isExtracted
          ? generateBibTeXFromParsed(results[index].parsed)
          : generateBibTeX(results[index]);
        const success = await copyToClipboard(bibtex);

        if (success) {
          const originalText = button.innerHTML;
          button.innerHTML = `<svg width="13" height="13" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5"><polyline points="20 6 9 17 4 12"></polyline></svg> å·²å¤åˆ¶`;
          setTimeout(() => (button.innerHTML = originalText), 2000);
        } else {
          showToast("å¤åˆ¶å¤±è´¥ï¼Œè¯·é‡è¯•");
        }
      }

      // æå– BibTeXï¼ˆä¸è°ƒç”¨ APIï¼‰
      document.getElementById("extractBib").addEventListener("click", () => {
        const rawText = document.getElementById("citation").value;
        const resultsDiv = document.getElementById("results");
        const summaryDiv = document.getElementById("summary");
        const exportSection = document.getElementById("exportSection");

        const lines = rawText
          .split("\n")
          .map((l) => l.trim())
          .filter(Boolean);

        if (lines.length === 0) {
          resultsDiv.innerHTML = `
      <div class="card empty-state">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
          <path d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"/>
        </svg>
        <div>è¯·è¾“å…¥è‡³å°‘ä¸€æ¡å¼•ç”¨</div>
      </div>
    `;
          return;
        }

        // ç”Ÿæˆä»…è§£æçš„ç»“æœï¼ˆä¸è°ƒç”¨ APIï¼‰
        const results = lines.map((line, i) => {
          const parsed = parseCitation(line);
          return {
            raw: line,
            parsed: parsed,
            oaBest: null,
            crBest: null,
            oaScore: 0,
            crScore: 0,
            combined: 0,
            verdict: { level: "medium", text: "æœªæ ¡éªŒ", desc: "åŸºäºè§£æ" },
            isExtracted: true, // æ ‡è®°ä¸ºä»…æå–ï¼Œæœªæ ¡éªŒ
          };
        });

        // æ˜¾ç¤ºç»“æœ
        resultsDiv.innerHTML = results
          .map((r, i) => renderExtractedResult(r, i))
          .join("");

        // æ›´æ–°ç»Ÿè®¡
        const total = results.length;
        document.getElementById("statTotal").textContent = total;
        document.getElementById("statHigh").textContent = "-";
        document.getElementById("statMedium").textContent = "-";
        document.getElementById("statLow").textContent = "-";
        summaryDiv.classList.add("active");
        exportSection.classList.add("active");

        // ä¿å­˜ç»“æœåˆ°å…¨å±€å˜é‡
        window.currentResults = results;
        window.extractedMode = true; // æ ‡è®°å½“å‰ä¸ºæå–æ¨¡å¼

        // æå–æ¨¡å¼ä¸‹é‡ç½®é€‰æ‹©å™¨ä¸º"å…¨éƒ¨"
        exportMode = "all";
        document
          .querySelectorAll(".export-option")
          .forEach((o) => o.classList.remove("active"));
        document
          .querySelector(".export-option[data-value='all']")
          .classList.add("active");
      });

      // æ¸²æŸ“ä»…æå–çš„ç»“æœï¼ˆä¸è°ƒç”¨ APIï¼‰
      function renderExtractedResult(result, index) {
        const { raw, parsed } = result;

        return `
    <div class="result-item" data-index="${index}">
      <div class="result-header" onclick="toggleResult(${index})">
        <div class="result-index">${index + 1}</div>
        <div class="result-title">${esc(parsed.title || raw.slice(0, 80))}</div>
        <div class="result-score medium">æœªæ ¡éªŒ</div>
        <div class="result-toggle">
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <polyline points="6 9 12 15 18 9"></polyline>
          </svg>
        </div>
      </div>
      <div class="result-details">
        <div class="detail-section">
          <h4>è§£æå­—æ®µ</h4>
          <div class="detail-grid">
            <div class="detail-label">åŸå§‹å¼•ç”¨</div>
            <div class="detail-value" style="font-size:12px;color:var(--text-muted)">${esc(
              raw
            )}</div>
            <div class="detail-label">æ ‡é¢˜</div>
            <div class="detail-value">${esc(parsed.title || "-")}</div>
            <div class="detail-label">ä½œè€…</div>
            <div class="detail-value">${esc(
              (parsed.authors || []).join(", ") || "-"
            )}</div>
            <div class="detail-label">æœŸåˆŠ/å‡ºç‰ˆç¤¾</div>
            <div class="detail-value">${esc(parsed.journal || "-")}</div>
            <div class="detail-label">å¹´ä»½</div>
            <div class="detail-value">${esc(parsed.year || "-")}</div>
            <div class="detail-label">å·(æœŸ):é¡µç </div>
            <div class="detail-value">${esc(parsed.volume || "-")}(${esc(
          parsed.issue || "-"
        )}):${esc(parsed.firstPage || "-")}-${esc(parsed.lastPage || "-")}</div>
            <div class="detail-label">DOI</div>
            <div class="detail-value">${esc(parsed.doi || "æœªæä¾›")}</div>
          </div>
        </div>

        <div class="detail-section">
          <h4> BibTeX é¢„è§ˆ</h4>
          <pre style="background:var(--bg);padding:12px;border-radius:8px;font-size:12px;overflow-x:auto;max-height:200px;overflow-y:auto;border:1px solid var(--border);">${esc(
            generateBibTeXFromParsed(parsed)
          )}</pre>
        </div>

        <div class="detail-section">
          <div class="detail-actions">
            <button class="btn btn-extract btn-small" onclick="copyExtractedBib(${index}, this)" title="å¤åˆ¶æ­¤æ¡ç›®çš„ BibTeX">
              <svg width="13" height="13" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5">
                <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                <path d="M5 15H4a2 2 0 01-2-2V4a2 2 0 012-2h9a2 2 0 012 2v1"></path>
              </svg>
              å¤åˆ¶ BibTeX
            </button>
          </div>
        </div>
      </div>
    </div>
  `;
      }

      // å¤åˆ¶æå–æ¨¡å¼çš„å•ä¸ª BibTeX
      async function copyExtractedBib(index, button) {
        const results = window.currentResults || [];
        if (!results[index]) return;

        const bibtex = generateBibTeXFromParsed(results[index].parsed);
        const success = await copyToClipboard(bibtex);

        if (success) {
          const originalText = button.innerHTML;
          button.innerHTML = `<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="20 6 9 17 4 12"></polyline></svg> å·²å¤åˆ¶`;
          setTimeout(() => (button.innerHTML = originalText), 2000);
        } else {
          showToast("å¤åˆ¶å¤±è´¥ï¼Œè¯·é‡è¯•");
        }
      }

      // é»˜è®¤å±•å¼€ç¬¬ä¸€ä¸ªç»“æœ
      window.toggleResult = toggleResult;
      window.copyBibTeX = copyBibTeX;
      window.copyExtractedBib = copyExtractedBib;

      /** ---------- å¼¹çª—å’Œåé¦ˆ ---------- */
      // æ‰“å¼€æ‰“åˆ†æ ‡å‡†å¼¹çª—
      function openScoreRulesModal() {
        document.getElementById("scoreRulesModal").classList.add("show");
        document.body.style.overflow = "hidden";
      }

      // å…³é—­æ‰“åˆ†æ ‡å‡†å¼¹çª—
      function closeScoreRulesModal() {
        document.getElementById("scoreRulesModal").classList.remove("show");
        document.body.style.overflow = "";
      }

      // æ‰“å¼€æ ¼å¼ç¤ºä¾‹å¼¹çª—
      function openFormatGuideModal() {
        document.getElementById("formatGuideModal").classList.add("show");
        document.body.style.overflow = "hidden";
      }

      // å…³é—­æ ¼å¼ç¤ºä¾‹å¼¹çª—
      function closeFormatGuideModal() {
        document.getElementById("formatGuideModal").classList.remove("show");
        document.body.style.overflow = "";
      }

      // ç‚¹å‡»é®ç½©å…³é—­å¼¹çª—
      document
        .getElementById("scoreRulesModal")
        .addEventListener("click", (e) => {
          if (e.target === e.currentTarget) {
            closeScoreRulesModal();
          }
        });

      document
        .getElementById("formatGuideModal")
        .addEventListener("click", (e) => {
          if (e.target === e.currentTarget) {
            closeFormatGuideModal();
          }
        });

      // ESC é”®å…³é—­å¼¹çª—
      document.addEventListener("keydown", (e) => {
        if (e.key === "Escape") {
          closeScoreRulesModal();
          closeFormatGuideModal();
        }
      });

      // ç»‘å®šæŒ‰é’®äº‹ä»¶
      document
        .getElementById("showScoreRules")
        .addEventListener("click", openScoreRulesModal);
      document
        .getElementById("showFormatGuide")
        .addEventListener("click", openFormatGuideModal);
      document.getElementById("feedback").addEventListener("click", () => {
        window.open(
          "https://github.com/QAbot-zh/citation-checker/issues",
          "_blank"
        );
      });

      window.closeScoreRulesModal = closeScoreRulesModal;
      window.closeFormatGuideModal = closeFormatGuideModal;
    </script>
  </body>
</html>
