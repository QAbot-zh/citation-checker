<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>å¼•ç”¨çœŸä¼ªå¿«é€Ÿæ ¡éªŒï¼ˆOpenAlex + Crossrefï¼‰</title>
    <style>
      :root {
        --primary: #4f46e5;
        --primary-light: #818cf8;
        --success: #10b981;
        --warning: #f59e0b;
        --danger: #ef4444;
        --bg: #f8fafc;
        --card-bg: #ffffff;
        --text: #1e293b;
        --text-muted: #64748b;
        --border: #e2e8f0;
        --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1),
          0 2px 4px -2px rgb(0 0 0 / 0.1);
        --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1),
          0 4px 6px -4px rgb(0 0 0 / 0.1);
      }

      * {
        box-sizing: border-box;
      }

      body {
        font-family: system-ui, -apple-system, "Segoe UI", Roboto, Helvetica,
          Arial, sans-serif;
        max-width: 1200px;
        margin: 0 auto;
        padding: 24px 16px;
        line-height: 1.6;
        background: var(--bg);
        color: var(--text);
      }

      .header {
        text-align: center;
        margin-bottom: 32px;
      }

      .header h1 {
        font-size: 28px;
        font-weight: 700;
        background: linear-gradient(
          135deg,
          var(--primary) 0%,
          var(--primary-light) 100%
        );
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
        margin: 0 0 12px 0;
      }

      .header p {
        color: var(--text-muted);
        font-size: 14px;
        max-width: 700px;
        margin: 0 auto;
      }

      .card {
        background: var(--card-bg);
        border-radius: 16px;
        padding: 24px;
        box-shadow: var(--shadow);
        margin-bottom: 20px;
        border: 1px solid var(--border);
      }

      .card-title {
        font-size: 16px;
        font-weight: 600;
        margin: 0 0 16px 0;
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .input-section {
        display: grid;
        grid-template-columns: 1fr 360px;
        gap: 20px;
      }

      @media (max-width: 768px) {
        .input-section {
          grid-template-columns: 1fr;
        }
      }

      label {
        display: block;
        font-size: 14px;
        font-weight: 500;
        margin-bottom: 8px;
        color: var(--text);
      }

      textarea,
      input[type="text"],
      input[type="email"] {
        width: 100%;
        padding: 12px 16px;
        border: 2px solid var(--border);
        border-radius: 12px;
        font-size: 14px;
        transition: all 0.2s ease;
        background: var(--card-bg);
        font-family: inherit;
      }

      textarea:focus,
      input:focus {
        outline: none;
        border-color: var(--primary);
        box-shadow: 0 0 0 3px rgba(79, 70, 229, 0.1);
      }

      textarea {
        resize: vertical;
        min-height: 180px;
      }

      .hint {
        font-size: 12px;
        color: var(--text-muted);
        margin-top: 8px;
      }

      .btn {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        gap: 8px;
        padding: 12px 24px;
        border: none;
        border-radius: 12px;
        font-size: 15px;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.25s ease;
      }

      .btn-primary {
        background: linear-gradient(
          135deg,
          var(--primary) 0%,
          var(--primary-light) 100%
        );
        color: white;
        box-shadow: 0 4px 14px 0 rgba(79, 70, 229, 0.35);
      }

      .btn-primary:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 20px 0 rgba(79, 70, 229, 0.45);
      }

      .btn-primary:active {
        transform: translateY(0);
      }

      .btn-primary:disabled {
        opacity: 0.6;
        cursor: not-allowed;
        transform: none;
      }

      .btn-extract {
        background: linear-gradient(135deg, #06b6d4 0%, #22d3ee 100%);
        color: white;
        box-shadow: 0 4px 14px 0 rgba(6, 182, 212, 0.35);
      }

      .btn-extract:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 20px 0 rgba(6, 182, 212, 0.45);
      }

      .btn-extract:active {
        transform: translateY(0);
      }

      .btn-success {
        background: linear-gradient(135deg, var(--success) 0%, #34d399 100%);
        color: white;
        box-shadow: 0 4px 14px 0 rgba(16, 185, 129, 0.35);
      }

      .btn-success:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 20px 0 rgba(16, 185, 129, 0.45);
      }

      .btn-success:active {
        transform: translateY(0);
      }

      .btn-copy {
        background: linear-gradient(135deg, #f97316 0%, #fb923c 100%);
        color: white;
        box-shadow: 0 4px 14px 0 rgba(249, 115, 22, 0.35);
      }

      .btn-copy:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 20px 0 rgba(249, 115, 22, 0.45);
      }

      .btn-copy:active {
        transform: translateY(0);
      }

      .btn-secondary {
        background: var(--card-bg);
        color: var(--text);
        border: 2px solid var(--border);
      }

      .btn-secondary:hover {
        background: var(--bg);
        border-color: #cbd5e1;
      }

      .btn-secondary:active {
        transform: scale(0.98);
      }

      .btn-clear {
        background: linear-gradient(135deg, #64748b 0%, #94a3b8 100%);
        color: white;
        box-shadow: 0 4px 14px 0 rgba(100, 116, 139, 0.35);
      }

      .btn-clear:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 20px 0 rgba(100, 116, 139, 0.45);
      }

      .btn-clear:active {
        transform: translateY(0);
      }

      .actions {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
        margin-top: 16px;
      }

      .progress-container {
        display: none;
        margin-bottom: 20px;
      }

      .progress-container.active {
        display: block;
      }

      .progress-bar {
        height: 8px;
        background: var(--border);
        border-radius: 4px;
        overflow: hidden;
      }

      .progress-fill {
        height: 100%;
        background: linear-gradient(
          90deg,
          var(--primary),
          var(--primary-light)
        );
        border-radius: 4px;
        transition: width 0.3s ease;
        width: 0%;
      }

      .progress-text {
        display: flex;
        justify-content: space-between;
        font-size: 13px;
        color: var(--text-muted);
        margin-top: 8px;
      }

      .summary {
        display: none;
        grid-template-columns: repeat(4, 1fr);
        gap: 16px;
        margin-bottom: 20px;
      }

      .summary.active {
        display: grid;
      }

      @media (max-width: 600px) {
        .summary {
          grid-template-columns: repeat(2, 1fr);
        }
      }

      .stat-card {
        background: var(--card-bg);
        border-radius: 12px;
        padding: 16px;
        text-align: center;
        border: 1px solid var(--border);
        box-shadow: var(--shadow);
      }

      .stat-value {
        font-size: 28px;
        font-weight: 700;
      }

      .stat-label {
        font-size: 13px;
        color: var(--text-muted);
        margin-top: 4px;
      }

      .stat-card.total .stat-value {
        color: var(--primary);
      }
      .stat-card.high .stat-value {
        color: var(--success);
      }
      .stat-card.medium .stat-value {
        color: var(--warning);
      }
      .stat-card.low .stat-value {
        color: var(--danger);
      }

      .result-item {
        background: var(--card-bg);
        border-radius: 12px;
        margin-bottom: 16px;
        border: 1px solid var(--border);
        box-shadow: var(--shadow);
        overflow: hidden;
        animation: slideIn 0.3s ease;
      }

      @keyframes slideIn {
        from {
          opacity: 0;
          transform: translateY(10px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      .result-header {
        padding: 16px 20px;
        display: flex;
        align-items: center;
        gap: 12px;
        cursor: pointer;
        user-select: none;
        transition: background 0.2s;
      }

      .result-header:hover {
        background: var(--bg);
      }

      .result-index {
        width: 32px;
        height: 32px;
        border-radius: 8px;
        background: var(--bg);
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: 600;
        font-size: 14px;
        color: var(--text-muted);
        flex-shrink: 0;
      }

      .result-title {
        flex: 1;
        font-size: 14px;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }

      .result-score {
        padding: 6px 12px;
        border-radius: 20px;
        font-size: 13px;
        font-weight: 600;
        flex-shrink: 0;
      }

      .result-score.high {
        background: rgba(16, 185, 129, 0.1);
        color: var(--success);
      }

      .result-score.medium {
        background: rgba(245, 158, 11, 0.1);
        color: var(--warning);
      }

      .result-score.low {
        background: rgba(239, 68, 68, 0.1);
        color: var(--danger);
      }

      .result-toggle {
        width: 24px;
        height: 24px;
        display: flex;
        align-items: center;
        justify-content: center;
        color: var(--text-muted);
        transition: transform 0.2s;
      }

      .result-item.expanded .result-toggle {
        transform: rotate(180deg);
      }

      .result-details {
        display: none;
        padding: 0 20px 20px;
        border-top: 1px solid var(--border);
      }

      .result-item.expanded .result-details {
        display: block;
      }

      .detail-section {
        margin-top: 16px;
      }

      .detail-section h4 {
        font-size: 14px;
        font-weight: 600;
        margin: 0 0 12px 0;
        color: var(--text);
      }

      .detail-grid {
        display: grid;
        grid-template-columns: 120px 1fr;
        gap: 8px 16px;
        font-size: 13px;
      }

      .detail-label {
        color: var(--text-muted);
      }

      .detail-value {
        color: var(--text);
        word-break: break-word;
      }

      .detail-value a {
        color: var(--primary);
        text-decoration: none;
      }

      .detail-value a:hover {
        text-decoration: underline;
      }

      .source-badge {
        display: inline-flex;
        align-items: center;
        gap: 4px;
        padding: 4px 10px;
        border-radius: 6px;
        font-size: 12px;
        font-weight: 500;
        margin-right: 8px;
      }

      .source-badge.openalex {
        background: rgba(79, 70, 229, 0.1);
        color: var(--primary);
      }

      .source-badge.crossref {
        background: rgba(245, 158, 11, 0.1);
        color: var(--warning);
      }

      .score-inline {
        font-size: 12px;
        color: var(--text-muted);
      }

      .empty-state {
        text-align: center;
        padding: 60px 20px;
        color: var(--text-muted);
      }

      .empty-state svg {
        width: 64px;
        height: 64px;
        margin-bottom: 16px;
        opacity: 0.5;
      }

      .loading-spinner {
        display: inline-block;
        width: 16px;
        height: 16px;
        border: 2px solid rgba(255, 255, 255, 0.3);
        border-radius: 50%;
        border-top-color: white;
        animation: spin 0.8s linear infinite;
      }

      @keyframes spin {
        to {
          transform: rotate(360deg);
        }
      }

      .processing-item {
        background: linear-gradient(
          90deg,
          var(--bg) 25%,
          var(--card-bg) 50%,
          var(--bg) 75%
        );
        background-size: 200% 100%;
        animation: shimmer 1.5s infinite;
        border-radius: 12px;
        padding: 16px 20px;
        margin-bottom: 16px;
        border: 1px solid var(--border);
      }

      @keyframes shimmer {
        0% {
          background-position: 200% 0;
        }
        100% {
          background-position: -200% 0;
        }
      }

      .verdict-bar {
        display: flex;
        gap: 8px;
        margin-top: 12px;
      }

      .verdict-segment {
        flex: 1;
        height: 4px;
        border-radius: 2px;
        background: var(--border);
      }

      .verdict-segment.active.high {
        background: var(--success);
      }
      .verdict-segment.active.medium {
        background: var(--warning);
      }
      .verdict-segment.active.low {
        background: var(--danger);
      }

      .detail-actions {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
      }

      .btn-small {
        padding: 9px 18px;
        font-size: 13px;
        gap: 6px;
        border-radius: 10px;
      }

      .export-section {
        display: none;
        align-items: center;
        justify-content: center;
        gap: 16px;
        margin: 20px 0;
        flex-wrap: wrap;
      }

      .export-section.active {
        display: flex;
      }

      .export-selector {
        display: flex;
        background: var(--bg);
        border-radius: 10px;
        padding: 4px;
        border: 2px solid var(--success);
        box-shadow: 0 4px 12px 0 rgba(16, 185, 129, 0.15);
      }

      .export-option {
        padding: 10px 24px;
        border-radius: 8px;
        font-size: 14px;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.25s ease;
        color: var(--text-muted);
        user-select: none;
        position: relative;
      }

      .export-option:hover {
        color: var(--text);
        background: rgba(16, 185, 129, 0.1);
      }

      .export-option.active {
        background: linear-gradient(135deg, var(--success) 0%, #34d399 100%);
        color: white;
        box-shadow: 0 2px 8px 0 rgba(16, 185, 129, 0.3);
      }

      .toast {
        position: fixed;
        bottom: 80px;
        left: 50%;
        transform: translateX(-50%) translateY(100px);
        background: linear-gradient(
          135deg,
          var(--primary) 0%,
          var(--primary-light) 100%
        );
        color: white;
        padding: 14px 28px;
        border-radius: 12px;
        font-size: 15px;
        font-weight: 500;
        opacity: 0;
        transition: all 0.3s ease;
        z-index: 1000;
        box-shadow: 0 8px 24px 0 rgba(79, 70, 229, 0.4);
      }

      .toast.show {
        transform: translateX(-50%) translateY(0);
        opacity: 1;
      }
    </style>
  </head>
  <body>
    <div class="header">
      <h1>å¼•ç”¨çœŸä¼ªå¿«é€Ÿæ ¡éªŒ</h1>
      <p>
        é€šè¿‡ OpenAlex ä¸ Crossref
        åŒæ•°æ®æºäº¤å‰éªŒè¯ï¼Œæ™ºèƒ½è§£æå¼•ç”¨å­—æ®µå¹¶è¯„ä¼°å¯ä¿¡åº¦ã€‚æ”¯æŒæ‰¹é‡æ ¡éªŒï¼Œæ¯è¡Œä¸€æ¡å¼•ç”¨ã€‚
      </p>
      <p style="font-size: 12px; margin-top: 8px; color: var(--text-muted)">
        ğŸ“š æ”¯æŒæ ¼å¼ï¼šGB/T
        7714ï¼ˆä¸­æ–‡çŸ¥ç½‘ï¼‰ã€APAã€MLAã€Chicagoã€Harvardã€IEEEã€Vancouverã€Natureã€Scienceã€BibTeX
        ç­‰
      </p>
    </div>

    <div class="card">
      <div class="input-section">
        <div>
          <label for="citation">ç²˜è´´å¼•ç”¨æ¡ç›®ï¼ˆæ”¯æŒå¤šæ¡ï¼Œæ¯è¡Œä¸€æ¡ï¼‰</label>
          <textarea
            id="citation"
            placeholder='æ”¯æŒå¤šç§æ ¼å¼ï¼Œæ¯è¡Œä¸€æ¡å¼•ç”¨ï¼Œä¾‹å¦‚ï¼š

GB/T 7714: å¼ ä¸‰, æå››. è®ºæ–‡æ ‡é¢˜[J]. æœŸåˆŠå, 2023, 15(3): 100-110.
APA: Smith, J. A. (2023). Title of article. Journal Name, 15(3), 100-110.
IEEE: [1] J. Smith, "Article title," Journal, vol. 15, no. 3, pp. 100-110, 2023.
Vancouver: Smith JA. Article title. Journal. 2023;15(3):100-110.
Nature: Smith, J. et al. Article title. Nature 600, 100-110 (2023).
DOI: 10.1000/xyz123'
          ></textarea>
          <div class="hint">
            æç¤ºï¼šæ¯è¡Œç²˜è´´ä¸€æ¡å¼•ç”¨ï¼Œç³»ç»Ÿå°†é€æ¡æ ¡éªŒå¹¶æ±‡æ€»ç»“æœã€‚ç©ºè¡Œä¼šè¢«è‡ªåŠ¨å¿½ç•¥ã€‚
          </div>
        </div>
        <div>
          <label for="mailto">è”ç³»é‚®ç®±ï¼ˆå¯é€‰ï¼‰</label>
          <input type="email" id="mailto" placeholder="you@example.com" />
          <div class="hint">
            æä¾›é‚®ç®±å¯è¿›å…¥ OpenAlex/Crossref çš„ polite poolï¼Œè·å¾—æ›´ç¨³å®šçš„å“åº”ã€‚
          </div>

          <div class="actions">
            <button
              id="run"
              class="btn btn-primary"
              title="è°ƒç”¨ OpenAlex å’Œ Crossref API æ ¡éªŒå¼•ç”¨çœŸå®æ€§"
            >
              å¼€å§‹æ ¡éªŒ
            </button>
            <button
              id="extractBib"
              class="btn btn-extract"
              title="ç›´æ¥è§£æå¼•ç”¨ç”Ÿæˆ BibTeXï¼Œä¸è°ƒç”¨ API"
            >
              ç”Ÿæˆ BibTeX
            </button>
            <button id="clear" class="btn btn-clear" title="æ¸…ç©ºè¾“å…¥å’Œç»“æœ">
              æ¸…ç©º
            </button>
          </div>
        </div>
      </div>
    </div>

    <div id="progress" class="progress-container">
      <div class="card" style="padding: 16px 20px">
        <div class="progress-bar">
          <div class="progress-fill" id="progressFill"></div>
        </div>
        <div class="progress-text">
          <span id="progressStatus">æ­£åœ¨æ ¡éªŒ...</span>
          <span id="progressCount">0 / 0</span>
        </div>
      </div>
    </div>

    <div id="summary" class="summary">
      <div class="stat-card total">
        <div class="stat-value" id="statTotal">0</div>
        <div class="stat-label">æ€»æ¡ç›®</div>
      </div>
      <div class="stat-card high">
        <div class="stat-value" id="statHigh">0</div>
        <div class="stat-label">é«˜å¯ä¿¡</div>
      </div>
      <div class="stat-card medium">
        <div class="stat-value" id="statMedium">0</div>
        <div class="stat-label">ä¸­å¯ä¿¡</div>
      </div>
      <div class="stat-card low">
        <div class="stat-value" id="statLow">0</div>
        <div class="stat-label">ä½å¯ä¿¡</div>
      </div>
    </div>

    <div id="exportSection" class="export-section">
      <div class="export-selector">
        <div class="export-option active" data-value="all">å…¨éƒ¨</div>
        <div class="export-option" data-value="high">é«˜å¯ä¿¡</div>
      </div>
      <button id="exportBib" class="btn btn-primary" title="ä¸‹è½½ BibTeX æ–‡ä»¶">
        <svg
          width="16"
          height="16"
          viewBox="0 0 24 24"
          fill="none"
          stroke="currentColor"
          stroke-width="2.5"
        >
          <path d="M21 15v4a2 2 0 01-2 2H5a2 2 0 01-2-2v-4"></path>
          <polyline points="7 10 12 15 17 10"></polyline>
          <line x1="12" y1="15" x2="12" y2="3"></line>
        </svg>
        ä¸‹è½½ BibTeX
      </button>
      <button id="copyBib" class="btn btn-copy" title="å¤åˆ¶ BibTeX åˆ°å‰ªè´´æ¿">
        <svg
          width="16"
          height="16"
          viewBox="0 0 24 24"
          fill="none"
          stroke="currentColor"
          stroke-width="2.5"
        >
          <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
          <path d="M5 15H4a2 2 0 01-2-2V4a2 2 0 012-2h9a2 2 0 012 2v1"></path>
        </svg>
        å¤åˆ¶ BibTeX
      </button>
    </div>

    <div id="results"></div>

    <div id="toast" class="toast">å·²å¤åˆ¶åˆ°å‰ªè´´æ¿</div>

    <script>
      function norm(s) {
        return (s || "")
          .toLowerCase()
          .replace(/[\[\]\(\)\{\},.:;'"`~!@#$%^&*_+=<>?/\\|-]/g, " ")
          .replace(/\s+/g, " ")
          .trim();
      }

      function tokens(s) {
        return new Set(norm(s).split(" ").filter(Boolean));
      }

      function jaccard(a, b) {
        const A = tokens(a),
          B = tokens(b);
        if (A.size === 0 || B.size === 0) return 0;
        let inter = 0;
        for (const t of A) if (B.has(t)) inter++;
        const union = A.size + B.size - inter;
        return inter / union;
      }

      function pickBest(items, scoreFn) {
        let best = null,
          bestScore = -1;
        for (const it of items) {
          const sc = scoreFn(it);
          if (sc > bestScore) {
            best = it;
            bestScore = sc;
          }
        }
        return { best, bestScore };
      }

      function esc(s) {
        return (s ?? "").toString().replace(
          /[&<>"']/g,
          (m) =>
            ({
              "&": "&amp;",
              "<": "&lt;",
              ">": "&gt;",
              '"': "&quot;",
              "'": "&#39;",
            }[m])
        );
      }

      // ä»…åŸºäºè§£æçš„å¼•ç”¨ç”Ÿæˆ BibTeXï¼ˆä¸è°ƒç”¨ APIï¼‰
      function generateBibTeXFromParsed(parsed) {
        // åˆ¤æ–­ç±»å‹ï¼šarXiv é¢„å°æœ¬ã€æœŸåˆŠæ–‡ç« ã€ä¹¦ç±ç­‰
        let type = "article";
        if (parsed.arxivId) {
          type = "misc"; // arXiv é¢„å°æœ¬é€šå¸¸ç”¨ misc æˆ– article
        } else if (!parsed.journal && !parsed.volume) {
          type = "book";
        }

        const year = parsed.year || "n.d.";
        const title = parsed.title || "";
        const journal = parsed.journal || "";
        const volume = parsed.volume || "";
        const number = parsed.issue || "";
        // å¤„ç†é¡µç ï¼šå¦‚æœæœ‰æ–‡ç« ç¼–å·ä½†æ²¡æœ‰é¡µç èŒƒå›´ï¼Œä½¿ç”¨æ–‡ç« ç¼–å·
        let pages = "";
        if (parsed.firstPage && parsed.lastPage) {
          pages = `${parsed.firstPage}--${parsed.lastPage}`;
        } else if (parsed.articleNumber) {
          pages = parsed.articleNumber;
        } else if (parsed.firstPage) {
          pages = parsed.firstPage;
        }

        const doi = parsed.doi || "";
        const arxivId = parsed.arxivId || "";
        let url = "";
        if (doi) {
          url = `https://doi.org/${doi}`;
        } else if (arxivId) {
          url = `https://arxiv.org/abs/${arxivId}`;
        }

        // å¤„ç†ä½œè€…
        const authors = (parsed.authors || []).map((a) => {
          // å‡è®¾ä½œè€…å·²ç»æ˜¯å§“æ°æ ¼å¼ï¼Œç›´æ¥ä½¿ç”¨
          return a;
        });

        const authorStr = authors.length > 0 ? authors.join(" and\n  ") : "";

        // ç”Ÿæˆ citation key
        let firstAuthor = authors[0] || "Unknown";
        const firstWord = (title || "").split(/\s+/)[0] || "";
        const cleanWord = firstWord.replace(/[^a-zA-Z0-9]/g, "");
        const citeKey = `${firstAuthor}${year}${cleanWord}`;

        let bibtex = `@${type}{${citeKey},
`;

        if (authorStr)
          bibtex += `  author = {${authorStr}},
`;
        if (title)
          bibtex += `  title = {${title}},
`;
        if (journal && type === "article")
          bibtex += `  journal = {${journal}},
`;
        if (journal && type !== "article")
          bibtex += `  howpublished = {${journal}},
`;
        if (year)
          bibtex += `  year = {${year}},
`;
        if (volume)
          bibtex += `  volume = {${volume}},
`;
        if (number)
          bibtex += `  number = {${number}},
`;
        if (pages)
          bibtex += `  pages = {${pages}},
`;
        if (doi)
          bibtex += `  doi = {${doi}},
`;
        if (arxivId)
          bibtex += `  eprint = {${arxivId}},
  archivePrefix = {arXiv},
`;
        if (url)
          bibtex += `  url = {${url}},
`;

        // ç§»é™¤æœ«å°¾é€—å·
        bibtex = bibtex.replace(/,\n$/, "\n");
        bibtex += "}";

        return bibtex;
      }

      // ä» OpenAlex/Crossref æ•°æ®ç”Ÿæˆ BibTeX
      function generateBibTeX(result) {
        const { parsed, oaBest, crBest } = result;
        const oa = oaBest?.best;
        const cr = crBest?.best;

        // ä¼˜å…ˆä½¿ç”¨ API è¿”å›çš„åŸå§‹ BibTeX
        const rawBib = oa?.biblio?.raw || cr?.["bibliographic-metadata"]?.raw;
        if (
          rawBib &&
          typeof rawBib === "string" &&
          rawBib.trim().startsWith("@")
        ) {
          // æå– citation key
          const entryMatch = rawBib.match(/@(\w+)\s*\{([^,]+),/);
          if (entryMatch) {
            return rawBib.trim();
          }
        }

        // è‡ªè¡Œæ„å»º BibTeX
        const type = parsed.journal ? "article" : "book";
        const year =
          oa?.publication_year ||
          cr?.issued?.["date-parts"]?.[0]?.[0] ||
          parsed.year ||
          "n.d.";
        const title = oa?.title || cr?.title?.[0] || parsed.title || "";

        // æå–ä½œè€…
        let authors = [];
        if (oa?.authorships) {
          authors = oa.authorships.map((a) => {
            const name = a.author?.display_name || "";
            const parts = name.trim().split(/\s+/);
            if (parts.length >= 2) {
              const last = parts[parts.length - 1];
              const first = parts.slice(0, -1).join(" ");
              return `${last}, ${first}`;
            }
            return name;
          });
        } else if (cr?.author) {
          authors = cr.author
            .map((a) => {
              const family = a.family || "";
              const given = a.given || "";
              return family ? (given ? `${family}, ${given}` : family) : "";
            })
            .filter(Boolean);
        } else if (parsed.authors?.length) {
          authors = parsed.authors;
        }

        const authorStr = authors.length > 0 ? authors.join(" and\n  ") : "";

        const journal =
          oa?.primary_location?.source?.display_name ||
          cr?.["container-title"]?.[0] ||
          parsed.journal ||
          "";

        const volume = oa?.biblio?.volume || cr?.volume || parsed.volume || "";
        const number = oa?.biblio?.issue || cr?.issue || parsed.issue || "";
        const pages =
          oa?.biblio?.first_page && oa?.biblio?.last_page
            ? `${oa.biblio.first_page}--${oa.biblio.last_page}`
            : cr?.page || parsed.firstPage
            ? parsed.firstPage && parsed.lastPage
              ? `${parsed.firstPage}--${parsed.lastPage}`
              : cr?.page || ""
            : "";

        const doi = oa?.doi || cr?.DOI || parsed.doi || "";
        const url = oa?.id || (doi ? `https://doi.org/${doi}` : "");

        // ç”Ÿæˆ citation key: ç¬¬ä¸€ä½œè€…å§“æ°+å¹´ä»½+é¦–è¯
        let firstAuthor = authors[0] || "";
        if (firstAuthor.includes(",")) {
          firstAuthor = firstAuthor.split(",")[0].trim();
        }
        const firstWord = (title || "").split(/\s+/)[0] || "";
        const cleanWord = firstWord.replace(/[^a-zA-Z0-9]/g, "");
        const citeKey = `${firstAuthor}${year}${cleanWord}`;

        let bibtex = `@${type}{${citeKey},
`;

        if (authorStr)
          bibtex += `  author = {${authorStr}},
`;
        if (title)
          bibtex += `  title = {${title}},
`;
        if (journal)
          bibtex += `  journal = {${journal}},
`;
        if (year)
          bibtex += `  year = {${year}},
`;
        if (volume)
          bibtex += `  volume = {${volume}},
`;
        if (number)
          bibtex += `  number = {${number}},
`;
        if (pages)
          bibtex += `  pages = {${pages}},
`;
        if (doi)
          bibtex += `  doi = {${doi}},
`;
        if (url)
          bibtex += `  url = {${url}},
`;

        // ç§»é™¤æœ«å°¾é€—å·
        bibtex = bibtex.replace(/,\n$/, "\n");
        bibtex += "}";

        return bibtex;
      }

      // å¤åˆ¶åˆ°å‰ªè´´æ¿
      async function copyToClipboard(text) {
        try {
          await navigator.clipboard.writeText(text);
          return true;
        } catch (e) {
          // å›é€€æ–¹æ¡ˆ
          const textarea = document.createElement("textarea");
          textarea.value = text;
          textarea.style.position = "fixed";
          textarea.style.opacity = "0";
          document.body.appendChild(textarea);
          textarea.select();
          try {
            document.execCommand("copy");
            document.body.removeChild(textarea);
            return true;
          } catch (e2) {
            document.body.removeChild(textarea);
            return false;
          }
        }
      }

      // ä¸‹è½½æ–‡ä»¶
      function downloadFile(content, filename) {
        const blob = new Blob([content], { type: "text/plain;charset=utf-8" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }

      /**
       * å¢å¼ºç‰ˆå‚è€ƒæ–‡çŒ®è§£æå™¨ v2.0
       * æ”¯æŒæ ¼å¼ï¼š
       * - ä¸­æ–‡ï¼šGB/T 7714ï¼ˆçŸ¥ç½‘ã€ä¸‡æ–¹ã€ç»´æ™®æ ‡å‡†æ ¼å¼ï¼‰
       * - è‹±æ–‡ï¼šAPAã€MLAã€Chicagoã€Harvardã€IEEEã€Vancouverã€Natureã€Science
       * - é€šç”¨ï¼šDOIã€BibTeXã€arXiv ç­‰
       *
       * æ ¸å¿ƒåŸåˆ™ï¼š
       * 1. ä¼˜å…ˆåŒ¹é…å…·æœ‰æ˜ç¡®ç‰¹å¾çš„æ ¼å¼ï¼ˆå¦‚ BibTeX çš„ @ã€GB/T 7714 çš„ [J] ç­‰ï¼‰
       * 2. é¿å…è¿‡åº¦åŒ¹é…ï¼Œå®å¯è½å…¥é€šç”¨è§£æä¹Ÿä¸è¦é”™è¯¯åˆ†ç±»
       * 3. æ¯ä¸ªè§£æå™¨ä¸“æ³¨äºè‡ªå·±æ ¼å¼çš„ç‰¹å¾ï¼Œä¸åšè¿‡åº¦æ¨æ–­
       */
      function parseCitation(raw) {
        const s = raw.trim();

        // ========== é€šç”¨å­—æ®µæå– ==========
        // æå–å¹´ä»½ï¼ˆæ›´ä¸¥æ ¼çš„åŒ¹é…ï¼Œé¿å…åŒ¹é…åˆ°å…¶ä»–æ•°å­—ï¼‰
        const yearPatterns = [
          /\((\d{4})\)/, // (2023)
          /\[(\d{4})\]/, // [2023]
          /[,ï¼Œ.ã€‚;ï¼›]\s*(\d{4})\s*[,ï¼Œ.ã€‚;ï¼›]/, // , 2023,
          /[,ï¼Œ]\s*(\d{4})\s*$/, // ç»“å°¾çš„ , 2023
          /^(\d{4})\s*[,ï¼Œ.ã€‚]/, // å¼€å¤´çš„ 2023,
          /[\s,.](\d{4})[\s,.]/, // ç©ºæ ¼æˆ–æ ‡ç‚¹åŒ…å›´çš„å¹´ä»½
        ];
        let year = null;
        for (const pattern of yearPatterns) {
          const match = s.match(pattern);
          if (match) {
            const y = parseInt(match[1], 10);
            if (y >= 1900 && y <= 2100) {
              year = y;
              break;
            }
          }
        }
        // å¦‚æœä¸Šé¢æ²¡åŒ¹é…åˆ°ï¼Œç”¨å®½æ¾æ¨¡å¼
        if (!year) {
          const looseMatch = s.match(/(19|20)\d{2}/);
          if (looseMatch) {
            year = parseInt(looseMatch[0], 10);
          }
        }

        // æå– DOIï¼ˆä¸¥æ ¼åŒ¹é…ï¼‰
        const doiMatch = s.match(/\b(10\.\d{4,9}\/[^\s\]\)>"',]+)/i);
        const doi = doiMatch ? doiMatch[1].replace(/[.,;:\]>]+$/, "") : null;

        // æå– URL
        const urlMatch = s.match(/https?:\/\/[^\s\]\)>]+/i);
        const url = urlMatch ? urlMatch[0].replace(/[.,;:\]>]+$/, "") : null;

        // ========== æ ¼å¼æ£€æµ‹ä¸è§£æï¼ˆæŒ‰ç‰¹å¾æ˜ç¡®ç¨‹åº¦æ’åºï¼‰ ==========

        // 1. BibTeX æ ¼å¼ï¼ˆæœ€æ˜ç¡®ï¼šä»¥ @ å¼€å¤´ï¼‰
        if (s.match(/^\s*@\w+\s*\{/)) {
          return parseBibTeX(s);
        }

        // 2. ä¸­æ–‡ GB/T 7714 æ ¼å¼ï¼ˆæ˜ç¡®ç‰¹å¾ï¼š[J], [M], [C] ç­‰ç±»å‹æ ‡è®°ï¼‰
        const cnTypeMatch = s.match(
          /\[(J|M|C|D|P|N|R|S|A|Z|DB|EB|OL|CP|DS)(?:\/[A-Z]+)?\]/i
        );
        if (cnTypeMatch) {
          return parseChineseGBT7714(s, cnTypeMatch, year, doi);
        }

        // 3. IEEE æ ¼å¼ï¼ˆæ˜ç¡®ç‰¹å¾ï¼šä»¥ [æ•°å­—] å¼€å¤´ + å¼•å·æ ‡é¢˜ æˆ– "vol." + "pp."ï¼‰
        const ieeeNumbered = s.match(
          /^\s*\[?\d+\]?\s*[A-Z][^"]*,\s*[""][^""]+[""]/
        );
        const ieeeKeywords =
          s.match(/\bvol\.\s*\d+/i) && s.match(/\bpp\.\s*\d+/i);
        if (ieeeNumbered || ieeeKeywords) {
          return parseIEEE(s, year, doi);
        }

        // 4. Vancouver/NLM æ ¼å¼ï¼ˆæ˜ç¡®ç‰¹å¾ï¼šå¹´ä»½åè·Ÿåˆ†å·å’Œå·æœŸé¡µç  å¦‚ 2023;15(3):100-110ï¼‰
        const vancouverPattern = s.match(
          /(19|20)\d{2}\s*;\s*\d+\s*\(\d+\)\s*:\s*\d+/
        );
        if (vancouverPattern) {
          return parseVancouver(s, year, doi);
        }

        // 5. arXiv/é¢„å°æœ¬æ ¼å¼ï¼ˆæ˜ç¡®ç‰¹å¾ï¼šarXiv: æˆ– abs/ IDï¼‰
        const arxivPattern =
          s.match(/arXiv\s*[:\s]\s*(\d{4}\.\d{4,5})/i) ||
          s.match(/abs\/(\d{4}\.\d{4,5})/i);
        if (arxivPattern) {
          return parseArxivTechReport(s, year, doi);
        }

        // 6. MDPI/å¼€æ”¾è·å–æ ¼å¼ï¼ˆæ˜ç¡®ç‰¹å¾ï¼šæ˜Ÿå·åŒ…è£¹çš„æœŸåˆŠå *Journal*ï¼‰
        const mdpiPattern = s.match(/\*([^*]+)\*\s*[.,]?\s*\d{4}/);
        if (mdpiPattern) {
          return parseMDPI(s, year, doi);
        }

        // 7. Nature/Science æ ¼å¼ï¼ˆæ˜ç¡®ç‰¹å¾ï¼šæœŸåˆŠå + å·å· + é¡µç  + (å¹´ä»½)ï¼‰
        // å¦‚: Nature 600, 100-110 (2023)
        const naturePattern = s.match(
          /\.\s*([A-Z][a-zA-Z.\s]{2,30}?)\s+(\d{1,4})\s*,\s*(\d+)\s*[-â€“â€”]\s*(\d+)\s*\((\d{4})\)\s*\.?\s*$/
        );
        if (naturePattern) {
          return parseNature(s, year, doi);
        }

        // 8. APA æ ¼å¼ï¼ˆç‰¹å¾ï¼šä½œè€… (å¹´ä»½). æ ‡é¢˜. æœŸåˆŠ, å·(æœŸ), é¡µç .ï¼‰
        // å…³é”®åˆ¤æ–­ï¼šä½œè€…éƒ¨åˆ†åç´§è·Ÿ (å¹´ä»½).
        const apaPattern = s.match(
          /^([^(]+?)\s*\((19|20)\d{2}[a-z]?\)\s*\.\s*(.+)/
        );
        if (apaPattern && !s.match(/^\s*\d+\./)) {
          // æ’é™¤ç¼–å·åˆ—è¡¨
          // è¿›ä¸€æ­¥éªŒè¯ï¼šAPA æ ¼å¼çš„ä½œè€…éƒ¨åˆ†é€šå¸¸åŒ…å«é€—å·å’Œ & æˆ– "and"
          const authorPart = apaPattern[1];
          const hasAPAAuthorFormat =
            authorPart.match(/[A-Z][a-z]+,\s*[A-Z]\./i) ||
            authorPart.match(/&/) ||
            authorPart.match(/,\s*and\s/i);
          if (hasAPAAuthorFormat) {
            return parseAPA(s, year, doi);
          }
        }

        // 9. Harvard æ ¼å¼ï¼ˆç‰¹å¾ï¼šä½œè€… (å¹´ä»½) 'æ ‡é¢˜' æˆ– ä½œè€… (å¹´ä»½) æ ‡é¢˜, æœŸåˆŠï¼‰
        const harvardPattern = s.match(
          /^([^(]+)\s*\((19|20)\d{2}\)\s+['''""]?([^''"",]+)/
        );
        if (harvardPattern && s.match(/pp\.\s*\d+/i)) {
          return parseHarvard(s, year, doi);
        }

        // 10. Chicago æ ¼å¼ï¼ˆç‰¹å¾ï¼šä½œè€…. "æ ‡é¢˜." æœŸåˆŠ å·, no. æœŸ (å¹´ä»½): é¡µç .ï¼‰
        const chicagoPattern = s.match(
          /^([^.]+)\.\s*[""]([^""]+)[""]\s*\.?\s*(.+)/
        );
        if (chicagoPattern) {
          const afterTitle = chicagoPattern[3];
          // Chicago æ ¼å¼çš„å…³é”®ç‰¹å¾ï¼šno. æœŸå· æˆ– (å¹´ä»½): é¡µç 
          if (
            afterTitle.match(/\bno\.\s*\d+/i) ||
            afterTitle.match(/\(\d{4}\)\s*:/)
          ) {
            return parseChicago(s, year, doi);
          }
        }

        // 11. MLA æ ¼å¼ï¼ˆç‰¹å¾ï¼šä½œè€…. "æ ‡é¢˜." æœŸåˆŠ, vol. X, no. Y, å¹´ä»½, pp. Z-W.ï¼‰
        const mlaPattern = s.match(
          /^([^.]+)\.\s*[""]([^""]+)[""]\s*\.?\s*(.+)/
        );
        if (mlaPattern) {
          const afterTitle = mlaPattern[3];
          // MLA æ ¼å¼çš„å…³é”®ç‰¹å¾ï¼švol. å’Œ pp. åŒæ—¶å‡ºç°ï¼Œä¸”ä¸æ˜¯ IEEE æ ¼å¼ï¼ˆæ—  [ ] ç¼–å·ï¼‰
          if (
            afterTitle.match(/\bvol\.\s*\d+/i) &&
            afterTitle.match(/\bpp\.\s*\d+/i) &&
            !s.match(/^\s*\[?\d+\]/)
          ) {
            return parseMLA(s, year, doi);
          }
        }

        // 12. é€šç”¨æ ¼å¼ï¼ˆå…œåº•ï¼‰
        return parseGeneric(s, year, doi);
      }

      // ========== BibTeX æ ¼å¼è§£æ ==========
      // ========== BibTeX æ ¼å¼è§£æï¼ˆä¼˜åŒ–ç‰ˆï¼‰ ==========
      // æ ‡å‡†æ ¼å¼ï¼š@type{citekey, field = {value}, ...}
      function parseBibTeX(s) {
        const result = {
          raw: s,
          year: null,
          doi: null,
          title: null,
          journal: null,
          volume: null,
          issue: null,
          firstPage: null,
          lastPage: null,
          authors: [],
        };

        // æå–ç±»å‹
        const typeMatch = s.match(/@(\w+)\s*\{/);
        if (typeMatch) result.type = typeMatch[1].toLowerCase();

        // æå–å„å­—æ®µ - ä½¿ç”¨æ›´ç²¾ç¡®çš„æ­£åˆ™è¡¨è¾¾å¼
        // BibTeX å­—æ®µæ ¼å¼ï¼šfield = {value} æˆ– field = "value" æˆ– field = value

        // æå– author
        const authorMatch = s.match(/\bauthor\s*=\s*[{"]([^}"]+)[}"]/i);
        if (authorMatch) {
          const authorStr = authorMatch[1].replace(/[{}]/g, "").trim();
          result.authors = authorStr
            .split(/\s+and\s+/i)
            .map((a) => {
              const trimmed = a.trim();
              // BibTeX ä½œè€…æ ¼å¼é€šå¸¸æ˜¯ "Lastname, Firstname" æˆ– "Firstname Lastname"
              if (trimmed.includes(",")) {
                return trimmed.split(",")[0].trim();
              } else {
                const parts = trimmed.split(/\s+/);
                return parts[parts.length - 1];
              }
            })
            .filter((a) => a && a.length > 0);
        }

        // æå– title
        const titleMatch = s.match(/\btitle\s*=\s*[{"]([^}"]+)[}"]/i);
        if (titleMatch) {
          result.title = titleMatch[1].replace(/[{}]/g, "").trim();
        }

        // æå– journal æˆ– booktitle
        const journalMatch = s.match(
          /\b(?:journal|booktitle)\s*=\s*[{"]([^}"]+)[}"]/i
        );
        if (journalMatch) {
          result.journal = journalMatch[1].replace(/[{}]/g, "").trim();
        }

        // æå– year
        const yearMatch = s.match(/\byear\s*=\s*[{"]?(\d{4})[}"']?/i);
        if (yearMatch) {
          result.year = parseInt(yearMatch[1], 10);
        }

        // æå– volume
        const volumeMatch = s.match(/\bvolume\s*=\s*[{"]?([^},"\s]+)[}"']?/i);
        if (volumeMatch) {
          result.volume = volumeMatch[1].replace(/[{}]/g, "").trim();
        }

        // æå– number (æœŸå·)
        const numberMatch = s.match(/\bnumber\s*=\s*[{"]?([^},"\s]+)[}"']?/i);
        if (numberMatch) {
          result.issue = numberMatch[1].replace(/[{}]/g, "").trim();
        }

        // æå– pages
        const pagesMatch = s.match(/\bpages\s*=\s*[{"]?([^}"',]+)[}"']?/i);
        if (pagesMatch) {
          const pageStr = pagesMatch[1].replace(/[{}]/g, "").trim();
          const pp = pageStr.match(/(\d+)\s*[-â€“â€”]+\s*(\d+)/);
          if (pp) {
            result.firstPage = pp[1];
            result.lastPage = pp[2];
          } else {
            const singlePage = pageStr.match(/(\d+)/);
            if (singlePage) {
              result.firstPage = singlePage[1];
            }
          }
        }

        // æå– doi
        const doiMatch = s.match(/\bdoi\s*=\s*[{"]?([^}"',\s]+)[}"']?/i);
        if (doiMatch) {
          result.doi = doiMatch[1].replace(/[{}]/g, "").trim();
        }

        // æå– eprint (arXiv ID)
        const eprintMatch = s.match(/\beprint\s*=\s*[{"]?([^}"',\s]+)[}"']?/i);
        if (eprintMatch) {
          result.arxivId = eprintMatch[1].replace(/[{}]/g, "").trim();
        }

        return result;
      }

      function parseChineseGBT7714(s, typeMatch, year, doi) {
        const result = {
          raw: s,
          year,
          doi,
          title: null,
          journal: null,
          volume: null,
          issue: null,
          firstPage: null,
          lastPage: null,
          authors: [],
        };

        const typeCode = typeMatch[1].toUpperCase();
        const typeIdx = s.indexOf(typeMatch[0]);
        const beforeType = s.slice(0, typeIdx).trim();
        const afterType = s.slice(typeIdx + typeMatch[0].length).trim();

        let authorPart = "";
        let titlePart = "";

        const chineseAuthorTitleMatch = beforeType.match(
          /^((?:[\u4e00-\u9fa5]{2,4}(?:[,ï¼Œã€]\s*)?)+(?:ç­‰|et\s*al\.?)?)\s*[.ï¼ã€‚]\s*(.+)$/
        );

        const englishAuthorTitleMatch = beforeType.match(
          /^((?:[A-Z][a-zA-Z'-]+(?:\s+[A-Z]\.?)*(?:[,ï¼Œ]\s*)?)+(?:et\s*al\.?)?)\s*[.ï¼ã€‚]\s*(.+)$/
        );

        // æ··åˆæ ¼å¼ï¼ˆä¸­è‹±æ–‡ä½œè€…æ··åˆï¼‰
        const mixedAuthorTitleMatch = beforeType.match(
          /^(.+?)\s*[.ï¼ã€‚]\s*([^.ï¼ã€‚]+)$/
        );

        if (chineseAuthorTitleMatch) {
          authorPart = chineseAuthorTitleMatch[1].trim();
          titlePart = chineseAuthorTitleMatch[2].trim();
        } else if (englishAuthorTitleMatch) {
          authorPart = englishAuthorTitleMatch[1].trim();
          titlePart = englishAuthorTitleMatch[2].trim();
        } else if (mixedAuthorTitleMatch) {
          // ä½¿ç”¨æ··åˆåŒ¹é…ä½œä¸ºåå¤‡
          authorPart = mixedAuthorTitleMatch[1].trim();
          titlePart = mixedAuthorTitleMatch[2].trim();
        } else {
          // æœ€åçš„å›é€€ï¼šæ•´ä¸ª beforeType ä½œä¸ºæ ‡é¢˜
          titlePart = beforeType;
        }

        result.title = titlePart;

        // è§£æä½œè€…åˆ—è¡¨
        if (authorPart) {
          const authorDelimiters = /[,ï¼Œ;ï¼›ã€]/;
          const rawAuthors = authorPart
            .split(authorDelimiters)
            .map((a) => a.trim())
            .filter(Boolean);

          result.authors = rawAuthors
            .map((a) => {
              // ç§»é™¤ "ç­‰" æˆ– "et al."
              a = a.replace(/ç­‰$|et\s*al\.?$/i, "").trim();
              // å¯¹äºè‹±æ–‡ä½œè€…ï¼Œæå–å§“æ°
              if (/^[A-Z]/.test(a)) {
                // å¦‚æœæ˜¯ "Lastname, Firstname" æ ¼å¼
                if (a.includes(",")) {
                  return a.split(",")[0].trim();
                }
                // å¦‚æœæ˜¯ "Firstname Lastname" æ ¼å¼ï¼Œå–æœ€åä¸€ä¸ªè¯
                const parts = a.split(/\s+/);
                return parts[parts.length - 1];
              }
              // ä¸­æ–‡ä½œè€…ç›´æ¥è¿”å›
              return a;
            })
            .filter((a) => a && a.length > 0);
        }

        // ===== è§£æç±»å‹æ ‡è®°åçš„å†…å®¹ =====
        // ç§»é™¤å¼€å¤´çš„ç‚¹å·å’Œæ–œæ 
        let restContent = afterType.replace(/^[.ï¼ã€‚/ï¼]\s*/, "").trim();

        if (typeCode === "J" || typeCode === "N") {
          // æœŸåˆŠ/æŠ¥çº¸æ ¼å¼ï¼šæœŸåˆŠå, å¹´, å·(æœŸ): èµ·å§‹é¡µ-ç»ˆæ­¢é¡µ.
          // æˆ–ï¼šæœŸåˆŠå, å¹´, å·(æœŸ): æ–‡ç« ç¼–å·.

          // æå–æœŸåˆŠåï¼ˆç¬¬ä¸€ä¸ªé€—å·å‰çš„å†…å®¹ï¼‰
          const journalMatch = restContent.match(/^([^,ï¼Œ]+)/);
          if (journalMatch) {
            result.journal = journalMatch[1].trim();
          }

          // æå–å·æœŸé¡µç 
          // æ ¼å¼1ï¼šå¹´, å·(æœŸ): é¡µç 
          const fullMatch = restContent.match(
            /(\d{4})\s*[,ï¼Œ]\s*(\d+)\s*\((\d+)\)\s*[ï¼š:]\s*(\d+)(?:\s*[-â€“â€”]\s*(\d+))?/
          );
          if (fullMatch) {
            result.year = parseInt(fullMatch[1], 10);
            result.volume = fullMatch[2];
            result.issue = fullMatch[3];
            result.firstPage = fullMatch[4];
            if (fullMatch[5]) result.lastPage = fullMatch[5];
          } else {
            // æ ¼å¼2ï¼šå·(æœŸ): é¡µç ï¼ˆæ— å¹´ä»½ï¼‰
            const viMatch = restContent.match(
              /(\d+)\s*\((\d+)\)\s*[ï¼š:]\s*(\d+)(?:\s*[-â€“â€”]\s*(\d+))?/
            );
            if (viMatch) {
              result.volume = viMatch[1];
              result.issue = viMatch[2];
              result.firstPage = viMatch[3];
              if (viMatch[4]) result.lastPage = viMatch[4];
            }
          }
        } else if (typeCode === "M") {
          // ä¸“è‘—æ ¼å¼ï¼šå‡ºç‰ˆåœ°: å‡ºç‰ˆç¤¾, å¹´.
          const publisherMatch = restContent.match(
            /([^:ï¼š]+)[ï¼š:]\s*([^,ï¼Œ]+)/
          );
          if (publisherMatch) {
            result.journal = publisherMatch[2].trim(); // ç”¨ journal å­—æ®µå­˜å‚¨å‡ºç‰ˆç¤¾
          }
        } else if (typeCode === "C") {
          // è®ºæ–‡é›†æ ¼å¼ï¼š//è®ºæ–‡é›†å. å‡ºç‰ˆåœ°: å‡ºç‰ˆç¤¾, å¹´: é¡µç .
          const procMatch = restContent.match(/^\/?\/?([^.ï¼ã€‚]+)/);
          if (procMatch) {
            result.journal = procMatch[1].trim();
          }
        } else if (typeCode === "D") {
          // å­¦ä½è®ºæ–‡æ ¼å¼ï¼šä¿å­˜åœ°: ä¿å­˜å•ä½, å¹´.
          const schoolMatch = restContent.match(/([^:ï¼š]+)[ï¼š:]\s*([^,ï¼Œ]+)/);
          if (schoolMatch) {
            result.journal = schoolMatch[2].trim();
          }
        }

        // å¦‚æœä¸Šé¢æ²¡æœ‰è§£æå‡ºé¡µç ï¼Œå°è¯•é€šç”¨é¡µç åŒ¹é…
        if (!result.firstPage) {
          const pageMatch = s.match(/[ï¼š:]\s*(\d+)\s*[-â€“â€”]\s*(\d+)/);
          if (pageMatch) {
            result.firstPage = pageMatch[1];
            result.lastPage = pageMatch[2];
          }
        }

        return result;
      }

      // ========== IEEE æ ¼å¼è§£æï¼ˆä¼˜åŒ–ç‰ˆï¼‰ ==========
      // æ ‡å‡†æ ¼å¼ï¼š[1] A. Author, B. Author, and C. Author, "Article title," Journal Name, vol. X, no. Y, pp. Z-W, Month Year.
      // æˆ–æ— ç¼–å·ï¼šA. Author, "Article title," Journal Name, vol. X, pp. Z-W, Year.
      function parseIEEE(s, year, doi) {
        const result = {
          raw: s,
          year,
          doi,
          title: null,
          journal: null,
          volume: null,
          issue: null,
          firstPage: null,
          lastPage: null,
          authors: [],
        };

        // ç§»é™¤å¼€å¤´çš„ç¼–å· [1] æˆ– 1. æˆ– 1)
        let str = s.replace(/^\s*\[?\d+[\].)]\s*/, "").trim();

        // ===== æå–æ ‡é¢˜ï¼ˆåœ¨å¼•å·å†…ï¼‰ =====
        // IEEE æ ¼å¼çš„æ ‡é¢˜ç”¨è‹±æ–‡å¼•å·åŒ…è£¹
        const titleMatch = str.match(/[""]([^""]+)[""]/);
        if (titleMatch) {
          result.title = titleMatch[1].trim().replace(/,\s*$/, "");
        }

        // ===== æå–ä½œè€…ï¼ˆåœ¨æ ‡é¢˜ä¹‹å‰ï¼‰ =====
        if (titleMatch) {
          const authorPart = str.slice(0, str.indexOf(titleMatch[0])).trim();
          // ç§»é™¤æœ«å°¾çš„é€—å·
          const cleanAuthorPart = authorPart.replace(/,\s*$/, "").trim();

          if (cleanAuthorPart) {
            // IEEE ä½œè€…æ ¼å¼ï¼šA. B. Author, C. D. Author, and E. F. Author
            // å…ˆæŒ‰ ", and " æˆ– " and " åˆ†å‰²
            const authorGroups = cleanAuthorPart.split(/,?\s+and\s+/i);

            for (const group of authorGroups) {
              // å†æŒ‰é€—å·åˆ†å‰²ï¼ˆæ³¨æ„ï¼šåå­—ç¼©å†™åä¹Ÿæœ‰ç‚¹å’Œç©ºæ ¼ï¼Œä¸è¦åœ¨é‚£é‡Œåˆ†å‰²ï¼‰
              // ç­–ç•¥ï¼šæŒ‰ ", " åè·Ÿå¤§å†™å­—æ¯çš„æ¨¡å¼åˆ†å‰²
              const authors = group.split(/,\s+(?=[A-Z])/);

              for (const author of authors) {
                const trimmed = author.trim();
                if (!trimmed) continue;

                // æå–å§“æ°ï¼ˆæœ€åä¸€ä¸ªå¤§å†™å¼€å¤´çš„è¯ï¼‰
                // IEEE æ ¼å¼é€šå¸¸æ˜¯ "A. B. Lastname" æˆ– "First M. Lastname"
                const parts = trimmed.split(/\s+/);
                // æ‰¾åˆ°æœ€åä¸€ä¸ªä¸æ˜¯ç¼©å†™ï¼ˆä¸ä»¥ç‚¹ç»“å°¾ï¼‰çš„è¯ä½œä¸ºå§“æ°
                for (let i = parts.length - 1; i >= 0; i--) {
                  const part = parts[i];
                  if (part && !part.match(/^[A-Z]\.$/) && part.length > 1) {
                    result.authors.push(part.replace(/,$/, ""));
                    break;
                  }
                }
              }
            }
          }
        }

        // ===== æå–æœŸåˆŠåï¼ˆåœ¨æ ‡é¢˜åã€vol. å‰ï¼‰ =====
        if (titleMatch) {
          const afterTitle = str.slice(
            str.indexOf(titleMatch[0]) + titleMatch[0].length
          );
          // æœŸåˆŠååœ¨ç¬¬ä¸€ä¸ªé€—å·åï¼Œvol. ä¹‹å‰
          // æ ¼å¼ï¼š," Journal Name, vol. X
          const journalMatch = afterTitle.match(
            /,?\s*[""]?\s*([^,]+?)\s*,\s*vol\./i
          );
          if (journalMatch) {
            result.journal = journalMatch[1]
              .trim()
              .replace(/^,\s*/, "")
              .replace(/^\s*in\s+/i, "");
          } else {
            // å¦‚æœæ²¡æœ‰ vol.ï¼Œå°è¯•å…¶ä»–æ¨¡å¼
            const simpleJournalMatch = afterTitle.match(
              /,?\s*([A-Z][^,]+?)\s*,\s*(?:pp\.|no\.|\d{4})/i
            );
            if (simpleJournalMatch) {
              result.journal = simpleJournalMatch[1].trim();
            }
          }
        }

        // ===== æå–å·å· =====
        const volMatch = s.match(/\bvol\.\s*(\d+)/i);
        if (volMatch) result.volume = volMatch[1];

        // ===== æå–æœŸå· =====
        const noMatch = s.match(/\bno\.\s*(\d+)/i);
        if (noMatch) result.issue = noMatch[1];

        // ===== æå–é¡µç  =====
        const ppMatch = s.match(/\bpp\.\s*(\d+)\s*[-â€“â€”]\s*(\d+)/i);
        if (ppMatch) {
          result.firstPage = ppMatch[1];
          result.lastPage = ppMatch[2];
        } else {
          // å•é¡µæƒ…å†µ
          const singlePpMatch = s.match(
            /\bpp?\.\s*(\d+)(?:\s*[-â€“â€”]\s*(\d+))?/i
          );
          if (singlePpMatch) {
            result.firstPage = singlePpMatch[1];
            if (singlePpMatch[2]) result.lastPage = singlePpMatch[2];
          }
        }

        return result;
      }

      // ========== Vancouver/NLM æ ¼å¼è§£æï¼ˆä¼˜åŒ–ç‰ˆï¼‰ ==========
      // æ ‡å‡†æ ¼å¼ï¼šAuthor AA, Author BB. Article title. Journal Abbrev. Year;Vol(Issue):Pages.
      // ç¤ºä¾‹ï¼šSmith JA, Jones BC. Article title here. N Engl J Med. 2023;389(15):1400-1410.
      function parseVancouver(s, year, doi) {
        const result = {
          raw: s,
          year,
          doi,
          title: null,
          journal: null,
          volume: null,
          issue: null,
          firstPage: null,
          lastPage: null,
          authors: [],
        };

        // Vancouver æ ¼å¼ç”¨ç‚¹å·åˆ†éš”ä¸»è¦éƒ¨åˆ†
        const parts = s.split(/\.\s+/);

        if (parts.length >= 3) {
          // ç¬¬ä¸€éƒ¨åˆ†æ˜¯ä½œè€…
          const authorPart = parts[0];
          // Vancouver ä½œè€…æ ¼å¼ï¼šLastname AB, Lastname CD
          const authorMatches = authorPart.match(
            /([A-Z][a-z]+)\s+[A-Z]{1,3}(?:,|$)/g
          );
          if (authorMatches) {
            result.authors = authorMatches.map(
              (a) => a.match(/([A-Z][a-z]+)/)[1]
            );
          } else {
            // å›é€€ï¼šæŒ‰é€—å·åˆ†å‰²
            result.authors = authorPart
              .split(/,\s*/)
              .map((a) => a.trim().split(/\s+/)[0])
              .filter((a) => a && a.length > 1);
          }

          // ç¬¬äºŒéƒ¨åˆ†æ˜¯æ ‡é¢˜
          result.title = parts[1].trim();

          // ç¬¬ä¸‰éƒ¨åˆ†å¼€å§‹æ˜¯æœŸåˆŠå’Œå…ƒæ•°æ®
          const journalPart = parts.slice(2).join(". ");

          // æœŸåˆŠåæ˜¯å¹´ä»½åˆ†å·å‰çš„å†…å®¹
          const journalMatch = journalPart.match(
            /^([^.;]+?)(?:\.\s*)?\d{4}\s*;/
          );
          if (journalMatch) {
            result.journal = journalMatch[1].trim();
          } else {
            // ç®€å•åŒ¹é…ï¼šç¬¬ä¸€ä¸ªéƒ¨åˆ†
            const simpleMatch = journalPart.match(/^([A-Za-z][A-Za-z\s]+)/);
            if (simpleMatch) {
              result.journal = simpleMatch[1].trim();
            }
          }
        }

        // è§£æå·æœŸé¡µç ï¼šYear;Vol(Issue):Pages
        const metaPatterns = [
          // å®Œæ•´æ ¼å¼ï¼š2023;389(15):1400-1410
          /(\d{4})\s*;\s*(\d+)\s*\((\d+)\)\s*:\s*(\d+)\s*[-â€“â€”]\s*(\d+)/,
          // æ— æœŸå·ï¼š2023;389:1400-1410
          /(\d{4})\s*;\s*(\d+)\s*:\s*(\d+)\s*[-â€“â€”]\s*(\d+)/,
          // åªæœ‰å·å’Œèµ·å§‹é¡µï¼š2023;389:1400
          /(\d{4})\s*;\s*(\d+)\s*:\s*(\d+)/,
        ];

        for (const pattern of metaPatterns) {
          const match = s.match(pattern);
          if (match) {
            result.year = parseInt(match[1], 10);
            result.volume = match[2];
            if (pattern.source.includes("\\(")) {
              // æœ‰æœŸå·çš„æ¨¡å¼
              result.issue = match[3];
              result.firstPage = match[4];
              if (match[5]) result.lastPage = match[5];
            } else {
              // æ— æœŸå·çš„æ¨¡å¼
              result.firstPage = match[3];
              if (match[4]) result.lastPage = match[4];
            }
            break;
          }
        }

        return result;
      }

      // ========== APA æ ¼å¼è§£æï¼ˆä¼˜åŒ–ç‰ˆï¼‰ ==========
      // APA 7th æ ¼å¼ï¼šAuthor, A. A., Author, B. B., & Author, C. C. (Year). Title of article. Journal Name, Vol(Issue), Pages. https://doi.org/xxx
      // ç¤ºä¾‹ï¼šSmith, J. A., & Jones, B. C. (2023). Article title here. Journal of Science, 45(3), 123-145.
      function parseAPA(s, year, doi) {
        const result = {
          raw: s,
          year,
          doi,
          title: null,
          journal: null,
          volume: null,
          issue: null,
          firstPage: null,
          lastPage: null,
          authors: [],
        };

        // APA æ ¼å¼ï¼šä½œè€… (å¹´ä»½). æ ‡é¢˜. æœŸåˆŠ, å·(æœŸ), é¡µç .
        const mainMatch = s.match(
          /^(.+?)\s*\((19|20)\d{2}[a-z]?\)\s*\.\s*(.+)/
        );
        if (!mainMatch) return result;

        // ===== è§£æä½œè€… =====
        const authorPart = mainMatch[1].trim();
        // APA ä½œè€…æ ¼å¼ï¼šLastname, F. M., Lastname, F. M., & Lastname, F. M.
        // æŒ‰ ", & " æˆ– " & " åˆ†å‰²å¤šä¸ªä½œè€…
        const authorGroups = authorPart.split(/,?\s*&\s*/);

        for (const group of authorGroups) {
          // æ¯ä¸ªä½œè€…å¯èƒ½æ˜¯ "Lastname, F. M." æ ¼å¼
          // éœ€è¦æå–å§“æ°ï¼ˆç¬¬ä¸€ä¸ªé€—å·å‰çš„å†…å®¹ï¼‰
          const trimmed = group.trim();
          if (!trimmed) continue;

          // æ£€æŸ¥æ˜¯å¦æ˜¯ "Lastname, F. M." æ ¼å¼
          const lastFirstMatch = trimmed.match(/^([A-Z][a-zA-Z'-]+)\s*,/);
          if (lastFirstMatch) {
            result.authors.push(lastFirstMatch[1]);
          } else {
            // å¯èƒ½åªæ˜¯ä¸€ä¸ªå§“æ°ï¼ˆå¦‚ "et al." å‰çš„æœ€åä¸€ä¸ªä½œè€…ï¼‰
            const simpleMatch = trimmed.match(/^([A-Z][a-zA-Z'-]+)/);
            if (simpleMatch && simpleMatch[1].length > 1) {
              result.authors.push(simpleMatch[1]);
            }
          }
        }

        // ===== è§£ææ ‡é¢˜å’ŒæœŸåˆŠ =====
        const afterYear = mainMatch[3];
        // ç”¨ç‚¹å·åˆ†å‰²ï¼Œç¬¬ä¸€éƒ¨åˆ†æ˜¯æ ‡é¢˜ï¼Œç¬¬äºŒéƒ¨åˆ†å¼€å§‹æ˜¯æœŸåˆŠä¿¡æ¯
        const dotParts = afterYear.split(/\.\s+/);

        if (dotParts.length >= 1) {
          result.title = dotParts[0].trim();
        }

        if (dotParts.length >= 2) {
          // æœŸåˆŠéƒ¨åˆ†ï¼šJournal Name, Vol(Issue), Pages.
          const journalPart = dotParts.slice(1).join(". ");

          // æå–æœŸåˆŠåï¼ˆç¬¬ä¸€ä¸ªé€—å·å‰çš„å†…å®¹ï¼Œä½†è¦æ’é™¤æœ«å°¾çš„å·æœŸä¿¡æ¯ï¼‰
          const journalMatch = journalPart.match(/^([^,]+?)(?:\s*,\s*\d|$)/);
          if (journalMatch) {
            result.journal = journalMatch[1].trim();
          }

          // æå–å·æœŸï¼šVol(Issue)
          const viMatch = journalPart.match(/,\s*(\d+)\s*\((\d+)\)/);
          if (viMatch) {
            result.volume = viMatch[1];
            result.issue = viMatch[2];
          } else {
            // åªæœ‰å·å·
            const volOnly = journalPart.match(/,\s*(\d+)\s*,/);
            if (volOnly) result.volume = volOnly[1];
          }

          // æå–é¡µç 
          const pageMatch = journalPart.match(/,\s*(\d+)\s*[-â€“â€”]\s*(\d+)/);
          if (pageMatch) {
            result.firstPage = pageMatch[1];
            result.lastPage = pageMatch[2];
          }
        }

        return result;
      }

      // ========== Chicago æ ¼å¼è§£æï¼ˆä¼˜åŒ–ç‰ˆï¼‰ ==========
      // Chicago 17th (Notes-Bibliography) æ ¼å¼ï¼š
      // Author. "Title." Journal Name Vol, no. Issue (Year): Pages.
      // ç¤ºä¾‹ï¼šSmith, John. "Article Title Here." Journal of Science 45, no. 3 (2023): 100-150.
      function parseChicago(s, year, doi) {
        const result = {
          raw: s,
          year,
          doi,
          title: null,
          journal: null,
          volume: null,
          issue: null,
          firstPage: null,
          lastPage: null,
          authors: [],
        };

        // ===== è§£æä½œè€… =====
        // Chicago æ ¼å¼ä½œè€…åœ¨ç¬¬ä¸€ä¸ªç‚¹å·å‰
        const firstDotMatch = s.match(/^([^.]+)\./);
        if (firstDotMatch) {
          const authorPart = firstDotMatch[1];
          // Chicago ä½œè€…æ ¼å¼ï¼šLastname, Firstname, and Firstname Lastname
          // æˆ–ç®€å•çš„ï¼šLastname, Firstname
          const authorGroups = authorPart.split(/,?\s+and\s+/i);

          for (const group of authorGroups) {
            const trimmed = group.trim();
            if (!trimmed) continue;

            // æå–å§“æ°
            const commaMatch = trimmed.match(/^([A-Z][a-zA-Z'-]+)\s*,/);
            if (commaMatch) {
              result.authors.push(commaMatch[1]);
            } else {
              // å¯èƒ½æ˜¯ "Firstname Lastname" æ ¼å¼
              const parts = trimmed.split(/\s+/);
              if (parts.length >= 2) {
                result.authors.push(parts[parts.length - 1]);
              } else if (parts.length === 1 && parts[0].length > 1) {
                result.authors.push(parts[0]);
              }
            }
          }
        }

        // ===== è§£ææ ‡é¢˜ï¼ˆåœ¨å¼•å·å†…ï¼‰ =====
        const titleMatch = s.match(/[""]([^""]+)[""]/);
        if (titleMatch) {
          result.title = titleMatch[1].trim().replace(/\.$/, "");
        }

        // ===== è§£ææœŸåˆŠå’Œå…ƒæ•°æ® =====
        if (titleMatch) {
          const afterTitle = s.slice(
            s.indexOf(titleMatch[0]) + titleMatch[0].length
          );

          // Chicago æœŸåˆŠæ ¼å¼ï¼šJournal Name Vol, no. Issue (Year): Pages.
          const journalMatch = afterTitle.match(
            /^\s*\.?\s*([A-Z][^0-9,]+?)\s+(\d+)\s*,\s*no\.\s*(\d+)\s*\((\d{4})\)\s*:\s*(\d+)(?:\s*[-â€“â€”]\s*(\d+))?/i
          );

          if (journalMatch) {
            result.journal = journalMatch[1].trim();
            result.volume = journalMatch[2];
            result.issue = journalMatch[3];
            result.year = parseInt(journalMatch[4], 10);
            result.firstPage = journalMatch[5];
            if (journalMatch[6]) result.lastPage = journalMatch[6];
          } else {
            // ç®€åŒ–åŒ¹é…ï¼šåªæœ‰æœŸåˆŠåå’Œå·å·
            const simpleMatch = afterTitle.match(
              /^\s*\.?\s*([A-Z][^0-9,]+?)\s+(\d+)/
            );
            if (simpleMatch) {
              result.journal = simpleMatch[1].trim();
              result.volume = simpleMatch[2];
            }

            // å•ç‹¬åŒ¹é…æœŸå·
            const noMatch = afterTitle.match(/no\.\s*(\d+)/i);
            if (noMatch) result.issue = noMatch[1];

            // å•ç‹¬åŒ¹é…é¡µç 
            const pageMatch = afterTitle.match(/:\s*(\d+)\s*[-â€“â€”]\s*(\d+)/);
            if (pageMatch) {
              result.firstPage = pageMatch[1];
              result.lastPage = pageMatch[2];
            }
          }
        }

        return result;
      }

      // ========== Harvard æ ¼å¼è§£æï¼ˆä¼˜åŒ–ç‰ˆï¼‰ ==========
      // Harvard æ ¼å¼ï¼šAuthor (Year) 'Title', Journal, Vol(Issue), pp. Pages.
      // æˆ–ï¼šAuthor (Year) Title, Journal, Vol(Issue), pp. Pages.
      // ç¤ºä¾‹ï¼šSmith, J. (2023) 'Article title here', Journal of Science, 45(3), pp. 100-150.
      function parseHarvard(s, year, doi) {
        const result = {
          raw: s,
          year,
          doi,
          title: null,
          journal: null,
          volume: null,
          issue: null,
          firstPage: null,
          lastPage: null,
          authors: [],
        };

        // Harvard æ ¼å¼ï¼šä½œè€… (å¹´ä»½) æ ‡é¢˜, æœŸåˆŠ, å·(æœŸ), pp. é¡µç 
        const mainMatch = s.match(/^(.+?)\s*\((19|20)\d{2}\)\s*(.+)/);
        if (!mainMatch) return result;

        // ===== è§£æä½œè€… =====
        const authorPart = mainMatch[1].trim();
        // Harvard ä½œè€…æ ¼å¼ï¼šSmith, J., Jones, A. and Lee, C.
        const authorGroups = authorPart.split(/,?\s+and\s+/i);

        for (const group of authorGroups) {
          const trimmed = group.trim();
          if (!trimmed) continue;

          // å¯èƒ½åŒ…å«å¤šä¸ªä½œè€…ç”¨é€—å·åˆ†éš”
          // ä½†è¦æ³¨æ„ "Smith, J." ä¸­çš„é€—å·ä¸æ˜¯åˆ†éš”ç¬¦
          const commaMatch = trimmed.match(/^([A-Z][a-zA-Z'-]+)\s*,/);
          if (commaMatch) {
            result.authors.push(commaMatch[1]);
          }
        }

        // ===== è§£ææ ‡é¢˜å’ŒæœŸåˆŠ =====
        const afterYear = mainMatch[3];

        // æå–æ ‡é¢˜ï¼ˆå¯èƒ½åœ¨å¼•å·å†…ï¼Œä¹Ÿå¯èƒ½ä¸åœ¨ï¼‰
        const quotedTitle = afterYear.match(
          /^[''']([^''']+)[''']|^[""]([^""]+)[""]/
        );
        if (quotedTitle) {
          result.title = (quotedTitle[1] || quotedTitle[2]).trim();

          // æœŸåˆŠåœ¨æ ‡é¢˜å
          const afterTitle = afterYear.slice(
            afterYear.indexOf(quotedTitle[0]) + quotedTitle[0].length
          );
          const journalMatch = afterTitle.match(/,\s*([^,]+?)\s*,\s*\d/);
          if (journalMatch) {
            result.journal = journalMatch[1].trim();
          }
        } else {
          // æ²¡æœ‰å¼•å·ï¼Œç”¨é€—å·åˆ†å‰²
          const parts = afterYear.split(/,\s*/);
          if (parts.length >= 2) {
            result.title = parts[0].trim();
            result.journal = parts[1].trim();
          }
        }

        // ===== è§£æå·æœŸ =====
        const viMatch = afterYear.match(/(\d+)\s*\((\d+)\)/);
        if (viMatch) {
          result.volume = viMatch[1];
          result.issue = viMatch[2];
        }

        // ===== è§£æé¡µç  =====
        const ppMatch = afterYear.match(/pp\.?\s*(\d+)\s*[-â€“â€”]\s*(\d+)/i);
        if (ppMatch) {
          result.firstPage = ppMatch[1];
          result.lastPage = ppMatch[2];
        }

        return result;
      }


      function parseMLA(s, year, doi) {
        const result = {
          raw: s,
          year,
          doi,
          title: null,
          journal: null,
          volume: null,
          issue: null,
          firstPage: null,
          lastPage: null,
          authors: [],
        };

        // ===== è§£æä½œè€… =====
        // MLA ä½œè€…åœ¨ç¬¬ä¸€ä¸ªç‚¹å·å‰
        const authorMatch = s.match(/^([^.]+)\./);
        if (authorMatch) {
          const authorPart = authorMatch[1];
          const authorGroups = authorPart.split(/,?\s+and\s+/i);

          for (const group of authorGroups) {
            const trimmed = group.trim();
            if (!trimmed) continue;

            // MLA ç¬¬ä¸€ä½œè€…æ ¼å¼ï¼šLastname, Firstname
            // åç»­ä½œè€…æ ¼å¼ï¼šFirstname Lastname
            const commaMatch = trimmed.match(/^([A-Z][a-zA-Z'-]+)\s*,/);
            if (commaMatch) {
              result.authors.push(commaMatch[1]);
            } else {
              const parts = trimmed.split(/\s+/);
              if (parts.length >= 2) {
                result.authors.push(parts[parts.length - 1]);
              }
            }
          }
        }

        // ===== è§£ææ ‡é¢˜ =====
        const titleMatch = s.match(/[""]([^""]+)[""]/);
        if (titleMatch) {
          result.title = titleMatch[1].trim().replace(/\.$/, "");
        }

        // ===== è§£ææœŸåˆŠå’Œå…ƒæ•°æ® =====
        if (titleMatch) {
          const afterTitle = s.slice(
            s.indexOf(titleMatch[0]) + titleMatch[0].length
          );

          // æœŸåˆŠååœ¨å¼•å·åï¼Œvol. ä¹‹å‰
          const journalMatch = afterTitle.match(
            /^\s*\.?\s*([^,]+?)\s*,\s*vol\./i
          );
          if (journalMatch) {
            result.journal = journalMatch[1].trim();
          }
        }

        // ===== è§£æå·æœŸ =====
        const volMatch = s.match(/\bvol\.\s*(\d+)/i);
        if (volMatch) result.volume = volMatch[1];

        const noMatch = s.match(/\bno\.\s*(\d+)/i);
        if (noMatch) result.issue = noMatch[1];

        // ===== è§£æé¡µç  =====
        const ppMatch = s.match(/\bpp\.\s*(\d+)\s*[-â€“â€”]\s*(\d+)/i);
        if (ppMatch) {
          result.firstPage = ppMatch[1];
          result.lastPage = ppMatch[2];
        }

        return result;
      }

      // ========== arXiv/é¢„å°æœ¬/æŠ€æœ¯æŠ¥å‘Šæ ¼å¼è§£æï¼ˆä¼˜åŒ–ç‰ˆï¼‰ ==========
      // å¸¸è§æ ¼å¼ï¼š
      // - Author, A., Author, B., et al. Title. arXiv:2401.12345.
      // - Author, A. (2024). Title. arXiv preprint arXiv:2401.12345.
      // - Wang, A., Chen, H., et al. YOLOv10: ... arXiv:2405.14458.
      function parseArxivTechReport(s, year, doi) {
        const result = {
          raw: s,
          year,
          doi,
          title: null,
          journal: null,
          volume: null,
          issue: null,
          firstPage: null,
          lastPage: null,
          authors: [],
          arxivId: null,
        };

        // æå– arXiv ID
        const arxivPatterns = [
          /arXiv\s*[:\s]\s*(\d{4}\.\d{4,5})/i,
          /arXiv\s*preprint\s*arXiv[:\s]*(\d{4}\.\d{4,5})/i,
          /abs\/(\d{4}\.\d{4,5})/i,
          /(\d{4}\.\d{4,5})/, // çº¯æ•°å­—æ ¼å¼ä½œä¸ºæœ€åæ‰‹æ®µ
        ];

        for (const pattern of arxivPatterns) {
          const match = s.match(pattern);
          if (match) {
            result.arxivId = match[1];
            break;
          }
        }

        if (result.arxivId) {
          result.journal = "arXiv preprint";
        }

        // ===== è§£æç»“æ„ =====
        // ç§»é™¤ arXiv ä¿¡æ¯åçš„å†…å®¹
        let str = s
          .replace(/arXiv\s*[:\s]*\d{4}\.\d{4,5}[v\d]*/gi, "")
          .replace(/abs\/\d{4}\.\d{4,5}/gi, "")
          .trim();

        // ç”¨ç‚¹å·åˆ†å‰²
        const parts = str.split(/\.\s+/).filter((p) => p.trim());

        if (parts.length >= 2) {
          // ===== è§£æä½œè€… =====
          let authorPart = parts[0];

          // æ£€æŸ¥æ˜¯å¦æœ‰ "et al."
          const etAlIdx = authorPart.toLowerCase().indexOf("et al");
          if (etAlIdx !== -1) {
            authorPart = authorPart.slice(0, etAlIdx).trim();
          }

          // è§£æä½œè€…åˆ—è¡¨
          // æ ¼å¼å¯èƒ½æ˜¯ï¼šAuthor, A., Author, B. æˆ– Author A, Author B
          const authorMatches = authorPart.match(
            /([A-Z][a-zA-Z'-]+)\s*,?\s*[A-Z]\.?/g
          );
          if (authorMatches) {
            result.authors = authorMatches
              .map((m) => {
                const match = m.match(/([A-Z][a-zA-Z'-]+)/);
                return match ? match[1] : null;
              })
              .filter(Boolean);
          }

          // å¦‚æœä¸Šé¢æ²¡è§£æå‡ºæ¥ï¼Œå°è¯•ç®€å•åˆ†å‰²
          if (result.authors.length === 0) {
            result.authors = authorPart
              .split(/[,;]/)
              .map((a) => a.trim().split(/\s+/)[0])
              .filter((a) => a && a.length > 1 && /^[A-Z]/.test(a));
          }

          // ===== è§£ææ ‡é¢˜ =====
          // æ ‡é¢˜é€šå¸¸æ˜¯ç¬¬äºŒéƒ¨åˆ†
          if (parts[1] && parts[1].length > 10) {
            result.title = parts[1].trim();
          } else if (parts.length > 2) {
            // å¯èƒ½ç¬¬ä¸€éƒ¨åˆ†åªæœ‰ä½œè€…ï¼Œæ ‡é¢˜åœ¨åé¢
            for (let i = 1; i < parts.length; i++) {
              if (
                parts[i].length > 20 &&
                !parts[i].match(/university|institute|arxiv/i)
              ) {
                result.title = parts[i].trim();
                break;
              }
            }
          }

          // ===== æ£€æŸ¥æ˜¯å¦æœ‰æœºæ„ä¿¡æ¯ =====
          const institutionKeywords =
            /University|Institute|Lab|Center|Centre|Research|College|School|Academy/i;
          for (const part of parts) {
            if (institutionKeywords.test(part) && !result.journal) {
              // å¦‚æœæ²¡æœ‰ arXiv IDï¼Œç”¨æœºæ„åä½œä¸º journal
              if (!result.arxivId) {
                result.journal = part.trim();
              }
              break;
            }
          }
        }

        // æå–é¡µç ï¼ˆå¦‚æœæœ‰ï¼‰
        const pageMatch = s.match(/\((\d+)\s*[-â€“â€”]\s*(\d+)\)/);
        if (pageMatch) {
          result.firstPage = pageMatch[1];
          result.lastPage = pageMatch[2];
        }

        return result;
      }

      // ========== MDPI/å¼€æ”¾è·å–æœŸåˆŠæ ¼å¼è§£æï¼ˆä¼˜åŒ–ç‰ˆï¼‰ ==========
      // æ ¼å¼ï¼šAuthor, A.; Author, B. Title. *Journal*. Year, Vol(Issue), ArticleNumber.
      function parseMDPI(s, year, doi) {
        const result = {
          raw: s,
          year,
          doi,
          title: null,
          journal: null,
          volume: null,
          issue: null,
          firstPage: null,
          lastPage: null,
          authors: [],
          articleNumber: null,
        };

        // æå–æœŸåˆŠåï¼ˆæ˜Ÿå·åŒ…è£¹ï¼‰
        const journalMatch = s.match(/\*([^*]+)\*/);
        if (journalMatch) {
          result.journal = journalMatch[1].trim();
        }

        // æå–å¹´ä»½ã€å·ã€æœŸ
        const metaPatterns = [
          /\*[^*]+\*\s*[.,]?\s*(\d{4})\s*[.,]?\s*(\d+)\s*\((\d+)\)/, // *Journal*. 2023, 11(6)
          /(\d{4})\s*[.,]\s*(\d+)\s*\((\d+)\)/, // 2023, 11(6)
        ];

        for (const pattern of metaPatterns) {
          const match = s.match(pattern);
          if (match) {
            result.year = parseInt(match[1], 10);
            result.volume = match[2];
            result.issue = match[3];
            break;
          }
        }

        // æå–æ–‡ç« ç¼–å·
        const articleNumPatterns = [
          /\)\s*[.,]?\s*(\d+)\s*[.,]?\s*$/, // æœ«å°¾çš„æ–‡ç« å·
          /[.,]\s*(\d+)\s*[.,]?\s*https?:/, // DOI å‰çš„æ–‡ç« å·
        ];

        for (const pattern of articleNumPatterns) {
          const match = s.match(pattern);
          if (match) {
            result.articleNumber = match[1];
            result.firstPage = match[1];
            break;
          }
        }

        // ===== è§£æä½œè€…å’Œæ ‡é¢˜ =====
        if (journalMatch) {
          const beforeJournal = s.slice(0, s.indexOf(journalMatch[0])).trim();

          // ç”¨ç‚¹å·åˆ†å‰²
          const parts = beforeJournal.split(/\.\s+/);

          if (parts.length >= 2) {
            // ç¬¬ä¸€éƒ¨åˆ†æ˜¯ä½œè€…
            result.authors = parseAuthorString(parts[0]);
            // å…¶ä½™éƒ¨åˆ†æ˜¯æ ‡é¢˜
            result.title = parts.slice(1).join(". ").replace(/\.$/, "").trim();
          } else {
            // å°è¯•å…¶ä»–åˆ†éš”æ–¹å¼
            // MDPI æ ¼å¼ä½œè€…é€šå¸¸ç”¨åˆ†å·åˆ†éš”
            const semiMatch = beforeJournal.match(/^(.+?[A-Z]\.)\s+(.+)$/);
            if (semiMatch) {
              result.authors = parseAuthorString(semiMatch[1]);
              result.title = semiMatch[2].replace(/\.$/, "").trim();
            } else {
              result.title = beforeJournal.replace(/\.$/, "").trim();
            }
          }
        }

        return result;
      }

      // è¾…åŠ©å‡½æ•°ï¼šè§£æä½œè€…å­—ç¬¦ä¸²
      function parseAuthorString(authorStr) {
        // å¤„ç†å¤šç§ä½œè€…æ ¼å¼ï¼š
        // "Asante,A., B. K., Imamura, H."
        // "Smith, J., Jones, A."
        // "Wang,A., Chen,H., Liu,L."

        const authors = [];

        // é¦–å…ˆæŒ‰åˆ†å·åˆ†å‰²ï¼ˆå¦‚æœæœ‰çš„è¯ï¼‰
        const semiParts = authorStr.split(/;\s*/);

        for (const part of semiParts) {
          // å°è¯•åŒ¹é… "å§“,åç¼©å†™" æˆ– "å§“, åç¼©å†™" æ ¼å¼
          // æ­£åˆ™ï¼šåŒ¹é…ä»¥å¤§å†™å­—æ¯å¼€å¤´çš„å§“æ°ï¼Œåé¢å¯èƒ½è·Ÿç€é€—å·å’Œåå­—ç¼©å†™
          const namePattern =
            /([A-Z][a-zA-Z'-]+)\s*,\s*([A-Z]\.?(?:\s*[A-Z]\.?)*)/g;
          let match;
          const foundNames = [];

          while ((match = namePattern.exec(part)) !== null) {
            foundNames.push(match[1]); // åªå–å§“æ°
          }

          if (foundNames.length > 0) {
            authors.push(...foundNames);
          } else {
            // å›é€€æ–¹æ¡ˆï¼šæŒ‰é€—å·åˆ†å‰²ï¼Œå–æ¯ä¸ªçœ‹èµ·æ¥åƒå§“çš„è¯
            const commaParts = part.split(/,\s*/);
            for (const cp of commaParts) {
              const trimmed = cp.trim();
              // å¦‚æœæ˜¯å•ä¸ªå¤§å†™å­—æ¯ï¼ˆåç¼©å†™ï¼‰ï¼Œè·³è¿‡
              if (/^[A-Z]\.?$/.test(trimmed)) continue;
              // å¦‚æœçœ‹èµ·æ¥åƒå§“æ°ï¼ˆé¦–å­—æ¯å¤§å†™ï¼Œåé¢æ˜¯å°å†™ï¼‰
              if (/^[A-Z][a-z]+/.test(trimmed)) {
                authors.push(trimmed.split(/\s+/)[0]);
              }
            }
          }
        }

        return authors.filter(Boolean);
      }

      // ========== Nature/Science æ ¼å¼è§£æï¼ˆä¼˜åŒ–ç‰ˆï¼‰ ==========
      // æ ‡å‡†æ ¼å¼ï¼šAuthor, A. et al. Title. Journal Vol, Pages (Year).
      // ç¤ºä¾‹ï¼šSmith, J. et al. Discovery of X. Nature 600, 100-110 (2023).
      // ç¤ºä¾‹ï¼šJones, A., Smith, B. & Lee, C. New findings. Science 380, 45-52 (2023).
      function parseNature(s, year, doi) {
        const result = {
          raw: s,
          year,
          doi,
          title: null,
          journal: null,
          volume: null,
          issue: null,
          firstPage: null,
          lastPage: null,
          authors: [],
        };

        // ===== è§£æä½œè€… =====
        // æ‰¾åˆ° "et al." æˆ–æœ€åä¸€ä¸ªä½œè€…
        const etAlMatch = s.match(/^(.+?)\s+et\s+al\./i);

        if (etAlMatch) {
          // æœ‰ "et al." çš„æƒ…å†µ
          const authorPart = etAlMatch[1];
          result.authors = parseNatureAuthors(authorPart);
        } else {
          // æ²¡æœ‰ "et al."ï¼Œéœ€è¦æ‰¾åˆ°ä½œè€…éƒ¨åˆ†çš„ç»“å°¾
          // Nature æ ¼å¼ä½œè€…åé¢ç´§è·Ÿæ ‡é¢˜ï¼ˆç”¨ç‚¹å·åˆ†éš”ï¼‰
          const firstDot = s.indexOf(".");
          if (firstDot > 0) {
            const possibleAuthor = s.slice(0, firstDot);
            // éªŒè¯æ˜¯å¦åƒä½œè€…ï¼ˆåº”è¯¥åŒ…å«é€—å·å’Œå¤§å†™å­—æ¯ï¼‰
            if (possibleAuthor.match(/[A-Z][a-z]+,\s*[A-Z]/)) {
              result.authors = parseNatureAuthors(possibleAuthor);
            }
          }
        }

        // ===== è§£ææœŸåˆŠã€å·å·ã€é¡µç ã€å¹´ä»½ =====
        // æ ¸å¿ƒæ¨¡å¼ï¼šJournal Vol, Pages (Year)
        const metaMatch = s.match(
          /\.\s*([A-Z][a-zA-Z.\s]{1,40}?)\s+(\d{1,4})\s*,\s*(\d+)\s*[-â€“â€”]\s*(\d+)\s*\((\d{4})\)/
        );

        if (metaMatch) {
          result.journal = metaMatch[1].trim();
          result.volume = metaMatch[2];
          result.firstPage = metaMatch[3];
          result.lastPage = metaMatch[4];
          result.year = parseInt(metaMatch[5], 10);

          // æ ‡é¢˜åœ¨ä½œè€…å’ŒæœŸåˆŠä¹‹é—´
          const journalIdx = s.indexOf(metaMatch[0]);
          let beforeJournal = s.slice(0, journalIdx).trim();

          // ç§»é™¤ä½œè€…éƒ¨åˆ†ï¼ˆå¦‚æœæœ‰ "et al."ï¼‰
          if (etAlMatch) {
            beforeJournal = beforeJournal.slice(etAlMatch[0].length).trim();
          } else if (result.authors.length > 0) {
            // ç§»é™¤ç¬¬ä¸€éƒ¨åˆ†ï¼ˆä½œè€…ï¼‰
            const firstDot = beforeJournal.indexOf(".");
            if (firstDot > 0) {
              beforeJournal = beforeJournal.slice(firstDot + 1).trim();
            }
          }

          // ç§»é™¤å¼€å¤´çš„ç‚¹å·
          result.title = beforeJournal
            .replace(/^\.\s*/, "")
            .replace(/\.\s*$/, "")
            .trim();
        } else {
          // ç®€åŒ–åŒ¹é…ï¼šæ²¡æœ‰å®Œæ•´çš„é¡µç èŒƒå›´
          const simpleMatch = s.match(
            /\.\s*([A-Z][a-zA-Z.\s]{1,40}?)\s+(\d{1,4})\s*,\s*(\d+)\s*\((\d{4})\)/
          );

          if (simpleMatch) {
            result.journal = simpleMatch[1].trim();
            result.volume = simpleMatch[2];
            result.firstPage = simpleMatch[3];
            result.year = parseInt(simpleMatch[4], 10);
          }
        }

        return result;
      }

      // Nature æ ¼å¼ä½œè€…è§£æè¾…åŠ©å‡½æ•°
      function parseNatureAuthors(authorStr) {
        const authors = [];

        // Nature ä½œè€…æ ¼å¼ï¼šSmith, J., Jones, A. & Lee, C.
        // æˆ–ï¼šSmith, J.
        const parts = authorStr.split(/\s*&\s*|,\s*(?=[A-Z][a-z]+\s*,)/);

        for (const part of parts) {
          const trimmed = part.trim();
          if (!trimmed) continue;

          // æå–å§“æ°ï¼ˆç¬¬ä¸€ä¸ªé€—å·å‰çš„å†…å®¹ï¼‰
          const commaMatch = trimmed.match(/^([A-Z][a-zA-Z'-]+)\s*,/);
          if (commaMatch) {
            authors.push(commaMatch[1]);
          } else {
            // æ²¡æœ‰é€—å·ï¼Œå¯èƒ½æ˜¯å•ä¸ªè¯
            const wordMatch = trimmed.match(/^([A-Z][a-zA-Z'-]+)/);
            if (wordMatch && wordMatch[1].length > 1) {
              authors.push(wordMatch[1]);
            }
          }
        }

        return authors;
      }

      // ========== é€šç”¨æ ¼å¼è§£æï¼ˆä¼˜åŒ–ç‰ˆå…œåº•æ–¹æ¡ˆï¼‰ ==========
      // ç”¨äºå¤„ç†æ— æ³•è¯†åˆ«ä¸ºç‰¹å®šæ ¼å¼çš„å‚è€ƒæ–‡çŒ®
      // ç­–ç•¥ï¼šåŸºäºå¸¸è§æ¨¡å¼è¿›è¡Œæ™ºèƒ½æå–ï¼Œä¸åšè¿‡åº¦å‡è®¾
      function parseGeneric(s, year, doi) {
        const result = {
          raw: s,
          year,
          doi,
          title: null,
          journal: null,
          volume: null,
          issue: null,
          firstPage: null,
          lastPage: null,
          authors: [],
        };

        // ===== ç§»é™¤ç¼–å·å‰ç¼€ =====
        let str = s.replace(/^\s*\[?\d+[\].)]\s*/, "").trim();

        // ===== ç­–ç•¥1ï¼šå°è¯•ç”¨ç‚¹å·åˆ†å‰²ï¼ˆæœ€å¸¸è§çš„åˆ†éš”æ–¹å¼ï¼‰ =====
        const dotParts = str.split(/\.\s+/);

        if (dotParts.length >= 2) {
          // ç¬¬ä¸€éƒ¨åˆ†é€šå¸¸æ˜¯ä½œè€…
          const firstPart = dotParts[0];

          // åˆ¤æ–­ç¬¬ä¸€éƒ¨åˆ†æ˜¯å¦åƒä½œè€…åˆ—è¡¨
          const looksLikeAuthors =
            // ä¸­æ–‡ä½œè€…ï¼šå¤šä¸ª2-4å­—çš„ä¸­æ–‡å
            firstPart.match(
              /^[\u4e00-\u9fa5]{2,4}(?:[,ï¼Œã€]\s*[\u4e00-\u9fa5]{2,4})*/
            ) ||
            // è‹±æ–‡ä½œè€…ï¼šLastname, F. æˆ– Lastname F æ ¼å¼
            firstPart.match(/^[A-Z][a-z]+[,\s]+[A-Z]\.?/);

          if (looksLikeAuthors) {
            // è§£æä½œè€…
            result.authors = parseAuthorsGeneric(firstPart);

            // ç¬¬äºŒéƒ¨åˆ†æ˜¯æ ‡é¢˜
            if (dotParts[1]) {
              result.title = dotParts[1].trim().replace(/\.$/, "");
            }

            // ç¬¬ä¸‰éƒ¨åˆ†åŠä¹‹åæ˜¯æœŸåˆŠå’Œå…ƒæ•°æ®
            if (dotParts.length >= 3) {
              const journalPart = dotParts.slice(2).join(". ");
              result.journal = extractJournalGeneric(journalPart);
            }
          } else {
            // ç¬¬ä¸€éƒ¨åˆ†å¯èƒ½å°±æ˜¯æ ‡é¢˜ï¼ˆæŸäº›æ ¼å¼ä½œè€…åœ¨åé¢ï¼‰
            result.title = firstPart.trim().replace(/\.$/, "");
          }
        }

        // ===== ç­–ç•¥2ï¼šå¦‚æœæ²¡æœ‰æå–åˆ°æ ‡é¢˜ï¼Œå°è¯•å…¶ä»–åˆ†éš”ç¬¦ =====
        if (!result.title) {
          // å°è¯•ç”¨é€—å·åˆ†å‰²
          const commaParts = str.split(/,\s*/);

          if (commaParts.length >= 3) {
            // æŸ¥æ‰¾å¹´ä»½ä½ç½®
            let yearIdx = -1;
            for (let i = 0; i < commaParts.length; i++) {
              if (commaParts[i].match(/^\(?(19|20)\d{2}\)?$/)) {
                yearIdx = i;
                break;
              }
            }

            if (yearIdx > 0 && yearIdx < commaParts.length - 1) {
              // å¹´ä»½å‰æ˜¯ä½œè€…
              result.authors = commaParts
                .slice(0, yearIdx)
                .map((a) => a.trim().split(/\s+/)[0])
                .filter((a) => a && a.length > 1 && !a.match(/^\d+$/));

              // å¹´ä»½åæ˜¯æ ‡é¢˜
              result.title = commaParts[yearIdx + 1].trim().replace(/\.$/, "");

              // å†åæ˜¯æœŸåˆŠ
              if (commaParts[yearIdx + 2]) {
                result.journal = commaParts[yearIdx + 2]
                  .trim()
                  .replace(/\.$/, "");
              }
            }
          }
        }

        // ===== ç­–ç•¥3ï¼šæå–å¼•å·å†…çš„æ ‡é¢˜ =====
        if (!result.title) {
          const quotedTitle = str.match(/["'""'']([^"'""'']+)["'""'']/);
          if (quotedTitle) {
            result.title = quotedTitle[1].trim();
          }
        }

        // ===== ç­–ç•¥4ï¼šæå–æ–œä½“æœŸåˆŠåï¼ˆæ˜Ÿå·åŒ…è£¹ï¼‰ =====
        if (!result.journal) {
          const italicJournal = str.match(/\*([^*]+)\*/);
          if (italicJournal) {
            result.journal = italicJournal[1].trim();
          }
        }

        // ===== æå–å·æœŸï¼ˆé€šç”¨æ¨¡å¼ï¼‰ =====
        const volumePatterns = [
          /(\d+)\s*\(\s*(\d+)\s*\)/, // 101(8)
          /\bvol\.?\s*(\d+)(?:\s*[,;]\s*no\.?\s*(\d+))?/i, // vol. 101, no. 8
          /\bVol\s+(\d+)\s+No\.?\s*(\d+)/i, // Vol 101 No 8
          /ç¬¬\s*(\d+)\s*å·\s*ç¬¬?\s*(\d+)\s*æœŸ/, // ç¬¬101å·ç¬¬8æœŸ
          /ç¬¬\s*(\d+)\s*å·/, // ç¬¬101å·
        ];

        for (const pattern of volumePatterns) {
          const match = str.match(pattern);
          if (match) {
            result.volume = match[1];
            if (match[2]) result.issue = match[2];
            break;
          }
        }

        // ===== æå–é¡µç ï¼ˆé€šç”¨æ¨¡å¼ï¼‰ =====
        const pagePatterns = [
          /[ï¼š:]\s*(\d+)\s*[-â€“â€”]\s*(\d+)/, // :100-200
          /\bpp\.?\s*(\d+)\s*[-â€“â€”]\s*(\d+)/i, // pp. 100-200
          /\bpages?\s*(\d+)\s*[-â€“â€”]\s*(\d+)/i, // page 100-200
          /[,ï¼Œ]\s*(\d+)\s*[-â€“â€”]\s*(\d+)\s*[.ï¼Œã€‚]?\s*$/, // æœ«å°¾çš„ 100-200
          /\((\d+)\s*[-â€“â€”]\s*(\d+)\)/, // (100-200)
        ];

        for (const pattern of pagePatterns) {
          const match = str.match(pattern);
          if (match) {
            // éªŒè¯é¡µç çš„åˆç†æ€§ï¼ˆé¿å…åŒ¹é…åˆ°å¹´ä»½ç­‰ï¼‰
            const first = parseInt(match[1], 10);
            const last = parseInt(match[2], 10);
            if (first < last && first < 100000 && last - first < 10000) {
              result.firstPage = match[1];
              result.lastPage = match[2];
              break;
            }
          }
        }

        // ===== æå–æ–‡ç« ç¼–å·ï¼ˆå¦‚ MDPI æ ¼å¼ï¼‰ =====
        if (!result.firstPage) {
          const articleNumMatch = str.match(/\)\s*[.,\s]*\((\d+)\)\s*[.,\s]*$/);
          if (articleNumMatch) {
            result.articleNumber = articleNumMatch[1];
            result.firstPage = articleNumMatch[1];
          }
        }

        // ===== æ¸…ç†ç»“æœ =====
        if (result.title) {
          result.title = result.title.replace(/\.$/, "").trim();
        }
        if (result.journal) {
          result.journal = result.journal
            .replace(/^\*|\*$/g, "")
            .replace(/\.$/, "")
            .trim();
        }

        return result;
      }

      // é€šç”¨ä½œè€…è§£æè¾…åŠ©å‡½æ•°
      function parseAuthorsGeneric(authorStr) {
        const authors = [];

        // ç§»é™¤ "et al." æˆ– "ç­‰"
        const cleaned = authorStr
          .replace(/\s*et\s+al\.?\s*$/i, "")
          .replace(/\s*ç­‰\s*$/, "")
          .trim();

        // å°è¯•å¤šç§åˆ†éš”ç¬¦
        const delimiters = [
          /[;ï¼›]\s*/, // åˆ†å·
          /,\s*(?:and|&)\s*/i, // é€—å·åè·Ÿ and æˆ– &
          /\s+(?:and|&)\s+/i, // ç©ºæ ¼åŒ…å›´çš„ and æˆ– &
          /[,ï¼Œ]\s*/, // é€—å·
          /[ã€]\s*/, // é¡¿å·ï¼ˆä¸­æ–‡ï¼‰
        ];

        let parts = [cleaned];
        for (const delimiter of delimiters) {
          if (cleaned.match(delimiter)) {
            parts = cleaned.split(delimiter);
            break;
          }
        }

        for (const part of parts) {
          const trimmed = part.trim();
          if (!trimmed) continue;

          // ä¸­æ–‡ä½œè€…
          if (/^[\u4e00-\u9fa5]+$/.test(trimmed)) {
            authors.push(trimmed);
            continue;
          }

          // è‹±æ–‡ä½œè€…ï¼šæå–å§“æ°
          // æ ¼å¼1ï¼šLastname, Firstname
          const commaMatch = trimmed.match(/^([A-Z][a-zA-Z'-]+)\s*,/);
          if (commaMatch) {
            authors.push(commaMatch[1]);
            continue;
          }

          // æ ¼å¼2ï¼šFirstname Lastname æˆ– F. Lastname
          const parts2 = trimmed.split(/\s+/);
          if (parts2.length > 0) {
            // å–æœ€åä¸€ä¸ªéç¼©å†™çš„è¯ä½œä¸ºå§“æ°
            for (let i = parts2.length - 1; i >= 0; i--) {
              const p = parts2[i];
              if (p && p.length > 1 && !p.match(/^[A-Z]\.?$/)) {
                authors.push(p.replace(/[,.]$/, ""));
                break;
              }
            }
          }
        }

        return authors.filter((a) => a && a.length > 0);
      }

      // é€šç”¨æœŸåˆŠåæå–è¾…åŠ©å‡½æ•°
      function extractJournalGeneric(journalPart) {
        // æœŸåˆŠåé€šå¸¸åœ¨å·æœŸä¿¡æ¯ä¹‹å‰
        // ç§»é™¤å¹´ä»½ã€å·æœŸã€é¡µç ç­‰ä¿¡æ¯
        let cleaned = journalPart
          .replace(/\d{4}\s*[;:,]?\s*\d+\s*\(\d+\)\s*:\s*\d+.*$/, "") // å¹´;å·(æœŸ):é¡µ
          .replace(/\d+\s*\(\d+\)\s*:\s*\d+.*$/, "") // å·(æœŸ):é¡µ
          .replace(/[,ï¼Œ]\s*\d+\s*[-â€“â€”]\s*\d+.*$/, "") // , é¡µç 
          .trim();

        // å–ç¬¬ä¸€ä¸ªé€—å·å‰çš„å†…å®¹
        const firstComma = cleaned.indexOf(",");
        if (firstComma > 0) {
          cleaned = cleaned.substring(0, firstComma);
        }

        return cleaned.replace(/\.$/, "").trim();
      }

      async function queryOpenAlex(p, mailto) {
        let url = new URL("https://api.openalex.org/works");
        url.searchParams.set("per-page", "25");
        if (mailto) url.searchParams.set("mailto", mailto);

        if (p.doi) {
          url.searchParams.set("filter", `doi:${p.doi.toLowerCase()}`);
        } else {
          url.searchParams.set("search", p.title || p.raw);
          if (p.year)
            url.searchParams.set("filter", `publication_year:${p.year}`);
        }

        const r = await fetch(url.toString());
        if (!r.ok) throw new Error("OpenAlex è¯·æ±‚å¤±è´¥: " + r.status);
        return await r.json();
      }

      async function queryCrossref(p, mailto) {
        if (p.doi) {
          const doiEnc = encodeURIComponent(p.doi.toLowerCase());
          const url = new URL(`https://api.crossref.org/works/${doiEnc}`);
          if (mailto) url.searchParams.set("mailto", mailto);

          const r = await fetch(url.toString(), {
            headers: { Accept: "application/json" },
          });
          if (!r.ok) throw new Error("Crossref DOI ç²¾ç¡®æŸ¥è¯¢å¤±è´¥: " + r.status);

          const one = await r.json();
          return { message: { items: [one.message] } };
        }

        let url = new URL("https://api.crossref.org/works");
        url.searchParams.set("rows", "50");
        if (mailto) url.searchParams.set("mailto", mailto);

        if (p.title) url.searchParams.set("query.bibliographic", p.title);
        if (p.journal) url.searchParams.set("query.container-title", p.journal);
        if (p.authors && p.authors[0])
          url.searchParams.set("query.author", p.authors[0]);
        if (p.year)
          url.searchParams.set(
            "filter",
            `from-pub-date:${p.year}-01-01,until-pub-date:${p.year}-12-31`
          );

        const r = await fetch(url.toString(), {
          headers: { Accept: "application/json" },
        });
        if (!r.ok) throw new Error("Crossref è¯·æ±‚å¤±è´¥: " + r.status);
        return await r.json();
      }

      /** ---------- æ‰“åˆ† ---------- */
      function scoreOpenAlexWork(p, w) {
        const t = jaccard(p.title, w.title || "");
        const y = p.year && w.publication_year === p.year ? 1 : 0;
        const j = jaccard(
          p.journal,
          w.primary_location?.source?.display_name || ""
        );
        const v =
          p.volume &&
          w.biblio?.volume &&
          String(w.biblio.volume) === String(p.volume)
            ? 1
            : 0;
        const i =
          p.issue &&
          w.biblio?.issue &&
          String(w.biblio.issue) === String(p.issue)
            ? 1
            : 0;
        const fp =
          p.firstPage &&
          w.biblio?.first_page &&
          String(w.biblio.first_page) === String(p.firstPage)
            ? 1
            : 0;
        const lp =
          p.lastPage &&
          w.biblio?.last_page &&
          String(w.biblio.last_page) === String(p.lastPage)
            ? 1
            : 0;

        const workAuthors = (w.authorships || [])
          .map((a) => a.author?.display_name || "")
          .join(" ");
        const a = p.authors?.length
          ? jaccard(p.authors.join(" "), workAuthors)
          : 0;

        return (
          0.45 * t +
          0.15 * a +
          0.12 * j +
          0.1 * y +
          0.06 * v +
          0.04 * i +
          0.04 * fp +
          0.04 * lp
        );
      }

      function scoreCrossrefItem(p, it) {
        const title = it.title && it.title[0] ? it.title[0] : "";
        const container =
          it["container-title"] && it["container-title"][0]
            ? it["container-title"][0]
            : "";
        const issuedYear = it.issued?.["date-parts"]?.[0]?.[0];

        const t = jaccard(p.title, title);
        const j = jaccard(p.journal, container);
        const y = p.year && issuedYear === p.year ? 1 : 0;

        const crAuthors = (it.author || [])
          .map((a) => a.family || "")
          .join(" ");
        const a = p.authors?.length
          ? jaccard(p.authors.join(" "), crAuthors)
          : 0;

        const v =
          p.volume && it.volume && String(it.volume) === String(p.volume)
            ? 1
            : 0;
        const i =
          p.issue && it.issue && String(it.issue) === String(p.issue) ? 1 : 0;
        const page = it.page || "";
        const fp = p.firstPage && page.includes(p.firstPage) ? 1 : 0;
        const lp = p.lastPage && page.includes(p.lastPage) ? 1 : 0;

        return (
          0.45 * t +
          0.15 * a +
          0.12 * j +
          0.1 * y +
          0.06 * v +
          0.04 * i +
          0.04 * fp +
          0.04 * lp
        );
      }

      function getVerdict(score) {
        if (score >= 0.78)
          return { level: "high", text: "é«˜å¯ä¿¡", desc: "å¼ºåŒ¹é…" };
        if (score >= 0.55)
          return { level: "medium", text: "ä¸­å¯ä¿¡", desc: "éœ€æ ¸å¯¹" };
        return { level: "low", text: "ä½å¯ä¿¡", desc: "å¯èƒ½ä¼ªé€ " };
      }

      /** ---------- å•æ¡æ ¡éªŒ ---------- */
      async function verifySingle(raw, mailto) {
        const p = parseCitation(raw);

        const [oa, cr] = await Promise.all([
          queryOpenAlex(p, mailto).catch((e) => ({ __error: e.message })),
          queryCrossref(p, mailto).catch((e) => ({ __error: e.message })),
        ]);

        const oaItems = oa?.results || [];
        const crItems = cr?.message?.items || [];

        const oaBest = pickBest(oaItems, (w) => scoreOpenAlexWork(p, w));
        const crBest = pickBest(crItems, (it) => scoreCrossrefItem(p, it));

        const oaScore = oaBest?.best ? oaBest.bestScore : 0;
        const crScore = crBest?.best ? crBest.bestScore : 0;
        const combined =
          Math.max(oaScore, crScore) * 0.6 + Math.min(oaScore, crScore) * 0.4;

        return {
          raw,
          parsed: p,
          oaBest,
          crBest,
          oaScore,
          crScore,
          combined,
          verdict: getVerdict(combined),
        };
      }

      /** ---------- UI æ¸²æŸ“ ---------- */
      function renderResult(result, index) {
        const {
          raw,
          parsed,
          oaBest,
          crBest,
          oaScore,
          crScore,
          combined,
          verdict,
        } = result;
        const oa = oaBest?.best;
        const cr = crBest?.best;

        return `
    <div class="result-item" data-index="${index}">
      <div class="result-header" onclick="toggleResult(${index})">
        <div class="result-index">${index + 1}</div>
        <div class="result-title">${esc(parsed.title || raw.slice(0, 80))}</div>
        <div class="result-score ${verdict.level}">${
          verdict.text
        } ${combined.toFixed(2)}</div>
        <div class="result-toggle">
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <polyline points="6 9 12 15 18 9"></polyline>
          </svg>
        </div>
      </div>
      <div class="result-details">
        <div class="detail-section">
          <h4>è§£æå­—æ®µ</h4>
          <div class="detail-grid">
            <div class="detail-label">åŸå§‹å¼•ç”¨</div>
            <div class="detail-value" style="font-size:12px;color:var(--text-muted)">${esc(
              raw
            )}</div>
            <div class="detail-label">æ ‡é¢˜</div>
            <div class="detail-value">${esc(parsed.title || "-")}</div>
            <div class="detail-label">ä½œè€…</div>
            <div class="detail-value">${esc(
              (parsed.authors || []).join(", ") || "-"
            )}</div>
            <div class="detail-label">æœŸåˆŠ/å‡ºç‰ˆç¤¾</div>
            <div class="detail-value">${esc(parsed.journal || "-")}</div>
            <div class="detail-label">å¹´ä»½</div>
            <div class="detail-value">${esc(parsed.year || "-")}</div>
            <div class="detail-label">å·(æœŸ):é¡µç </div>
            <div class="detail-value">${esc(parsed.volume || "-")}(${esc(
          parsed.issue || "-"
        )}):${
          parsed.articleNumber
            ? esc(parsed.articleNumber)
            : esc(parsed.firstPage || "-") + "-" + esc(parsed.lastPage || "-")
        }</div>
            <div class="detail-label">DOI</div>
            <div class="detail-value">${esc(parsed.doi || "æœªæä¾›")}</div>
            ${
              parsed.arxivId
                ? `<div class="detail-label">arXiv ID</div>
            <div class="detail-value"><a href="https://arxiv.org/abs/${esc(
              parsed.arxivId
            )}" target="_blank">${esc(parsed.arxivId)}</a></div>`
                : ""
            }
          </div>
        </div>

        <div class="detail-section">
          <h4>
            <span class="source-badge openalex">OpenAlex</span>
            <span class="score-inline">åŒ¹é…åˆ† ${oaScore.toFixed(3)}</span>
          </h4>
          ${
            oa
              ? `
            <div class="detail-grid">
              <div class="detail-label">æ ‡é¢˜</div>
              <div class="detail-value">${esc(oa.title || "-")}</div>
              <div class="detail-label">æ¥æº</div>
              <div class="detail-value">${esc(
                oa.primary_location?.source?.display_name || "-"
              )}</div>
              <div class="detail-label">å¹´ä»½</div>
              <div class="detail-value">${esc(oa.publication_year || "-")}</div>
              <div class="detail-label">å·æœŸé¡µ</div>
              <div class="detail-value">${esc(oa.biblio?.volume || "-")}(${esc(
                  oa.biblio?.issue || "-"
                )}):${esc(oa.biblio?.first_page || "-")}-${esc(
                  oa.biblio?.last_page || "-"
                )}</div>
              <div class="detail-label">DOI</div>
              <div class="detail-value">${
                oa.doi
                  ? `<a href="https://doi.org/${esc(
                      oa.doi.replace("https://doi.org/", "")
                    )}" target="_blank">${esc(oa.doi)}</a>`
                  : "-"
              }</div>
              <div class="detail-label">OpenAlex</div>
              <div class="detail-value"><a href="${esc(
                oa.id
              )}" target="_blank">æŸ¥çœ‹è¯¦æƒ…</a></div>
            </div>
          `
              : `<div style="color:var(--text-muted);font-size:13px">æœªæ‰¾åˆ°åŒ¹é…ç»“æœ</div>`
          }
        </div>

        <div class="detail-section">
          <h4>
            <span class="source-badge crossref">Crossref</span>
            <span class="score-inline">åŒ¹é…åˆ† ${crScore.toFixed(3)}</span>
          </h4>
          ${
            cr
              ? `
            <div class="detail-grid">
              <div class="detail-label">æ ‡é¢˜</div>
              <div class="detail-value">${esc(
                (cr.title && cr.title[0]) || "-"
              )}</div>
              <div class="detail-label">æœŸåˆŠ</div>
              <div class="detail-value">${esc(
                (cr["container-title"] && cr["container-title"][0]) || "-"
              )}</div>
              <div class="detail-label">å¹´ä»½</div>
              <div class="detail-value">${esc(
                cr.issued?.["date-parts"]?.[0]?.[0] || "-"
              )}</div>
              <div class="detail-label">å·æœŸé¡µ</div>
              <div class="detail-value">${esc(cr.volume || "-")}(${esc(
                  cr.issue || "-"
                )}):${esc(cr.page || "-")}</div>
              <div class="detail-label">DOI</div>
              <div class="detail-value">${
                cr.DOI
                  ? `<a href="https://doi.org/${esc(
                      cr.DOI
                    )}" target="_blank">${esc(cr.DOI)}</a>`
                  : "-"
              }</div>
            </div>
          `
              : `<div style="color:var(--text-muted);font-size:13px">æœªæ‰¾åˆ°åŒ¹é…ç»“æœ</div>`
          }
        </div>

        <div class="detail-section">
          <div class="detail-actions">
            <button class="btn btn-extract btn-small" onclick="copyBibTeX(${index}, this)" title="å¤åˆ¶æ­¤æ¡ç›®çš„ BibTeX">
              <svg width="13" height="13" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5">
                <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                <path d="M5 15H4a2 2 0 01-2-2V4a2 2 0 012-2h9a2 2 0 012 2v1"></path>
              </svg>
              å¤åˆ¶ BibTeX
            </button>
          </div>
        </div>
      </div>
    </div>
  `;
      }

      function toggleResult(index) {
        const item = document.querySelector(
          `.result-item[data-index="${index}"]`
        );
        if (item) item.classList.toggle("expanded");
      }

      function updateStats(results) {
        const total = results.length;
        const high = results.filter((r) => r.verdict.level === "high").length;
        const medium = results.filter(
          (r) => r.verdict.level === "medium"
        ).length;
        const low = results.filter((r) => r.verdict.level === "low").length;

        document.getElementById("statTotal").textContent = total;
        document.getElementById("statHigh").textContent = high;
        document.getElementById("statMedium").textContent = medium;
        document.getElementById("statLow").textContent = low;
        document.getElementById("summary").classList.add("active");

        // æ˜¾ç¤ºå¯¼å‡ºåŒºåŸŸ
        if (total > 0) {
          document.getElementById("exportSection").classList.add("active");
        }

        // ä¿å­˜ç»“æœåˆ°å…¨å±€å˜é‡ä¾›å¯¼å‡ºä½¿ç”¨
        window.currentResults = results;

        // æ ¡éªŒå®Œæˆåï¼Œå¦‚æœæœ‰é«˜å¯ä¿¡æ¡ç›®ï¼Œé»˜è®¤é€‰æ‹©"é«˜å¯ä¿¡"
        if (!window.extractedMode && high > 0) {
          exportMode = "high";
          document
            .querySelectorAll(".export-option")
            .forEach((o) => o.classList.remove("active"));
          document
            .querySelector(".export-option[data-value='high']")
            .classList.add("active");
        } else {
          switchToAll();
        }
      }

      function updateProgress(current, total, status) {
        const percent = total > 0 ? (current / total) * 100 : 0;
        document.getElementById("progressFill").style.width = percent + "%";
        document.getElementById(
          "progressCount"
        ).textContent = `${current} / ${total}`;
        document.getElementById("progressStatus").textContent = status;
      }

      /** ---------- ä¸»é€»è¾‘ ---------- */
      document.getElementById("run").addEventListener("click", async () => {
        const btn = document.getElementById("run");
        const resultsDiv = document.getElementById("results");
        const progressDiv = document.getElementById("progress");
        const summaryDiv = document.getElementById("summary");

        const rawText = document.getElementById("citation").value;
        const mailto = document.getElementById("mailto").value.trim();

        // è§£æå¤šè¡Œï¼Œè¿‡æ»¤ç©ºè¡Œ
        const lines = rawText
          .split("\n")
          .map((l) => l.trim())
          .filter(Boolean);

        if (lines.length === 0) {
          resultsDiv.innerHTML = `
      <div class="card empty-state">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
          <path d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"/>
        </svg>
        <div>è¯·è¾“å…¥è‡³å°‘ä¸€æ¡å¼•ç”¨</div>
      </div>
    `;
          return;
        }

        // é‡ç½®UI
        btn.disabled = true;
        const originalText = btn.textContent;
        btn.innerHTML = `<span class="loading-spinner"></span> æ ¡éªŒä¸­...`;
        resultsDiv.innerHTML = "";
        summaryDiv.classList.remove("active");
        progressDiv.classList.add("active");
        updateProgress(0, lines.length, "å‡†å¤‡ä¸­...");

        // æ¸…é™¤æå–æ¨¡å¼ï¼Œæ ¡éªŒå®Œæˆåå°†ä½¿ç”¨æ ¡éªŒç»“æœç”Ÿæˆ BibTeX
        window.extractedMode = false;

        const results = [];

        for (let i = 0; i < lines.length; i++) {
          updateProgress(i, lines.length, `æ­£åœ¨æ ¡éªŒç¬¬ ${i + 1} æ¡...`);

          // æ˜¾ç¤ºå¤„ç†ä¸­å ä½
          resultsDiv.innerHTML += `<div class="processing-item" id="processing-${i}">æ­£åœ¨æ ¡éªŒï¼š${esc(
            lines[i].slice(0, 60)
          )}...</div>`;

          try {
            const result = await verifySingle(lines[i], mailto);
            results.push(result);

            // æ›¿æ¢å ä½ä¸ºçœŸå®ç»“æœ
            const placeholder = document.getElementById(`processing-${i}`);
            if (placeholder) {
              placeholder.outerHTML = renderResult(result, i);
            }
          } catch (e) {
            results.push({
              raw: lines[i],
              parsed: parseCitation(lines[i]),
              oaBest: null,
              crBest: null,
              oaScore: 0,
              crScore: 0,
              combined: 0,
              verdict: { level: "low", text: "é”™è¯¯", desc: e.message },
            });

            const placeholder = document.getElementById(`processing-${i}`);
            if (placeholder) {
              placeholder.outerHTML = renderResult(
                results[results.length - 1],
                i
              );
            }
          }

          // æ·»åŠ å°å»¶è¿Ÿé¿å…è¯·æ±‚è¿‡å¿«
          if (i < lines.length - 1) {
            await new Promise((r) => setTimeout(r, 300));
          }
        }

        updateProgress(lines.length, lines.length, "æ ¡éªŒå®Œæˆ");
        updateStats(results);

        btn.disabled = false;
        btn.textContent = originalText;

        // éšè—è¿›åº¦æ¡
        setTimeout(() => {
          progressDiv.classList.remove("active");
        }, 1000);
      });

      document.getElementById("clear").addEventListener("click", () => {
        document.getElementById("citation").value = "";
        document.getElementById("results").innerHTML = "";
        document.getElementById("summary").classList.remove("active");
        document.getElementById("progress").classList.remove("active");
        document.getElementById("exportSection").classList.remove("active");
        window.currentResults = [];
      });

      /** ---------- BibTeX å¯¼å‡ºåŠŸèƒ½ ---------- */
      // æ˜¾ç¤ºæç¤ºæ¶ˆæ¯
      function showToast(message) {
        const toast = document.getElementById("toast");
        toast.textContent = message;
        toast.classList.add("show");
        setTimeout(() => toast.classList.remove("show"), 2000);
      }

      // å¯¼å‡ºæ¨¡å¼ï¼šall æˆ– high
      let exportMode = "all";

      // é€‰æ‹©å™¨åˆ‡æ¢
      document.querySelectorAll(".export-option").forEach((option) => {
        option.addEventListener("click", () => {
          document
            .querySelectorAll(".export-option")
            .forEach((o) => o.classList.remove("active"));
          option.classList.add("active");
          exportMode = option.dataset.value;
        });
      });

      // åˆ‡æ¢åˆ°å…¨éƒ¨æ¨¡å¼
      function switchToAll() {
        exportMode = "all";
        document
          .querySelectorAll(".export-option")
          .forEach((o) => o.classList.remove("active"));
        document
          .querySelector(".export-option[data-value='all']")
          .classList.add("active");
      }

      // è·å–è¦å¯¼å‡ºçš„ç»“æœå’Œæ™ºèƒ½æç¤ºä¿¡æ¯
      function getResultsForExport() {
        const results = window.currentResults || [];
        if (results.length === 0)
          return { results: [], message: "æš‚æ— ç»“æœ", needSwitch: false };

        // æå–æ¨¡å¼ä¸‹æ²¡æœ‰é«˜å¯ä¿¡æ¦‚å¿µ
        if (window.extractedMode && results[0]?.isExtracted) {
          if (exportMode === "high") {
            return {
              results: [],
              message: "æœªç»è¿‡æ ¡éªŒï¼Œæ— é«˜å¯ä¿¡æ¡ç›®",
              needSwitch: true,
            };
          }
          return { results, message: "", needSwitch: false };
        }

        if (exportMode === "high") {
          const highResults = results.filter((r) => r.verdict.level === "high");
          if (highResults.length === 0) {
            const medium = results.filter(
              (r) => r.verdict.level === "medium"
            ).length;
            const low = results.filter((r) => r.verdict.level === "low").length;
            if (medium > 0 || low > 0) {
              return {
                results: [],
                message: `æ— é«˜å¯ä¿¡æ¡ç›®ï¼ˆ${medium}ä¸­å¯ä¿¡/${low}ä½å¯ä¿¡ï¼‰`,
                needSwitch: true,
              };
            }
            return { results: [], message: "æ— é«˜å¯ä¿¡æ¡ç›®", needSwitch: true };
          }
          return { results: highResults, message: "", needSwitch: false };
        }

        return { results, message: "", needSwitch: false };
      }

      // ç”Ÿæˆ BibTeX å­—ç¬¦ä¸²
      function generateBibTeXString(results) {
        if (results.length === 0) return "";

        const isExtractedMode = window.extractedMode && results[0]?.isExtracted;
        return results
          .map((r) =>
            isExtractedMode
              ? generateBibTeXFromParsed(r.parsed)
              : generateBibTeX(r)
          )
          .join("\n\n");
      }

      // ä¸‹è½½ BibTeX
      document.getElementById("exportBib").addEventListener("click", () => {
        const { results, message, needSwitch } = getResultsForExport();
        if (results.length === 0) {
          showToast(message);
          if (needSwitch) switchToAll();
          return;
        }

        const allBibtex = generateBibTeXString(results);
        const filename = `citations_${new Date()
          .toISOString()
          .slice(0, 10)}.bib`;
        downloadFile(allBibtex, filename);
        showToast(`å·²ä¸‹è½½ ${results.length} æ¡ BibTeX`);
      });

      // å¤åˆ¶ BibTeX
      document.getElementById("copyBib").addEventListener("click", async () => {
        const { results, message, needSwitch } = getResultsForExport();
        if (results.length === 0) {
          showToast(message);
          if (needSwitch) switchToAll();
          return;
        }

        const allBibtex = generateBibTeXString(results);
        const success = await copyToClipboard(allBibtex);

        if (success) {
          showToast(`å·²å¤åˆ¶ ${results.length} æ¡ BibTeX`);
        } else {
          showToast("å¤åˆ¶å¤±è´¥ï¼Œè¯·é‡è¯•");
        }
      });

      // å¤åˆ¶å•ä¸ª BibTeXï¼ˆç»“æœé¡¹å†…ï¼‰
      async function copyBibTeX(index, button) {
        const results = window.currentResults || [];
        if (!results[index]) return;

        const isExtracted = window.extractedMode && results[index]?.isExtracted;
        const bibtex = isExtracted
          ? generateBibTeXFromParsed(results[index].parsed)
          : generateBibTeX(results[index]);
        const success = await copyToClipboard(bibtex);

        if (success) {
          const originalText = button.innerHTML;
          button.innerHTML = `<svg width="13" height="13" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5"><polyline points="20 6 9 17 4 12"></polyline></svg> å·²å¤åˆ¶`;
          setTimeout(() => (button.innerHTML = originalText), 2000);
        } else {
          showToast("å¤åˆ¶å¤±è´¥ï¼Œè¯·é‡è¯•");
        }
      }

      // æå– BibTeXï¼ˆä¸è°ƒç”¨ APIï¼‰
      document.getElementById("extractBib").addEventListener("click", () => {
        const rawText = document.getElementById("citation").value;
        const resultsDiv = document.getElementById("results");
        const summaryDiv = document.getElementById("summary");
        const exportSection = document.getElementById("exportSection");

        const lines = rawText
          .split("\n")
          .map((l) => l.trim())
          .filter(Boolean);

        if (lines.length === 0) {
          resultsDiv.innerHTML = `
      <div class="card empty-state">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
          <path d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"/>
        </svg>
        <div>è¯·è¾“å…¥è‡³å°‘ä¸€æ¡å¼•ç”¨</div>
      </div>
    `;
          return;
        }

        // ç”Ÿæˆä»…è§£æçš„ç»“æœï¼ˆä¸è°ƒç”¨ APIï¼‰
        const results = lines.map((line, i) => {
          const parsed = parseCitation(line);
          return {
            raw: line,
            parsed: parsed,
            oaBest: null,
            crBest: null,
            oaScore: 0,
            crScore: 0,
            combined: 0,
            verdict: { level: "medium", text: "æœªæ ¡éªŒ", desc: "åŸºäºè§£æ" },
            isExtracted: true, // æ ‡è®°ä¸ºä»…æå–ï¼Œæœªæ ¡éªŒ
          };
        });

        // æ˜¾ç¤ºç»“æœ
        resultsDiv.innerHTML = results
          .map((r, i) => renderExtractedResult(r, i))
          .join("");

        // æ›´æ–°ç»Ÿè®¡
        const total = results.length;
        document.getElementById("statTotal").textContent = total;
        document.getElementById("statHigh").textContent = "-";
        document.getElementById("statMedium").textContent = "-";
        document.getElementById("statLow").textContent = "-";
        summaryDiv.classList.add("active");
        exportSection.classList.add("active");

        // ä¿å­˜ç»“æœåˆ°å…¨å±€å˜é‡
        window.currentResults = results;
        window.extractedMode = true; // æ ‡è®°å½“å‰ä¸ºæå–æ¨¡å¼

        // æå–æ¨¡å¼ä¸‹é‡ç½®é€‰æ‹©å™¨ä¸º"å…¨éƒ¨"
        exportMode = "all";
        document
          .querySelectorAll(".export-option")
          .forEach((o) => o.classList.remove("active"));
        document
          .querySelector(".export-option[data-value='all']")
          .classList.add("active");
      });

      // æ¸²æŸ“ä»…æå–çš„ç»“æœï¼ˆä¸è°ƒç”¨ APIï¼‰
      function renderExtractedResult(result, index) {
        const { raw, parsed } = result;

        return `
    <div class="result-item" data-index="${index}">
      <div class="result-header" onclick="toggleResult(${index})">
        <div class="result-index">${index + 1}</div>
        <div class="result-title">${esc(parsed.title || raw.slice(0, 80))}</div>
        <div class="result-score medium">æœªæ ¡éªŒ</div>
        <div class="result-toggle">
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <polyline points="6 9 12 15 18 9"></polyline>
          </svg>
        </div>
      </div>
      <div class="result-details">
        <div class="detail-section">
          <h4>è§£æå­—æ®µ</h4>
          <div class="detail-grid">
            <div class="detail-label">åŸå§‹å¼•ç”¨</div>
            <div class="detail-value" style="font-size:12px;color:var(--text-muted)">${esc(
              raw
            )}</div>
            <div class="detail-label">æ ‡é¢˜</div>
            <div class="detail-value">${esc(parsed.title || "-")}</div>
            <div class="detail-label">ä½œè€…</div>
            <div class="detail-value">${esc(
              (parsed.authors || []).join(", ") || "-"
            )}</div>
            <div class="detail-label">æœŸåˆŠ/å‡ºç‰ˆç¤¾</div>
            <div class="detail-value">${esc(parsed.journal || "-")}</div>
            <div class="detail-label">å¹´ä»½</div>
            <div class="detail-value">${esc(parsed.year || "-")}</div>
            <div class="detail-label">å·(æœŸ):é¡µç </div>
            <div class="detail-value">${esc(parsed.volume || "-")}(${esc(
          parsed.issue || "-"
        )}):${
          parsed.articleNumber
            ? esc(parsed.articleNumber)
            : esc(parsed.firstPage || "-") + "-" + esc(parsed.lastPage || "-")
        }</div>
            <div class="detail-label">DOI</div>
            <div class="detail-value">${esc(parsed.doi || "æœªæä¾›")}</div>
            ${
              parsed.arxivId
                ? `<div class="detail-label">arXiv ID</div>
            <div class="detail-value"><a href="https://arxiv.org/abs/${esc(
              parsed.arxivId
            )}" target="_blank">${esc(parsed.arxivId)}</a></div>`
                : ""
            }
          </div>
        </div>

        <div class="detail-section">
          <h4> BibTeX é¢„è§ˆ</h4>
          <pre style="background:var(--bg);padding:12px;border-radius:8px;font-size:12px;overflow-x:auto;max-height:200px;overflow-y:auto;border:1px solid var(--border);">${esc(
            generateBibTeXFromParsed(parsed)
          )}</pre>
        </div>

        <div class="detail-section">
          <div class="detail-actions">
            <button class="btn btn-extract btn-small" onclick="copyExtractedBib(${index}, this)" title="å¤åˆ¶æ­¤æ¡ç›®çš„ BibTeX">
              <svg width="13" height="13" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5">
                <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                <path d="M5 15H4a2 2 0 01-2-2V4a2 2 0 012-2h9a2 2 0 012 2v1"></path>
              </svg>
              å¤åˆ¶ BibTeX
            </button>
          </div>
        </div>
      </div>
    </div>
  `;
      }

      // å¤åˆ¶æå–æ¨¡å¼çš„å•ä¸ª BibTeX
      async function copyExtractedBib(index, button) {
        const results = window.currentResults || [];
        if (!results[index]) return;

        const bibtex = generateBibTeXFromParsed(results[index].parsed);
        const success = await copyToClipboard(bibtex);

        if (success) {
          const originalText = button.innerHTML;
          button.innerHTML = `<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="20 6 9 17 4 12"></polyline></svg> å·²å¤åˆ¶`;
          setTimeout(() => (button.innerHTML = originalText), 2000);
        } else {
          showToast("å¤åˆ¶å¤±è´¥ï¼Œè¯·é‡è¯•");
        }
      }

      // é»˜è®¤å±•å¼€ç¬¬ä¸€ä¸ªç»“æœ
      window.toggleResult = toggleResult;
      window.copyBibTeX = copyBibTeX;
      window.copyExtractedBib = copyExtractedBib;
    </script>
  </body>
</html>
