<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>å¼•ç”¨çœŸä¼ªå¿«é€Ÿæ ¡éªŒï¼ˆOpenAlex + Crossrefï¼‰</title>
    <style>
      :root {
        --primary: #4f46e5;
        --primary-light: #818cf8;
        --success: #10b981;
        --warning: #f59e0b;
        --danger: #ef4444;
        --bg: #f8fafc;
        --card-bg: #ffffff;
        --text: #1e293b;
        --text-muted: #64748b;
        --border: #e2e8f0;
        --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1),
          0 2px 4px -2px rgb(0 0 0 / 0.1);
        --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1),
          0 4px 6px -4px rgb(0 0 0 / 0.1);
      }

      * {
        box-sizing: border-box;
      }

      body {
        font-family: system-ui, -apple-system, "Segoe UI", Roboto, Helvetica,
          Arial, sans-serif;
        max-width: 1200px;
        margin: 0 auto;
        padding: 24px 16px;
        line-height: 1.6;
        background: var(--bg);
        color: var(--text);
      }

      .header {
        text-align: center;
        margin-bottom: 32px;
      }

      .header h1 {
        font-size: 28px;
        font-weight: 700;
        background: linear-gradient(
          135deg,
          var(--primary) 0%,
          var(--primary-light) 100%
        );
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
        margin: 0 0 12px 0;
      }

      .header p {
        color: var(--text-muted);
        font-size: 14px;
        max-width: 700px;
        margin: 0 auto;
      }

      .card {
        background: var(--card-bg);
        border-radius: 16px;
        padding: 24px;
        box-shadow: var(--shadow);
        margin-bottom: 20px;
        border: 1px solid var(--border);
      }

      .card-title {
        font-size: 16px;
        font-weight: 600;
        margin: 0 0 16px 0;
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .input-section {
        display: grid;
        grid-template-columns: 1fr 360px;
        gap: 20px;
        align-items: stretch;
      }

      .input-section > div {
        display: flex;
        flex-direction: column;
      }

      .input-section > div:first-child {
        /* å·¦ä¾§ï¼štextarea åŒºåŸŸ */
        display: flex;
        flex-direction: column;
      }

      .input-section > div:last-child {
        /* å³ä¾§ï¼šé…ç½®åŒºåŸŸ */
        justify-content: space-between;
      }

      .right-top {
        flex: 1;
        display: flex;
        flex-direction: column;
        gap: 0;
      }

      .right-bottom {
        margin-top: 16px;
      }

      /* å¹¶å‘æ•°æ§åˆ¶æ ·å¼ */
      .concurrency-section {
        margin-top: 12px;
      }

      .concurrency-control {
        display: flex;
        align-items: center;
        gap: 12px;
      }

      .concurrency-control input[type="number"] {
        width: 70px;
        padding: 6px 10px;
        border: 1px solid var(--border);
        border-radius: 6px;
        font-size: 14px;
        font-weight: 600;
        color: var(--primary);
        text-align: center;
        background: var(--bg);
        outline: none;
        transition: border-color 0.2s ease, box-shadow 0.2s ease;
      }

      .concurrency-control input[type="number"]:focus {
        border-color: var(--primary);
        box-shadow: 0 0 0 3px rgba(79, 70, 229, 0.1);
      }

      .concurrency-control input[type="number"]::-webkit-inner-spin-button,
      .concurrency-control input[type="number"]::-webkit-outer-spin-button {
        opacity: 1;
      }

      @media (max-width: 768px) {
        .input-section {
          grid-template-columns: 1fr;
        }
      }

      label {
        display: block;
        font-size: 14px;
        font-weight: 500;
        margin-bottom: 8px;
        color: var(--text);
      }

      textarea,
      input[type="text"],
      input[type="email"] {
        width: 100%;
        padding: 12px 16px;
        border: 2px solid var(--border);
        border-radius: 12px;
        font-size: 14px;
        transition: all 0.2s ease;
        background: var(--card-bg);
        font-family: inherit;
      }

      textarea:focus,
      input:focus {
        outline: none;
        border-color: var(--primary);
        box-shadow: 0 0 0 3px rgba(79, 70, 229, 0.1);
      }

      textarea {
        resize: vertical;
        min-height: 180px;
        flex: 1;
      }

      .hint {
        font-size: 12px;
        color: var(--text-muted);
        margin-top: 8px;
      }

      .btn {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        gap: 8px;
        padding: 12px 24px;
        border: none;
        border-radius: 12px;
        font-size: 15px;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.25s ease;
      }

      .btn-primary {
        background: linear-gradient(
          135deg,
          var(--primary) 0%,
          var(--primary-light) 100%
        );
        color: white;
        box-shadow: 0 4px 14px 0 rgba(79, 70, 229, 0.35);
      }

      .btn-primary:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 20px 0 rgba(79, 70, 229, 0.45);
      }

      .btn-primary:active {
        transform: translateY(0);
      }

      .btn-primary:disabled {
        opacity: 0.6;
        cursor: not-allowed;
        transform: none;
      }

      .btn-extract {
        background: linear-gradient(135deg, #06b6d4 0%, #22d3ee 100%);
        color: white;
        box-shadow: 0 4px 14px 0 rgba(6, 182, 212, 0.35);
      }

      .btn-extract:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 20px 0 rgba(6, 182, 212, 0.45);
      }

      .btn-extract:active {
        transform: translateY(0);
      }

      .btn-success {
        background: linear-gradient(135deg, var(--success) 0%, #34d399 100%);
        color: white;
        box-shadow: 0 4px 14px 0 rgba(16, 185, 129, 0.35);
      }

      .btn-success:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 20px 0 rgba(16, 185, 129, 0.45);
      }

      .btn-success:active {
        transform: translateY(0);
      }

      .btn-copy {
        background: linear-gradient(135deg, #f97316 0%, #fb923c 100%);
        color: white;
        box-shadow: 0 4px 14px 0 rgba(249, 115, 22, 0.35);
      }

      .btn-copy:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 20px 0 rgba(249, 115, 22, 0.45);
      }

      .btn-copy:active {
        transform: translateY(0);
      }

      .btn-secondary {
        background: var(--card-bg);
        color: var(--text);
        border: 2px solid var(--border);
      }

      .btn-secondary:hover {
        background: var(--bg);
        border-color: #cbd5e1;
      }

      .btn-secondary:active {
        transform: scale(0.98);
      }

      .btn-clear {
        background: linear-gradient(135deg, #64748b 0%, #94a3b8 100%);
        color: white;
        box-shadow: 0 4px 14px 0 rgba(100, 116, 139, 0.35);
      }

      .btn-clear:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 20px 0 rgba(100, 116, 139, 0.45);
      }

      .btn-clear:active {
        transform: translateY(0);
      }

      .btn-info {
        background: linear-gradient(135deg, #0ea5e9 0%, #38bdf8 100%);
        color: white;
        box-shadow: 0 4px 14px 0 rgba(14, 165, 233, 0.35);
      }

      .btn-info:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 20px 0 rgba(14, 165, 233, 0.45);
      }

      .btn-info:active {
        transform: translateY(0);
      }

      .btn-github {
        background: linear-gradient(135deg, #374151 0%, #4b5563 100%);
        color: white;
        box-shadow: 0 4px 14px 0 rgba(55, 65, 81, 0.35);
      }

      .btn-github:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 20px 0 rgba(55, 65, 81, 0.45);
      }

      .btn-github:active {
        transform: translateY(0);
      }

      .actions {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
      }

      /* æŒ‰é’® tooltip æ ·å¼ */
      .btn-tooltip-wrapper {
        position: relative;
        display: inline-flex;
      }

      .btn-tooltip {
        position: absolute;
        bottom: calc(100% + 8px);
        left: 50%;
        transform: translateX(-50%);
        background: #1e293b;
        color: white;
        padding: 6px 12px;
        border-radius: 6px;
        font-size: 12px;
        font-weight: 400;
        white-space: nowrap;
        opacity: 0;
        visibility: hidden;
        transition: opacity 0.15s ease, visibility 0.15s ease;
        z-index: 100;
        pointer-events: none;
      }

      .btn-tooltip::after {
        content: "";
        position: absolute;
        top: 100%;
        left: 50%;
        transform: translateX(-50%);
        border: 5px solid transparent;
        border-top-color: #1e293b;
      }

      .btn-tooltip-wrapper:hover .btn-tooltip {
        opacity: 1;
        visibility: visible;
      }

      /* Progress Bar */
      .progress-container {
        display: none;
        margin-bottom: 20px;
      }

      .progress-container.active {
        display: block;
      }

      .progress-bar {
        height: 8px;
        background: var(--border);
        border-radius: 4px;
        overflow: hidden;
      }

      .progress-fill {
        height: 100%;
        background: linear-gradient(
          90deg,
          var(--primary),
          var(--primary-light)
        );
        border-radius: 4px;
        transition: width 0.3s ease;
        width: 0%;
      }

      .progress-text {
        display: flex;
        justify-content: space-between;
        font-size: 13px;
        color: var(--text-muted);
        margin-top: 8px;
      }

      /* Summary Stats */
      .summary {
        display: none;
        grid-template-columns: repeat(4, 1fr);
        gap: 16px;
        margin-bottom: 20px;
      }

      .summary.active {
        display: grid;
      }

      @media (max-width: 600px) {
        .summary {
          grid-template-columns: repeat(2, 1fr);
        }
      }

      .stat-card {
        background: var(--card-bg);
        border-radius: 12px;
        padding: 16px;
        text-align: center;
        border: 1px solid var(--border);
        box-shadow: var(--shadow);
      }

      .stat-value {
        font-size: 28px;
        font-weight: 700;
      }

      .stat-label {
        font-size: 13px;
        color: var(--text-muted);
        margin-top: 4px;
      }

      .stat-card.total .stat-value {
        color: var(--primary);
      }
      .stat-card.high .stat-value {
        color: var(--success);
      }
      .stat-card.medium .stat-value {
        color: var(--warning);
      }
      .stat-card.low .stat-value {
        color: var(--danger);
      }

      /* Result Items */
      .result-item {
        background: var(--card-bg);
        border-radius: 12px;
        margin-bottom: 16px;
        border: 1px solid var(--border);
        box-shadow: var(--shadow);
        animation: slideIn 0.3s ease;
        position: relative;
      }

      @keyframes slideIn {
        from {
          opacity: 0;
          transform: translateY(10px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      .result-header {
        padding: 16px 20px;
        display: flex;
        align-items: center;
        gap: 12px;
        cursor: pointer;
        user-select: none;
        transition: background 0.2s;
        border-radius: 12px;
        background: var(--card-bg);
      }

      .result-item.expanded .result-header {
        border-radius: 12px 12px 0 0;
      }

      .result-header:hover {
        background: var(--bg);
      }

      .result-index {
        width: 32px;
        height: 32px;
        border-radius: 8px;
        background: var(--bg);
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: 600;
        font-size: 14px;
        color: var(--text-muted);
        flex-shrink: 0;
      }

      .result-title {
        flex: 1;
        font-size: 14px;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }

      .result-score {
        padding: 6px 12px;
        border-radius: 20px;
        font-size: 13px;
        font-weight: 600;
        flex-shrink: 0;
        transition: all 0.2s ease;
        cursor: help;
        display: inline-flex;
        align-items: center;
        gap: 6px;
      }

      .result-score::before {
        content: "";
        width: 8px;
        height: 8px;
        border-radius: 50%;
        flex-shrink: 0;
      }

      .result-score.high {
        background: rgba(16, 185, 129, 0.1);
        color: var(--success);
      }

      .result-score.high::before {
        background: linear-gradient(135deg, var(--success) 0%, #34d399 100%);
        box-shadow: 0 0 6px rgba(16, 185, 129, 0.4);
      }

      .result-score.medium {
        background: rgba(245, 158, 11, 0.1);
        color: var(--warning);
      }

      .result-score.medium::before {
        background: linear-gradient(135deg, var(--warning) 0%, #fbbf24 100%);
        box-shadow: 0 0 6px rgba(245, 158, 11, 0.4);
      }

      .result-score.low {
        background: rgba(239, 68, 68, 0.1);
        color: var(--danger);
      }

      .result-score.low::before {
        background: linear-gradient(135deg, var(--danger) 0%, #f87171 100%);
        box-shadow: 0 0 6px rgba(239, 68, 68, 0.4);
      }

      .result-toggle {
        width: 24px;
        height: 24px;
        display: flex;
        align-items: center;
        justify-content: center;
        color: var(--text-muted);
        transition: transform 0.2s;
      }

      .result-item.expanded .result-toggle {
        transform: rotate(180deg);
      }

      .result-details {
        display: none;
        padding: 0 20px 20px;
        border-top: 1px solid var(--border);
        border-radius: 0 0 12px 12px;
        background: var(--card-bg);
      }

      .result-item.expanded .result-details {
        display: block;
      }

      .detail-section {
        margin-top: 16px;
      }

      .detail-section h4 {
        font-size: 14px;
        font-weight: 600;
        margin: 0 0 12px 0;
        color: var(--text);
      }

      .detail-grid {
        display: grid;
        grid-template-columns: 120px 1fr;
        gap: 8px 16px;
        font-size: 13px;
      }

      .detail-label {
        color: var(--text-muted);
      }

      .detail-value {
        color: var(--text);
        word-break: break-word;
      }

      .detail-value a {
        color: var(--primary);
        text-decoration: none;
      }

      .detail-value a:hover {
        text-decoration: underline;
      }

      .source-badge {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        padding: 6px 12px;
        border-radius: 8px;
        font-size: 12px;
        font-weight: 600;
        margin-right: 8px;
        letter-spacing: 0.3px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.06);
        transition: all 0.2s ease;
      }

      .source-badge::before {
        content: "";
        width: 8px;
        height: 8px;
        border-radius: 50%;
        flex-shrink: 0;
      }

      .source-badge.openalex {
        background: linear-gradient(
          135deg,
          rgba(79, 70, 229, 0.12) 0%,
          rgba(129, 140, 248, 0.12) 100%
        );
        color: var(--primary);
        border: 1px solid rgba(79, 70, 229, 0.2);
      }

      .source-badge.openalex::before {
        background: linear-gradient(
          135deg,
          var(--primary) 0%,
          var(--primary-light) 100%
        );
        box-shadow: 0 0 6px rgba(79, 70, 229, 0.4);
      }

      .source-badge.crossref {
        background: linear-gradient(
          135deg,
          rgba(245, 158, 11, 0.12) 0%,
          rgba(251, 191, 36, 0.12) 100%
        );
        color: #b45309;
        border: 1px solid rgba(245, 158, 11, 0.25);
      }

      .source-badge.crossref::before {
        background: linear-gradient(135deg, var(--warning) 0%, #fbbf24 100%);
        box-shadow: 0 0 6px rgba(245, 158, 11, 0.4);
      }

      .score-tooltip-wrapper:hover .source-badge {
        transform: translateY(-1px);
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
      }

      /* æ ¼å¼èƒ¶å›Šæ ·å¼ */
      .format-badge {
        display: inline-flex;
        align-items: center;
        padding: 2px 8px;
        border-radius: 10px;
        font-size: 11px;
        font-weight: 500;
        background: linear-gradient(135deg, rgba(99, 102, 241, 0.1) 0%, rgba(139, 92, 246, 0.1) 100%);
        color: var(--primary);
        border: 1px solid rgba(99, 102, 241, 0.2);
        white-space: nowrap;
        flex-shrink: 0;
        margin-right: 8px;
      }

      /* Tooltip æ ·å¼ */
      .score-tooltip-wrapper {
        position: relative;
        display: inline-flex;
        align-items: center;
        gap: 10px;
        cursor: help;
        padding: 4px 0;
      }

      .score-tooltip {
        position: absolute;
        bottom: calc(100% + 10px);
        left: 0;
        transform: translateX(0);
        background: linear-gradient(135deg, #1e293b 0%, #334155 100%);
        color: white;
        padding: 14px 16px;
        border-radius: 12px;
        font-size: 12px;
        white-space: nowrap;
        opacity: 0;
        visibility: hidden;
        transition: all 0.25s ease;
        z-index: 1000;
        box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2),
          0 4px 10px rgba(0, 0, 0, 0.1);
        min-width: 240px;
        border: 1px solid rgba(255, 255, 255, 0.1);
        pointer-events: none;
      }

      .score-tooltip::after {
        content: "";
        position: absolute;
        top: 100%;
        left: 24px;
        transform: translateX(0);
        border: 8px solid transparent;
        border-top-color: #334155;
      }

      .score-tooltip-wrapper:hover .score-tooltip {
        opacity: 1;
        visibility: visible;
        transform: translateY(-4px);
      }

      .score-tooltip-row {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 5px 0;
        border-bottom: 1px solid rgba(255, 255, 255, 0.08);
      }

      .score-tooltip-row:last-child {
        border-bottom: none;
        padding-top: 10px;
        margin-top: 6px;
        border-top: 1px solid rgba(255, 255, 255, 0.2);
        font-weight: 600;
      }

      .score-tooltip-label {
        color: rgba(255, 255, 255, 0.65);
        font-size: 11px;
      }

      .score-tooltip-value {
        font-family: "SF Mono", "Monaco", "Inconsolata", monospace;
        font-size: 11px;
        padding: 2px 6px;
        border-radius: 4px;
        background: rgba(255, 255, 255, 0.08);
      }

      .score-tooltip-value.good {
        color: #34d399;
        background: rgba(52, 211, 153, 0.15);
      }

      .score-tooltip-value.medium {
        color: #fbbf24;
        background: rgba(251, 191, 36, 0.15);
      }

      .score-tooltip-value.bad {
        color: #f87171;
        background: rgba(248, 113, 113, 0.15);
      }

      .score-inline {
        font-size: 13px;
        color: var(--text-muted);
        font-weight: 500;
        background: var(--bg);
        padding: 4px 10px;
        border-radius: 6px;
        border: 1px solid var(--border);
      }

      /* æŠ˜å å¤´éƒ¨çš„ tooltip ç‰¹æ®Šå®šä½ */
      .result-score-wrapper {
        padding: 0;
      }

      .result-score-wrapper .score-tooltip {
        left: auto;
        right: 0;
        transform: translateX(0);
      }

      .result-score-wrapper .score-tooltip::after {
        left: auto;
        right: 24px;
      }

      .result-score-wrapper:hover .result-score {
        transform: translateY(-1px);
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      }

      .empty-state {
        text-align: center;
        padding: 60px 20px;
        color: var(--text-muted);
      }

      .empty-state svg {
        width: 64px;
        height: 64px;
        margin-bottom: 16px;
        opacity: 0.5;
      }

      .loading-spinner {
        display: inline-block;
        width: 16px;
        height: 16px;
        border: 2px solid rgba(255, 255, 255, 0.3);
        border-radius: 50%;
        border-top-color: white;
        animation: spin 0.8s linear infinite;
      }

      @keyframes spin {
        to {
          transform: rotate(360deg);
        }
      }

      .processing-item {
        background: linear-gradient(
          90deg,
          var(--bg) 25%,
          var(--card-bg) 50%,
          var(--bg) 75%
        );
        background-size: 200% 100%;
        animation: shimmer 1.5s infinite;
        border-radius: 12px;
        padding: 16px 20px;
        margin-bottom: 16px;
        border: 1px solid var(--border);
      }

      @keyframes shimmer {
        0% {
          background-position: 200% 0;
        }
        100% {
          background-position: -200% 0;
        }
      }

      /* Verdict bar */
      .verdict-bar {
        display: flex;
        gap: 8px;
        margin-top: 12px;
      }

      .verdict-segment {
        flex: 1;
        height: 4px;
        border-radius: 2px;
        background: var(--border);
      }

      .verdict-segment.active.high {
        background: var(--success);
      }
      .verdict-segment.active.medium {
        background: var(--warning);
      }
      .verdict-segment.active.low {
        background: var(--danger);
      }

      /* Detail actions */
      .detail-actions {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
      }

      .btn-small {
        padding: 9px 18px;
        font-size: 13px;
        gap: 6px;
        border-radius: 10px;
      }

      .export-section {
        display: none;
        align-items: center;
        justify-content: center;
        gap: 16px;
        margin: 20px 0;
        flex-wrap: wrap;
      }

      .export-section.active {
        display: flex;
      }

      .export-selector {
        display: flex;
        background: var(--bg);
        border-radius: 10px;
        padding: 4px;
        border: 2px solid var(--success);
        box-shadow: 0 4px 12px 0 rgba(16, 185, 129, 0.15);
      }

      .export-option {
        padding: 10px 24px;
        border-radius: 8px;
        font-size: 14px;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.25s ease;
        color: var(--text-muted);
        user-select: none;
        position: relative;
      }

      .export-option:hover {
        color: var(--text);
        background: rgba(16, 185, 129, 0.1);
      }

      .export-option.active {
        background: linear-gradient(135deg, var(--success) 0%, #34d399 100%);
        color: white;
        box-shadow: 0 2px 8px 0 rgba(16, 185, 129, 0.3);
      }

      .toast {
        position: fixed;
        bottom: 80px;
        left: 50%;
        transform: translateX(-50%) translateY(100px);
        background: linear-gradient(
          135deg,
          var(--primary) 0%,
          var(--primary-light) 100%
        );
        color: white;
        padding: 14px 28px;
        border-radius: 12px;
        font-size: 15px;
        font-weight: 500;
        opacity: 0;
        transition: all 0.3s ease;
        z-index: 3000;
        box-shadow: 0 8px 24px 0 rgba(79, 70, 229, 0.4);
      }

      .toast.show {
        transform: translateX(-50%) translateY(0);
        opacity: 1;
      }

      /* å›¾æ ‡æŒ‰é’® */
      .icon-btn {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        width: 36px;
        height: 36px;
        border: 1px solid var(--border);
        border-radius: 10px;
        background: var(--card-bg);
        color: var(--text-muted);
        cursor: pointer;
        transition: all 0.2s ease;
      }

      .icon-btn:hover {
        background: var(--bg);
        color: var(--text);
        border-color: #cbd5e1;
        transform: translateY(-1px);
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
      }

      .icon-btn:active {
        transform: translateY(0);
      }

      .helper-btns {
        display: flex;
        gap: 8px;
        margin-top: 12px;
      }

      /* å¼¹çª—æ ·å¼ */
      .modal-overlay {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.5);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 2000;
        opacity: 0;
        visibility: hidden;
        transition: all 0.3s ease;
        backdrop-filter: blur(4px);
      }

      .modal-overlay.show {
        opacity: 1;
        visibility: visible;
      }

      .modal {
        background: var(--card-bg);
        border-radius: 16px;
        box-shadow: 0 20px 50px rgba(0, 0, 0, 0.2);
        max-width: 600px;
        width: 90%;
        max-height: 80vh;
        overflow: hidden;
        transform: scale(0.9) translateY(20px);
        transition: all 0.3s ease;
      }

      .modal-overlay.show .modal {
        transform: scale(1) translateY(0);
      }

      .modal-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 20px 24px;
        border-bottom: 1px solid var(--border);
        background: linear-gradient(
          135deg,
          var(--primary) 0%,
          var(--primary-light) 100%
        );
        color: white;
      }

      .modal-header h3 {
        margin: 0;
        font-size: 18px;
        font-weight: 600;
      }

      .modal-close {
        width: 32px;
        height: 32px;
        border: none;
        background: rgba(255, 255, 255, 0.2);
        border-radius: 8px;
        color: white;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.2s ease;
      }

      .modal-close:hover {
        background: rgba(255, 255, 255, 0.3);
      }

      .modal-body {
        padding: 24px;
        overflow-y: auto;
        max-height: calc(80vh - 80px);
      }

      .score-table {
        width: 100%;
        border-collapse: collapse;
        font-size: 14px;
      }

      .score-table th,
      .score-table td {
        padding: 12px 16px;
        text-align: left;
        border-bottom: 1px solid var(--border);
      }

      .score-table th {
        background: var(--bg);
        font-weight: 600;
        color: var(--text);
      }

      .score-table tr:last-child td {
        border-bottom: none;
      }

      .score-table .weight {
        color: var(--primary);
        font-weight: 600;
      }

      .verdict-table {
        margin-top: 20px;
      }

      .verdict-table .high {
        color: var(--success);
      }
      .verdict-table .medium {
        color: var(--warning);
      }
      .verdict-table .low {
        color: var(--danger);
      }

      .formula-box {
        background: var(--bg);
        border-radius: 10px;
        padding: 16px;
        margin: 16px 0;
        font-family: "SF Mono", Monaco, monospace;
        font-size: 13px;
        color: var(--text);
        border: 1px solid var(--border);
      }

      .formula-box code {
        color: var(--primary);
        font-weight: 600;
      }

      /* åŒåˆ—å¸ƒå±€ */
      .sources-grid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 16px;
        margin-top: 16px;
      }

      @media (max-width: 768px) {
        .sources-grid {
          grid-template-columns: 1fr;
        }
      }

      .source-card {
        background: var(--bg);
        border-radius: 12px;
        padding: 16px;
        border: 1px solid var(--border);
      }

      .source-card h4 {
        margin: 0 0 12px 0;
        font-size: 14px;
        display: flex;
        align-items: center;
        justify-content: space-between;
        flex-wrap: wrap;
        gap: 8px;
      }

      .source-card .detail-grid {
        font-size: 12px;
      }

      .source-card .detail-label {
        font-size: 11px;
      }

      .link-badge {
        display: inline-flex;
        align-items: center;
        gap: 4px;
        padding: 4px 10px;
        border-radius: 6px;
        font-size: 11px;
        font-weight: 500;
        text-decoration: none;
        transition: all 0.2s ease;
        background: rgba(79, 70, 229, 0.1);
        color: var(--primary);
        border: 1px solid rgba(79, 70, 229, 0.2);
      }

      .link-badge:hover {
        background: rgba(79, 70, 229, 0.15);
        transform: translateY(-1px);
        text-decoration: none;
      }

      .link-badge svg {
        width: 12px;
        height: 12px;
      }

      /* æ ¼å¼ç¤ºä¾‹æ ·å¼ */
      .format-example {
        margin-bottom: 20px;
        padding-bottom: 16px;
        border-bottom: 1px solid var(--border);
      }

      .format-example:last-of-type {
        border-bottom: none;
        margin-bottom: 0;
        padding-bottom: 0;
      }

      .format-example h4 {
        margin: 0 0 10px 0;
        font-size: 14px;
        color: var(--text);
      }

      .example-box {
        background: var(--bg);
        border-radius: 8px;
        padding: 12px 14px;
        margin-bottom: 8px;
        border: 1px solid var(--border);
        overflow-x: auto;
      }

      .example-box:last-child {
        margin-bottom: 0;
      }

      .example-box code {
        font-family: "SF Mono", Monaco, Consolas, "Courier New", monospace;
        font-size: 12px;
        color: var(--text);
        white-space: pre-wrap;
        word-break: break-all;
      }

      /* AI é…ç½®ç›¸å…³æ ·å¼ */
      .ai-config-section {
        margin-top: 16px;
        padding: 16px;
        border: 1px solid rgba(139, 92, 246, 0.2);
        border-radius: 12px;
        background: linear-gradient(135deg, rgba(139, 92, 246, 0.05) 0%, rgba(167, 139, 250, 0.05) 100%);
        flex: 1;
        display: flex;
        flex-direction: column;
        justify-content: center;
        min-height: 80px;
      }

      .ai-toggle {
        display: flex;
        align-items: center;
        gap: 10px;
        margin-bottom: 8px;
      }

      .ai-toggle input[type="checkbox"] {
        width: 18px;
        height: 18px;
        accent-color: #8b5cf6;
        cursor: pointer;
      }

      .ai-toggle label {
        margin: 0;
        cursor: pointer;
        display: flex;
        align-items: center;
        gap: 6px;
      }

      .ai-toggle .ai-badge {
        background: linear-gradient(135deg, #8b5cf6 0%, #a78bfa 100%);
        color: white;
        font-size: 10px;
        padding: 2px 6px;
        border-radius: 4px;
        font-weight: 600;
      }

      .ai-toggle:has(input:disabled) {
        opacity: 0.6;
        cursor: not-allowed;
      }

      /* AI tooltip æ ·å¼ */
      .ai-tooltip {
        position: absolute;
        bottom: calc(100% + 8px);
        left: 50%;
        transform: translateX(-50%);
        background: #1e293b;
        color: white;
        padding: 6px 12px;
        border-radius: 6px;
        font-size: 12px;
        white-space: nowrap;
        opacity: 0;
        visibility: hidden;
        transition: opacity 0.15s ease, visibility 0.15s ease;
        z-index: 100;
        pointer-events: none;
      }

      .ai-tooltip::after {
        content: "";
        position: absolute;
        top: 100%;
        left: 50%;
        transform: translateX(-50%);
        border: 5px solid transparent;
        border-top-color: #1e293b;
      }

      .ai-toggle {
        position: relative;
      }

      .ai-toggle:has(input:disabled):hover .ai-tooltip {
        opacity: 1;
        visibility: visible;
      }

      .btn-ai-config {
        background: linear-gradient(135deg, #8b5cf6 0%, #a78bfa 100%);
        color: white;
        box-shadow: 0 4px 14px 0 rgba(139, 92, 246, 0.35);
      }

      .btn-ai-config:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 20px 0 rgba(139, 92, 246, 0.45);
      }

      .btn-ai-config:active {
        transform: translateY(0);
      }

      .ai-config-form {
        display: flex;
        flex-direction: column;
        gap: 16px;
      }

      .ai-config-form .form-group {
        display: flex;
        flex-direction: column;
        gap: 6px;
      }

      .ai-config-form label {
        font-size: 13px;
        font-weight: 500;
        color: var(--text);
        margin: 0;
      }

      .ai-config-form input,
      .ai-config-form select {
        padding: 10px 14px;
        border: 2px solid var(--border);
        border-radius: 10px;
        font-size: 14px;
        transition: all 0.2s ease;
        background: var(--card-bg);
      }

      .ai-config-form input:focus,
      .ai-config-form select:focus {
        outline: none;
        border-color: #8b5cf6;
        box-shadow: 0 0 0 3px rgba(139, 92, 246, 0.1);
      }

      .ai-config-form .form-row {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 12px;
      }

      .ai-config-form .form-hint {
        font-size: 11px;
        color: var(--text-muted);
        margin-top: 4px;
      }

      .ai-config-actions {
        display: flex;
        gap: 10px;
        margin-top: 8px;
      }

      .ai-status {
        display: flex;
        align-items: center;
        gap: 6px;
        font-size: 12px;
        padding: 8px 12px;
        border-radius: 8px;
        margin-bottom: 16px;
      }

      .ai-status.configured {
        background: rgba(16, 185, 129, 0.1);
        color: var(--success);
        border: 1px solid rgba(16, 185, 129, 0.2);
      }

      .ai-status.not-configured {
        background: rgba(245, 158, 11, 0.1);
        color: var(--warning);
        border: 1px solid rgba(245, 158, 11, 0.2);
      }

      .ai-status-dot {
        width: 8px;
        height: 8px;
        border-radius: 50%;
      }

      .ai-status.configured .ai-status-dot {
        background: var(--success);
      }

      .ai-status.not-configured .ai-status-dot {
        background: var(--warning);
      }
    </style>
  </head>
  <body>
    <div class="header">
      <h1>å¼•ç”¨çœŸä¼ªå¿«é€Ÿæ ¡éªŒ</h1>
      <p>
        é€šè¿‡ OpenAlex ä¸ Crossref
        åŒæ•°æ®æºäº¤å‰éªŒè¯ï¼Œæ™ºèƒ½è§£æå¼•ç”¨å­—æ®µå¹¶è¯„ä¼°å¯ä¿¡åº¦ã€‚æ”¯æŒ GB/T
        7714ã€APAã€MLAã€IEEEã€Chicagoã€Vancouverã€Harvardã€Natureã€Science
        ç­‰å¤šç§æ ¼å¼ï¼Œè‡ªåŠ¨è¯†åˆ«å¹¶å®¹é”™è§£æã€‚<span style="color: var(--danger);">ä½å¯ä¿¡åº¦è¡¨ç¤ºæœªæ‰¾åˆ°åŒ¹é…æ–‡çŒ®ï¼Œå¯èƒ½æ˜¯æ–‡çŒ®ä¸å­˜åœ¨æˆ–æœªè¢«æ•°æ®æºæ”¶å½•ï¼Œç‰¹åˆ«æ˜¯ä¸­æ–‡æ–‡çŒ®ã€‚</span>
      </p>
    </div>

    <div class="card">
      <div class="input-section">
        <div>
          <label for="citation">ç²˜è´´å¼•ç”¨æ¡ç›®ï¼ˆæ”¯æŒå¤šæ¡ï¼Œæ¯è¡Œä¸€æ¡ï¼‰</label>
          <textarea
            id="citation"
            placeholder='åœ¨æ­¤ç²˜è´´å¼•ç”¨æ¡ç›®ï¼Œæ¯è¡Œä¸€æ¡ã€‚æ”¯æŒå¤šç§æ ¼å¼ï¼š&#10;&#10;ä¸­æ–‡ GB/T 7714: å¼ ä¸‰. è®ºæ–‡æ ‡é¢˜[J]. æœŸåˆŠå, 2020, 10(2): 1-20.&#10;APA: Author, A. A. (2020). Title. Journal, 10(2), 1-20.&#10;IEEE: A. Author, "Title," Journal, vol. 10, no. 2, pp. 1-20, 2020.&#10;MLA: Author. "Title." Journal 10.2 (2020): 1-20.&#10;Vancouver: Author. Title. Journal. 2020;10(2):1-20.&#10;&#10;æ ¼å¼ä¹±äº†ä¹Ÿæ²¡å…³ç³»ï¼Œç³»ç»Ÿä¼šæ™ºèƒ½è¯†åˆ«ï¼'
          ></textarea>
          <div class="hint">
            ğŸ’¡ æç¤ºï¼šæ”¯æŒ GB/T 7714ã€APAã€MLAã€IEEEã€Chicagoã€Vancouverã€Harvardã€Natureã€Science
            ç­‰æ ¼å¼ã€‚æ¯è¡Œä¸€æ¡ï¼Œæ ¼å¼ä¸è§„èŒƒä¹Ÿèƒ½æ™ºèƒ½è§£æã€‚
          </div>
        </div>
        <div>
          <div class="right-top">
            <div>
              <label for="mailto">è”ç³»é‚®ç®±ï¼ˆå¯é€‰ï¼‰</label>
              <input type="email" id="mailto" placeholder="you@example.com" />
              <div class="hint">
                æä¾›é‚®ç®±å¯è¿›å…¥ OpenAlex/Crossref çš„ polite poolï¼Œè·å¾—æ›´ç¨³å®šçš„å“åº”ã€‚
              </div>
            </div>

            <div class="concurrency-section">
              <div class="concurrency-control">
                <label for="concurrency">å¹¶å‘æ•°</label>
                <input type="number" id="concurrency" min="1" max="20" value="5" />
              </div>
              <div class="hint" style="margin-top: 4px;">
                åŒæ—¶å¤„ç†çš„è¯·æ±‚æ•°é‡ï¼Œå»ºè®® 3-5ã€‚è¿‡é«˜å¯èƒ½è§¦å‘ API é™æµã€‚
              </div>
            </div>

            <!-- AI é…ç½®åŒºåŸŸ -->
            <div class="ai-config-section">
              <div class="ai-toggle" id="aiToggleWrapper">
                <input type="checkbox" id="useAiParsing" disabled />
                <label for="useAiParsing">
                  ä½¿ç”¨ AI æ™ºèƒ½è§£æ
                  <span class="ai-badge">AI</span>
                </label>
                <span class="ai-tooltip" id="aiTooltip">è¯·å…ˆé…ç½® AI API</span>
              </div>
              <div class="hint" style="margin-top: 0;">
                å¯ç”¨åå°†ä½¿ç”¨ AI è¾…åŠ©è§£æå¼•ç”¨å­—æ®µï¼Œæé«˜å¤æ‚æ ¼å¼çš„è¯†åˆ«å‡†ç¡®ç‡ã€‚
                <a href="javascript:void(0)" id="openAiConfig" style="color: #8b5cf6; font-weight: 500;">é…ç½® AI</a>
              </div>
            </div>
          </div>

          <div class="right-bottom">
            <div class="actions">
              <span class="btn-tooltip-wrapper">
                <button id="run" class="btn btn-primary">å¼€å§‹æ ¡éªŒ</button>
                <span class="btn-tooltip">è°ƒç”¨ OpenAlex å’Œ Crossref API æ ¡éªŒå¼•ç”¨çœŸå®æ€§</span>
              </span>
              <span class="btn-tooltip-wrapper">
                <button id="extractBib" class="btn btn-extract">ç”Ÿæˆ BibTeX</button>
                <span class="btn-tooltip">ç›´æ¥è§£æå¼•ç”¨ç”Ÿæˆ BibTeXï¼Œä¸è°ƒç”¨ API</span>
              </span>
              <span class="btn-tooltip-wrapper">
                <button id="clear" class="btn btn-clear">æ¸…ç©º</button>
                <span class="btn-tooltip">æ¸…ç©ºè¾“å…¥å’Œç»“æœ</span>
              </span>
            </div>

            <div class="helper-btns">
            <span class="btn-tooltip-wrapper">
              <button id="showFormatGuide" class="btn btn-success btn-small">
                <svg
                  width="14"
                  height="14"
                  viewBox="0 0 24 24"
                  fill="none"
                  stroke="currentColor"
                  stroke-width="2.5"
                >
                  <path
                    d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"
                  ></path>
                  <polyline points="14 2 14 8 20 8"></polyline>
                  <line x1="16" y1="13" x2="8" y2="13"></line>
                  <line x1="16" y1="17" x2="8" y2="17"></line>
                  <polyline points="10 9 9 9 8 9"></polyline>
                </svg>
                æ ¼å¼ç¤ºä¾‹
              </button>
              <span class="btn-tooltip">æŸ¥çœ‹æ”¯æŒçš„æ ¼å¼</span>
            </span>
            <span class="btn-tooltip-wrapper">
              <button id="showScoreRules" class="btn btn-info btn-small">
                <svg
                  width="14"
                  height="14"
                  viewBox="0 0 24 24"
                  fill="none"
                  stroke="currentColor"
                  stroke-width="2.5"
                >
                  <circle cx="12" cy="12" r="10"></circle>
                  <path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"></path>
                  <line x1="12" y1="17" x2="12.01" y2="17"></line>
                </svg>
                æ‰“åˆ†æ ‡å‡†
              </button>
              <span class="btn-tooltip">æŸ¥çœ‹æ‰“åˆ†æ ‡å‡†</span>
            </span>
            <span class="btn-tooltip-wrapper">
              <button id="feedback" class="btn btn-github btn-small">
                <svg
                  width="14"
                  height="14"
                  viewBox="0 0 24 24"
                  fill="none"
                  stroke="currentColor"
                stroke-width="2.5"
              >
                <path
                  d="M21 11.5a8.38 8.38 0 0 1-.9 3.8 8.5 8.5 0 0 1-7.6 4.7 8.38 8.38 0 0 1-3.8-.9L3 21l1.9-5.7a8.38 8.38 0 0 1-.9-3.8 8.5 8.5 0 0 1 4.7-7.6 8.38 8.38 0 0 1 3.8-.9h.5a8.48 8.48 0 0 1 8 8v.5z"
                ></path>
              </svg>
              é—®é¢˜åé¦ˆ
              </button>
              <span class="btn-tooltip">åé¦ˆé—®é¢˜</span>
            </span>
          </div>
          </div>
        </div>
      </div>
    </div>

    <div id="progress" class="progress-container">
      <div class="card" style="padding: 16px 20px">
        <div class="progress-bar">
          <div class="progress-fill" id="progressFill"></div>
        </div>
        <div class="progress-text">
          <span id="progressStatus">æ­£åœ¨æ ¡éªŒ...</span>
          <span id="progressCount">0 / 0</span>
        </div>
      </div>
    </div>

    <div id="summary" class="summary">
      <div class="stat-card total">
        <div class="stat-value" id="statTotal">0</div>
        <div class="stat-label">æ€»æ¡ç›®</div>
      </div>
      <div class="stat-card high">
        <div class="stat-value" id="statHigh">0</div>
        <div class="stat-label">é«˜å¯ä¿¡</div>
      </div>
      <div class="stat-card medium">
        <div class="stat-value" id="statMedium">0</div>
        <div class="stat-label">ä¸­å¯ä¿¡</div>
      </div>
      <div class="stat-card low">
        <div class="stat-value" id="statLow">0</div>
        <div class="stat-label">ä½å¯ä¿¡</div>
      </div>
    </div>

    <div id="exportSection" class="export-section">
      <div class="export-selector">
        <div class="export-option active" data-value="all">å…¨éƒ¨</div>
        <div class="export-option" data-value="high">é«˜å¯ä¿¡</div>
      </div>
      <span class="btn-tooltip-wrapper">
        <button id="exportBib" class="btn btn-primary">
          <svg
            width="16"
            height="16"
            viewBox="0 0 24 24"
            fill="none"
            stroke="currentColor"
            stroke-width="2.5"
          >
            <path d="M21 15v4a2 2 0 01-2 2H5a2 2 0 01-2-2v-4"></path>
            <polyline points="7 10 12 15 17 10"></polyline>
            <line x1="12" y1="15" x2="12" y2="3"></line>
          </svg>
          ä¸‹è½½ BibTeX
        </button>
        <span class="btn-tooltip">ä¸‹è½½ BibTeX æ–‡ä»¶</span>
      </span>
      <span class="btn-tooltip-wrapper">
        <button id="copyBib" class="btn btn-copy">
          <svg
            width="16"
            height="16"
            viewBox="0 0 24 24"
            fill="none"
            stroke="currentColor"
            stroke-width="2.5"
          >
            <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
            <path d="M5 15H4a2 2 0 01-2-2V4a2 2 0 012-2h9a2 2 0 012 2v1"></path>
          </svg>
          å¤åˆ¶ BibTeX
        </button>
        <span class="btn-tooltip">å¤åˆ¶ BibTeX åˆ°å‰ªè´´æ¿</span>
      </span>
    </div>

    <div id="results"></div>

    <div id="toast" class="toast">å·²å¤åˆ¶åˆ°å‰ªè´´æ¿</div>

    <!-- æ‰“åˆ†æ ‡å‡†å¼¹çª— -->
    <div id="scoreRulesModal" class="modal-overlay">
      <div class="modal">
        <div class="modal-header">
          <h3>æ‰“åˆ†æ ‡å‡†è¯´æ˜</h3>
          <button class="modal-close" onclick="closeScoreRulesModal()">
            <svg
              width="18"
              height="18"
              viewBox="0 0 24 24"
              fill="none"
              stroke="currentColor"
              stroke-width="2"
            >
              <line x1="18" y1="6" x2="6" y2="18"></line>
              <line x1="6" y1="6" x2="18" y2="18"></line>
            </svg>
          </button>
        </div>
        <div class="modal-body">
          <h4 style="margin: 0 0 12px 0; color: var(--text)">å­—æ®µæƒé‡</h4>
          <table class="score-table">
            <thead>
              <tr>
                <th>å­—æ®µ</th>
                <th>æƒé‡</th>
                <th>è®¡ç®—æ–¹å¼</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>æ ‡é¢˜</td>
                <td class="weight">45%</td>
                <td>Jaccard ç›¸ä¼¼åº¦</td>
              </tr>
              <tr>
                <td>ä½œè€…</td>
                <td class="weight">15%</td>
                <td>å§“æ°åŒ¹é… + Jaccard</td>
              </tr>
              <tr>
                <td>æœŸåˆŠ</td>
                <td class="weight">12%</td>
                <td>ç¼–è¾‘è·ç¦» + å‰ç¼€åŒ¹é…</td>
              </tr>
              <tr>
                <td>å¹´ä»½</td>
                <td class="weight">10%</td>
                <td>ç²¾ç¡®åŒ¹é… (0/1)</td>
              </tr>
              <tr>
                <td>å·å·</td>
                <td class="weight">6%</td>
                <td>ç²¾ç¡®åŒ¹é… (0/1)</td>
              </tr>
              <tr>
                <td>æœŸå·</td>
                <td class="weight">4%</td>
                <td>ç²¾ç¡®åŒ¹é… (0/1)</td>
              </tr>
              <tr>
                <td>é¦–é¡µ</td>
                <td class="weight">4%</td>
                <td>ç²¾ç¡®åŒ¹é… (0/1)</td>
              </tr>
              <tr>
                <td>æœ«é¡µ</td>
                <td class="weight">4%</td>
                <td>ç²¾ç¡®åŒ¹é… (0/1)</td>
              </tr>
            </tbody>
          </table>

          <h4 style="margin: 20px 0 12px 0; color: var(--text)">
            ç»¼åˆè¯„åˆ†å…¬å¼
          </h4>
          <div class="formula-box">
            <code>ç»¼åˆåˆ†</code> = max(OA, CR) Ã— <code>0.6</code> + min(OA, CR) Ã—
            <code>0.4</code>
            <div
              style="margin-top: 8px; font-size: 11px; color: var(--text-muted)"
            >
              OA = OpenAlex å¾—åˆ†ï¼ŒCR = Crossref å¾—åˆ†
            </div>
          </div>

          <h4 style="margin: 20px 0 12px 0; color: var(--text)">å¯ä¿¡åº¦ç­‰çº§</h4>
          <table class="score-table verdict-table">
            <thead>
              <tr>
                <th>ç­‰çº§</th>
                <th>åˆ†æ•°èŒƒå›´</th>
                <th>è¯´æ˜</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td class="high">é«˜å¯ä¿¡</td>
                <td>â‰¥ 0.78</td>
                <td>å¼ºåŒ¹é…ï¼Œå¼•ç”¨åŸºæœ¬å¯ä¿¡</td>
              </tr>
              <tr>
                <td class="medium">ä¸­å¯ä¿¡</td>
                <td>0.55 - 0.78</td>
                <td>éƒ¨åˆ†åŒ¹é…ï¼Œå»ºè®®æ ¸å¯¹</td>
              </tr>
              <tr>
                <td class="low">ä½å¯ä¿¡</td>
                <td>&lt; 0.55</td>
                <td>åŒ¹é…åº¦ä½ï¼Œå¯èƒ½ä¼ªé€ </td>
              </tr>
            </tbody>
          </table>

          <h4 style="margin: 20px 0 12px 0; color: var(--text)">ç‰¹æ®Šå¤„ç†</h4>
          <ul
            style="
              margin: 0;
              padding-left: 20px;
              color: var(--text-muted);
              font-size: 14px;
              line-height: 1.8;
            "
          >
            <li>
              <strong>æœŸåˆŠç¼©å†™</strong>ï¼šæ”¯æŒ "Opt. Express" åŒ¹é… "Optics
              Express"
            </li>
            <li>
              <strong>ä½œè€…ç¼©å†™</strong>ï¼šæ”¯æŒ "G. Lazarev" åŒ¹é… "Gleb Lazarev"
            </li>
            <li>
              <strong>DOI ä¼˜å…ˆ</strong>ï¼šå¦‚æä¾› DOIï¼Œå°†ç²¾ç¡®æŸ¥è¯¢è€Œéæ¨¡ç³Šæœç´¢
            </li>
          </ul>
        </div>
      </div>
    </div>

    <!-- æ ¼å¼ç¤ºä¾‹å¼¹çª— -->
    <div id="formatGuideModal" class="modal-overlay">
      <div class="modal" style="max-width: 800px">
        <div
          class="modal-header"
          style="background: linear-gradient(135deg, #10b981 0%, #34d399 100%)"
        >
          <h3>ğŸ“š æ”¯æŒçš„å‚è€ƒæ–‡çŒ®æ ¼å¼</h3>
          <button class="modal-close" onclick="closeFormatGuideModal()">
            <svg
              width="18"
              height="18"
              viewBox="0 0 24 24"
              fill="none"
              stroke="currentColor"
              stroke-width="2"
            >
              <line x1="18" y1="6" x2="6" y2="18"></line>
              <line x1="6" y1="6" x2="18" y2="18"></line>
            </svg>
          </button>
        </div>
        <div class="modal-body">
          <p
            style="
              color: var(--text-muted);
              margin: 0 0 20px 0;
              font-size: 14px;
            "
          >
            ç³»ç»Ÿæ”¯æŒæ™ºèƒ½è§£æå¤šç§å¸¸è§å‚è€ƒæ–‡çŒ®æ ¼å¼ã€‚å³ä½¿æ ¼å¼ä¸å®Œå…¨è§„èŒƒï¼Œä¹Ÿèƒ½å°½é‡è¯†åˆ«å…³é”®ä¿¡æ¯ã€‚
          </p>

          <div class="format-example">
            <h4>ğŸ‡¨ğŸ‡³ ä¸­æ–‡ GB/T 7714 æ ¼å¼</h4>
            <div class="example-box">
              <code>å¼ ä¸‰, æå››. äººå·¥æ™ºèƒ½åœ¨åŒ»å­¦å½±åƒä¸­çš„åº”ç”¨ç ”ç©¶[J]. è®¡ç®—æœºå­¦æŠ¥, 2020, 43(5): 1024-1035.</code>
            </div>
            <div class="example-box">
              <code>ç‹äº”. æ·±åº¦å­¦ä¹ åŸç†ä¸å®è·µ[M]. åŒ—äº¬: æ¸…åå¤§å­¦å‡ºç‰ˆç¤¾, 2019: 56-78.</code>
            </div>
          </div>

          <div class="format-example">
            <h4>ğŸ“˜ APA æ ¼å¼ (ç¾å›½å¿ƒç†å­¦ä¼š)</h4>
            <div class="example-box">
              <code>Smith, J. A., & Johnson, B. C. (2020). Deep learning in medical imaging. Nature Medicine, 26(3), 317-325.</code>
            </div>
          </div>

          <div class="format-example">
            <h4>ğŸ“— MLA æ ¼å¼ (ç°ä»£è¯­è¨€åä¼š)</h4>
            <div class="example-box">
              <code>Smith, John A. "Deep Learning in Medical Imaging." Nature Medicine, vol. 26, no. 3, 2020, pp. 317-325.</code>
            </div>
          </div>

          <div class="format-example">
            <h4>ğŸ“š Chicago æ ¼å¼</h4>
            <div class="example-box">
              <code>John A. Smith, "Deep Learning in Medical Imaging," Nature Medicine 26, no. 3 (2020): 317-325.</code>
            </div>
          </div>

          <div class="format-example">
            <h4>âš¡ IEEE æ ¼å¼</h4>
            <div class="example-box">
              <code>J. A. Smith, "Deep learning in medical imaging," Nature Medicine, vol. 26, no. 3, pp. 317-325, 2020.</code>
            </div>
          </div>

          <div class="format-example">
            <h4>ğŸ“™ Chicago æ ¼å¼</h4>
            <div class="example-box">
              <code>Smith, John A. "Deep Learning in Medical Imaging." Nature Medicine 26, no. 3 (2020): 317-325.</code>
            </div>
          </div>

          <div class="format-example">
            <h4>ğŸ¥ Vancouver æ ¼å¼ (åŒ»å­¦)</h4>
            <div class="example-box">
              <code>Smith JA, Johnson BC. Deep learning in medical imaging. Nature Medicine. 2020;26(3):317-325.</code>
            </div>
          </div>

          <div class="format-example">
            <h4>ğŸ“‹ Harvard æ ¼å¼</h4>
            <div class="example-box">
              <code>Smith, J.A. (2020) Deep learning in medical imaging. Nature Medicine, 26(3), pp. 317-325.</code>
            </div>
          </div>

          <div class="format-example">
            <h4>ğŸ”¬ Nature æ ¼å¼</h4>
            <div class="example-box">
              <code>Smith, J. A. Deep learning in medical imaging. Nature Medicine 26, 317â€“325 (2020).</code>
            </div>
            <div class="example-box">
              <code>Smith, J. A. et al. A new approach to quantum computing. Nature 600, 123-128 (2021).</code>
            </div>
          </div>

          <div class="format-example">
            <h4>ğŸ§ª Science æ ¼å¼</h4>
            <div class="example-box">
              <code>J. A. Smith, Deep learning in medical imaging. Science 368, 1234-1238 (2020).</code>
            </div>
            <div class="example-box">
              <code>J. A. Smith et al., Advances in gene therapy. Science 372, 456 (2021).</code>
            </div>
          </div>

          <div
            style="
              background: rgba(79, 70, 229, 0.08);
              border-radius: 12px;
              padding: 16px;
              margin-top: 20px;
              border: 1px solid rgba(79, 70, 229, 0.15);
            "
          >
            <h4
              style="margin: 0 0 10px 0; color: var(--primary); font-size: 14px"
            >
              ğŸ’¡ æ™ºèƒ½å®¹é”™æç¤º
            </h4>
            <ul
              style="
                margin: 0;
                padding-left: 20px;
                color: var(--text-muted);
                font-size: 13px;
                line-height: 1.8;
              "
            >
              <li>è‡ªåŠ¨è¯†åˆ«å¹¶ç§»é™¤å¼€å¤´çš„åºå·ï¼ˆå¦‚ [1]ã€1.ã€1) ç­‰ï¼‰</li>
              <li>å…¼å®¹å„ç§å¼•å·æ ¼å¼ï¼ˆ"" ã€Œã€ ã€Šã€‹ï¼‰</li>
              <li>å…¼å®¹å„ç§ç ´æŠ˜å·ï¼ˆ- â€“ â€” âˆ’ï¼‰</li>
              <li>æ ¼å¼ä¸è§„èŒƒæ—¶è‡ªåŠ¨å°è¯•æ™ºèƒ½è§£æ</li>
              <li>æä¾› DOI å¯è·å¾—æœ€ç²¾ç¡®çš„åŒ¹é…ç»“æœ</li>
            </ul>
          </div>
        </div>
      </div>
    </div>

    <!-- AI é…ç½®å¼¹çª— -->
    <div id="aiConfigModal" class="modal-overlay">
      <div class="modal" style="max-width: 500px">
        <div
          class="modal-header"
          style="background: linear-gradient(135deg, #8b5cf6 0%, #a78bfa 100%)"
        >
          <h3>ğŸ¤– AI æ™ºèƒ½è§£æé…ç½®</h3>
          <button class="modal-close" onclick="closeAiConfigModal()">
            <svg
              width="18"
              height="18"
              viewBox="0 0 24 24"
              fill="none"
              stroke="currentColor"
              stroke-width="2"
            >
              <line x1="18" y1="6" x2="6" y2="18"></line>
              <line x1="6" y1="6" x2="18" y2="18"></line>
            </svg>
          </button>
        </div>
        <div class="modal-body">
          <div id="aiConfigStatus" class="ai-status not-configured">
            <span class="ai-status-dot"></span>
            <span>æœªé…ç½® API</span>
          </div>

          <div class="ai-config-form">
            <div class="form-group">
              <label for="aiBaseUrl">API Base URL</label>
              <input
                type="text"
                id="aiBaseUrl"
                placeholder="https://api.openai.com/v1"
              />
              <div class="form-hint">OpenAI å…¼å®¹æ ¼å¼çš„ API åœ°å€</div>
            </div>

            <div class="form-group">
              <label for="aiApiKey">API Key</label>
              <input
                type="password"
                id="aiApiKey"
                placeholder="sk-..."
              />
              <div class="form-hint">API å¯†é’¥ï¼Œå°†å®‰å…¨å­˜å‚¨åœ¨æµè§ˆå™¨æœ¬åœ°</div>
            </div>

            <div class="form-group">
              <label for="aiModel">æ¨¡å‹</label>
              <input
                type="text"
                id="aiModel"
                placeholder="gpt-4o-mini"
                value="gpt-4o-mini"
              />
            </div>

            <div class="form-group">
              <label for="aiTemperature">æ¸©åº¦ (Temperature)</label>
              <input
                type="range"
                id="aiTemperature"
                min="0"
                max="1"
                step="0.1"
                value="0.1"
                style="width: 100%"
              />
              <div style="display: flex; justify-content: space-between; font-size: 12px; color: var(--text-muted);">
                <span>ç²¾ç¡® (0)</span>
                <span id="aiTempValue">0.1</span>
                <span>åˆ›æ„ (1)</span>
              </div>
              <div class="form-hint">å»ºè®®ä½¿ç”¨è¾ƒä½æ¸©åº¦ä»¥è·å¾—ç¨³å®šçš„è§£æç»“æœ</div>
            </div>

            <div class="ai-config-actions">
              <button class="btn btn-primary" onclick="saveAiConfig()">
                ä¿å­˜é…ç½®
              </button>
              <button class="btn btn-secondary" onclick="testAiConfig()">
                æµ‹è¯•è¿æ¥
              </button>
              <button class="btn btn-clear" onclick="clearAiConfig()">
                æ¸…é™¤é…ç½®
              </button>
            </div>
          </div>
        </div>
      </div>
    </div>

    <script>
      /** ---------- AI é…ç½®å¸¸é‡ ---------- */
      const AI_CONFIG_KEY = "citation_checker_ai_config";
      const AI_ENABLED_KEY = "citation_checker_ai_enabled";
      const CONCURRENCY_KEY = "citation_checker_concurrency";

      /** ---------- å·¥å…·å‡½æ•° ---------- */
      function norm(s) {
        return (s || "")
          .toLowerCase()
          .replace(/[\[\]\(\)\{\},.:;'"`~!@#$%^&*_+=<>?/\\|-]/g, " ")
          .replace(/\s+/g, " ")
          .trim();
      }

      function tokens(s) {
        return new Set(norm(s).split(" ").filter(Boolean));
      }

      function jaccard(a, b) {
        const A = tokens(a),
          B = tokens(b);
        if (A.size === 0 || B.size === 0) return 0;
        let inter = 0;
        for (const t of A) if (B.has(t)) inter++;
        const union = A.size + B.size - inter;
        return inter / union;
      }

      // ç¼–è¾‘è·ç¦»ï¼ˆLevenshtein Distanceï¼‰
      function levenshtein(s1, s2) {
        const m = s1.length,
          n = s2.length;
        if (m === 0) return n;
        if (n === 0) return m;

        const dp = Array.from({ length: m + 1 }, () => Array(n + 1).fill(0));
        for (let i = 0; i <= m; i++) dp[i][0] = i;
        for (let j = 0; j <= n; j++) dp[0][j] = j;

        for (let i = 1; i <= m; i++) {
          for (let j = 1; j <= n; j++) {
            const cost = s1[i - 1] === s2[j - 1] ? 0 : 1;
            dp[i][j] = Math.min(
              dp[i - 1][j] + 1, // åˆ é™¤
              dp[i][j - 1] + 1, // æ’å…¥
              dp[i - 1][j - 1] + cost // æ›¿æ¢
            );
          }
        }
        return dp[m][n];
      }

      // å½’ä¸€åŒ–ç¼–è¾‘è·ç¦»ç›¸ä¼¼åº¦ï¼ˆ0-1ï¼Œ1ä¸ºå®Œå…¨ç›¸åŒï¼‰
      function editSimilarity(a, b) {
        if (!a || !b) return 0;
        const s1 = norm(a),
          s2 = norm(b);
        if (s1 === s2) return 1;
        if (s1.length === 0 || s2.length === 0) return 0;
        const dist = levenshtein(s1, s2);
        const maxLen = Math.max(s1.length, s2.length);
        return 1 - dist / maxLen;
      }

      // æœŸåˆŠåç›¸ä¼¼åº¦ï¼ˆç»“åˆå¤šç§ç­–ç•¥ï¼ŒåŠ æƒç»„åˆï¼‰
      function journalSimilarity(input, api) {
        if (!input || !api) return 0;

        // é¢„å¤„ç†ï¼šç§»é™¤ç‚¹å·ã€ç»Ÿä¸€å°å†™ã€å»é™¤å¤šä½™ç©ºæ ¼
        const cleanInput = input
          .toLowerCase()
          .replace(/\./g, "")
          .replace(/\s+/g, " ")
          .trim();
        const cleanApi = api
          .toLowerCase()
          .replace(/\./g, "")
          .replace(/\s+/g, " ")
          .trim();

        // å®Œå…¨åŒ¹é…
        if (cleanInput === cleanApi) return 1;

        const inputWords = cleanInput.split(" ").filter(Boolean);
        const apiWords = cleanApi.split(" ").filter(Boolean);

        // å‰ç¼€åŒ¹é…ï¼ˆæ›´ä¸¥æ ¼ï¼šè¦æ±‚å‰ç¼€é•¿åº¦è‡³å°‘3ä¸ªå­—ç¬¦ï¼Œä¸”åŒ¹é…æ¯”ä¾‹é«˜ï¼‰
        let prefixMatches = 0;
        let totalChecked = 0;
        for (const iw of inputWords) {
          if (iw.length < 2) continue; // è·³è¿‡å¤ªçŸ­çš„è¯
          totalChecked++;
          for (const aw of apiWords) {
            // è¦æ±‚å‰ç¼€é•¿åº¦è‡³å°‘ä¸ºè¾ƒçŸ­è¯çš„60%
            const minPrefixLen = Math.max(
              3,
              Math.floor(Math.min(iw.length, aw.length) * 0.6)
            );
            if (aw.startsWith(iw) || iw.startsWith(aw)) {
              const commonLen = Math.min(iw.length, aw.length);
              if (commonLen >= minPrefixLen) {
                prefixMatches++;
                break;
              }
            }
          }
        }
        // è¦æ±‚è‡³å°‘80%çš„è¯åŒ¹é…æˆåŠŸ
        const prefixScore =
          totalChecked > 0 && prefixMatches / totalChecked >= 0.8
            ? prefixMatches / Math.max(inputWords.length, apiWords.length)
            : 0;

        // ç¼–è¾‘è·ç¦»ç›¸ä¼¼åº¦
        const editScore = editSimilarity(cleanInput, cleanApi);

        // Jaccard ç›¸ä¼¼åº¦
        const jaccardScore = jaccard(input, api);

        // åŠ æƒç»„åˆï¼šç¼–è¾‘è·ç¦»æƒé‡æœ€é«˜ï¼Œå‰ç¼€åŒ¹é…æ¬¡ä¹‹ï¼ŒJaccard ä½œä¸ºè¡¥å……
        // å¦‚æœå‰ç¼€åŒ¹é…æˆåŠŸç‡é«˜ï¼Œç»™äºˆé¢å¤–åŠ æˆ
        const weightedScore =
          editScore * 0.5 + prefixScore * 0.3 + jaccardScore * 0.2;

        // å¦‚æœæŸä¸ªç­–ç•¥å¾—åˆ†ç‰¹åˆ«é«˜ï¼ˆ>0.9ï¼‰ï¼Œå¯ä»¥é€‚å½“æå‡æ€»åˆ†
        const maxScore = Math.max(prefixScore, editScore, jaccardScore);
        if (maxScore > 0.9) {
          return Math.min(1, weightedScore * 0.7 + maxScore * 0.3);
        }

        return weightedScore;
      }

      // ä½œè€…ç›¸ä¼¼åº¦ï¼ˆå¤„ç†ç¼©å†™æƒ…å†µï¼ŒåŠ æƒç»„åˆï¼‰
      // æ”¯æŒä¸¤ç§è¾“å…¥ï¼šæ•°ç»„æˆ–å­—ç¬¦ä¸²
      function authorSimilarity(inputAuthors, apiAuthors) {
        if (!inputAuthors?.length || !apiAuthors) return 0;

        // æ£€æµ‹æ˜¯å¦æ˜¯ä¸­æ–‡åå­—ï¼ˆå…¨æ˜¯ä¸­æ–‡å­—ç¬¦ï¼‰
        const isChinese = (str) => /^[\u4e00-\u9fa5]+$/.test(str.trim());
        // æ£€æµ‹æ˜¯å¦åŒ…å«ä¸­æ–‡å­—ç¬¦
        const hasChinese = (str) => /[\u4e00-\u9fa5]/.test(str);

        // ä»å•ä¸ªä½œè€…å­—ç¬¦ä¸²æå–å§“æ°å’Œåå­—é¦–å­—æ¯
        const extractSingleAuthor = (authorStr) => {
          if (!authorStr || typeof authorStr !== 'string') return null;

          const a = authorStr.trim();
          if (a.length < 2) return null;

          // ä¸­æ–‡åå­—ç‰¹æ®Šå¤„ç†
          if (isChinese(a)) {
            // ä¸­æ–‡åå­—ï¼šç¬¬ä¸€ä¸ªå­—æ˜¯å§“ï¼Œåé¢æ˜¯å
            return {
              lastName: a[0],
              givenName: a.slice(1),
              fullName: a,
              isChinese: true
            };
          }

          // OpenAlex ä¸­æ–‡åå­—æ ¼å¼ï¼š"çˆ½ è–›"ï¼ˆå å§“ï¼Œç©ºæ ¼åˆ†éš”ï¼‰
          // æ£€æµ‹æ˜¯å¦æ˜¯ç©ºæ ¼åˆ†éš”çš„ä¸­æ–‡åå­—
          const spaceParts = a.split(/\s+/);
          if (spaceParts.length === 2 && hasChinese(a)) {
            const [part1, part2] = spaceParts;
            if (isChinese(part1) && isChinese(part2)) {
              // å‡è®¾æ ¼å¼æ˜¯ "å å§“"ï¼ˆOpenAlex æ ¼å¼ï¼‰
              // ä¸­æ–‡åå­—é€šå¸¸å§“æ˜¯å•å­—ï¼Œåæ˜¯1-2å­—
              // å¦‚æœç¬¬äºŒéƒ¨åˆ†æ˜¯å•å­—ï¼Œå¾ˆå¯èƒ½æ˜¯å§“
              if (part2.length === 1 && part1.length >= 1) {
                return {
                  lastName: part2,
                  givenName: part1,
                  fullName: part2 + part1,
                  isChinese: true
                };
              } else if (part1.length === 1 && part2.length >= 1) {
                // æ ¼å¼æ˜¯ "å§“ å"
                return {
                  lastName: part1,
                  givenName: part2,
                  fullName: part1 + part2,
                  isChinese: true
                };
              }
            }
          }

          const parts = a.split(/\s+/);
          let lastName = "";
          let givenInitials = [];

          // å¦‚æœæ˜¯ "Lastname, Firstname" æ ¼å¼
          if (a.includes(",")) {
            const [lastPart, firstPart] = a.split(/,\s*/);
            lastName = lastPart.trim().toLowerCase();
            // æå–åå­—é¦–å­—æ¯
            if (firstPart) {
              const firstParts = firstPart.trim().split(/\s+/);
              for (const p of firstParts) {
                const clean = p.replace(/\./g, "");
                if (clean.length > 0) givenInitials.push(clean[0].toLowerCase());
              }
            }
          } else {
            // "Firstname Lastname" æˆ– "F. Lastname" æˆ– "Smith JA" æ ¼å¼
            // æ£€æµ‹ "Smith JA" æ ¼å¼ï¼ˆå§“æ°åè·Ÿå¤§å†™ç¼©å†™ï¼‰
            const lastPart = parts[parts.length - 1];
            if (parts.length >= 2 && /^[A-Z]{1,3}$/.test(lastPart)) {
              // "Smith JA" æ ¼å¼ï¼šæœ€åæ˜¯ç¼©å†™ï¼Œå€’æ•°ç¬¬äºŒä¸ªæ˜¯å§“æ°
              lastName = parts[parts.length - 2].toLowerCase();
              // ç¼©å†™çš„æ¯ä¸ªå­—æ¯éƒ½æ˜¯åå­—é¦–å­—æ¯
              for (const c of lastPart) {
                givenInitials.push(c.toLowerCase());
              }
              // è¿˜å¯èƒ½æœ‰å‰é¢çš„åå­—éƒ¨åˆ†
              for (let i = 0; i < parts.length - 2; i++) {
                const p = parts[i].replace(/\./g, "");
                if (p.length > 0) givenInitials.unshift(p[0].toLowerCase());
              }
            } else {
              // æ ‡å‡† "Firstname Lastname" æ ¼å¼
              lastName = lastPart.toLowerCase();
              for (let i = 0; i < parts.length - 1; i++) {
                const p = parts[i].replace(/\./g, "");
                if (p.length > 0) givenInitials.push(p[0].toLowerCase());
              }
            }
          }

          if (lastName.length < 2) return null;
          return { lastName, givenInitials, isChinese: false };
        };

        // ä»å­—ç¬¦ä¸²è§£æå¤šä¸ªä½œè€…ï¼ˆç”¨äºå…¼å®¹æ—§çš„å­—ç¬¦ä¸²è¾“å…¥ï¼‰
        const parseAuthorsFromString = (str) => {
          if (!str) return [];

          // æ™ºèƒ½åˆ†å‰²ä½œè€…åˆ—è¡¨
          let authorList = [];

          // å…ˆæŒ‰ " and " æˆ– " & " åˆ†å‰²
          const andParts = str.split(/\s+and\s+|\s*&\s*/i).filter(Boolean);

          for (const part of andParts) {
            // æ£€æµ‹æ˜¯å¦æ˜¯ "Lastname, Firstname" æ ¼å¼
            const commaMatch = part.match(/^([^,]+),\s*([A-Z][^,]*?)$/);
            if (commaMatch) {
              authorList.push(part.trim());
            } else if (part.includes(',')) {
              const commaParts = part.split(/,\s*/);
              let isMultipleAuthors = true;

              if (commaParts.length === 2) {
                const secondPart = commaParts[1].trim();
                if (secondPart.length < 10 && /^[A-Z]/.test(secondPart)) {
                  isMultipleAuthors = false;
                  authorList.push(part.trim());
                }
              }

              if (isMultipleAuthors) {
                for (const cp of commaParts) {
                  if (cp.trim()) authorList.push(cp.trim());
                }
              }
            } else {
              authorList.push(part.trim());
            }
          }

          return authorList.map(extractSingleAuthor).filter(Boolean);
        };

        // å¤„ç†è¾“å…¥ä½œè€…ï¼ˆå¯èƒ½æ˜¯æ•°ç»„æˆ–å­—ç¬¦ä¸²ï¼‰
        let inputAuthorsInfo = [];
        if (Array.isArray(inputAuthors)) {
          // æ•°ç»„ï¼šæ¯ä¸ªå…ƒç´ æ˜¯ä¸€ä¸ªä½œè€…
          inputAuthorsInfo = inputAuthors.map(extractSingleAuthor).filter(Boolean);
        } else {
          // å­—ç¬¦ä¸²ï¼šéœ€è¦è§£æ
          inputAuthorsInfo = parseAuthorsFromString(inputAuthors);
        }

        // å¤„ç† API ä½œè€…ï¼ˆå¯èƒ½æ˜¯æ•°ç»„æˆ–å­—ç¬¦ä¸²ï¼‰
        let apiAuthorsInfo = [];
        if (Array.isArray(apiAuthors)) {
          // æ•°ç»„ï¼šæ¯ä¸ªå…ƒç´ æ˜¯ä¸€ä¸ªä½œè€…ï¼ˆå¯èƒ½æ˜¯å­—ç¬¦ä¸²æˆ–å¯¹è±¡ï¼‰
          apiAuthorsInfo = apiAuthors.map(a => {
            if (typeof a === 'string') {
              return extractSingleAuthor(a);
            } else if (a && typeof a === 'object') {
              // Crossref æ ¼å¼ï¼š{family: "Zhang", given: "Jinglin"}
              // OpenAlex æ ¼å¼ï¼š{author: {display_name: "Jinglin Zhang"}}
              if (a.family) {
                const family = a.family.trim();
                const given = (a.given || '').trim();

                // æ£€æµ‹æ˜¯å¦æ˜¯ä¸­æ–‡åå­—
                if (isChinese(family) || isChinese(given)) {
                  // ä¸­æ–‡åå­—ï¼šfamily æ˜¯å§“ï¼Œgiven æ˜¯å
                  return {
                    lastName: family,
                    givenName: given,
                    fullName: family + given,
                    isChinese: true
                  };
                }

                // è¥¿æ–¹åå­—
                const lastName = family.toLowerCase();
                const givenInitials = [];
                if (given) {
                  // æå– given name çš„é¦–å­—æ¯
                  const givenParts = given.split(/\s+/);
                  for (const p of givenParts) {
                    const clean = p.replace(/\./g, "");
                    if (clean.length > 0) givenInitials.push(clean[0].toLowerCase());
                  }
                }
                return { lastName, givenInitials, isChinese: false };
              } else if (a.author?.display_name) {
                return extractSingleAuthor(a.author.display_name);
              } else if (a.display_name) {
                return extractSingleAuthor(a.display_name);
              }
            }
            return null;
          }).filter(Boolean);
        } else {
          // å­—ç¬¦ä¸²ï¼šéœ€è¦è§£æ
          apiAuthorsInfo = parseAuthorsFromString(apiAuthors);
        }

        if (inputAuthorsInfo.length === 0 || apiAuthorsInfo.length === 0) {
          // å›é€€åˆ° Jaccard ç›¸ä¼¼åº¦
          const inputStr = Array.isArray(inputAuthors) ? inputAuthors.join(" ") : inputAuthors;
          const apiStr = Array.isArray(apiAuthors)
            ? apiAuthors.map(a => typeof a === 'string' ? a : (a.family ? `${a.given || ''} ${a.family}` : a.author?.display_name || '')).join(" ")
            : apiAuthors;
          return jaccard(inputStr, apiStr);
        }

        // ä½œè€…åŒ¹é…
        let totalScore = 0;
        let matchedCount = 0;

        for (const inputAuthor of inputAuthorsInfo) {
          let bestMatchScore = 0;

          for (const apiAuthor of apiAuthorsInfo) {
            let score = 0;

            // ä¸­æ–‡åå­—åŒ¹é…
            if (inputAuthor.isChinese && apiAuthor.isChinese) {
              // å®Œå…¨åŒ¹é…
              if (inputAuthor.fullName === apiAuthor.fullName) {
                score = 1.0;
              } else if (inputAuthor.lastName === apiAuthor.lastName) {
                // å§“æ°åŒ¹é…
                score = 0.7;
                // åå­—åŒ¹é…
                if (inputAuthor.givenName && apiAuthor.givenName) {
                  if (inputAuthor.givenName === apiAuthor.givenName) {
                    score += 0.3;
                  } else if (inputAuthor.givenName.includes(apiAuthor.givenName) ||
                             apiAuthor.givenName.includes(inputAuthor.givenName)) {
                    score += 0.2;
                  }
                }
              }
            } else if (!inputAuthor.isChinese && !apiAuthor.isChinese) {
              // è¥¿æ–¹åå­—åŒ¹é…ï¼ˆå§“æ° + åå­—é¦–å­—æ¯ï¼‰
              if (inputAuthor.lastName === apiAuthor.lastName) {
                score += 0.7;
              } else if (
                inputAuthor.lastName.length >= 3 &&
                (apiAuthor.lastName.startsWith(inputAuthor.lastName) ||
                  inputAuthor.lastName.startsWith(apiAuthor.lastName))
              ) {
                score += 0.5; // å‰ç¼€åŒ¹é…
              } else if (editSimilarity(inputAuthor.lastName, apiAuthor.lastName) > 0.8) {
                score += 0.5; // é«˜ç¼–è¾‘ç›¸ä¼¼åº¦
              }

              // åå­—é¦–å­—æ¯åŒ¹é…ï¼ˆæƒé‡ 30%ï¼‰
              if (inputAuthor.givenInitials?.length > 0 && apiAuthor.givenInitials?.length > 0) {
                let initialMatches = 0;
                const minLen = Math.min(
                  inputAuthor.givenInitials.length,
                  apiAuthor.givenInitials.length
                );
                for (let i = 0; i < minLen; i++) {
                  if (inputAuthor.givenInitials[i] === apiAuthor.givenInitials[i]) {
                    initialMatches++;
                  }
                }
                // é¦–å­—æ¯åŒ¹é…æ¯”ä¾‹
                const initialScore = initialMatches / minLen;
                score += 0.3 * initialScore;
              } else if (score > 0) {
                // å¦‚æœå§“æ°åŒ¹é…ä½†æ²¡æœ‰åå­—ä¿¡æ¯ï¼Œç»™äºˆéƒ¨åˆ†åˆ†æ•°
                score += 0.15;
              }
            }

            bestMatchScore = Math.max(bestMatchScore, score);
          }

          if (bestMatchScore > 0) {
            totalScore += bestMatchScore;
            matchedCount++;
          }
        }

        const totalAuthors = Math.max(
          inputAuthorsInfo.length,
          apiAuthorsInfo.length
        );

        // è®¡ç®—æœ€ç»ˆå¾—åˆ†
        const authorScore = totalAuthors > 0 ? totalScore / totalAuthors : 0;

        // åŸå§‹ Jaccard ä½œä¸ºè¡¥å……ï¼ˆæƒé‡é™ä½ï¼‰
        const inputStr = Array.isArray(inputAuthors) ? inputAuthors.join(" ") : inputAuthors;
        const apiStr = Array.isArray(apiAuthors)
          ? apiAuthors.map(a => typeof a === 'string' ? a : (a.family ? `${a.given || ''} ${a.family}` : a.author?.display_name || '')).join(" ")
          : apiAuthors;
        const jaccardScore = jaccard(inputStr, apiStr);

        // åŠ æƒç»„åˆï¼šä½œè€…åŒ¹é…æƒé‡é«˜ï¼ŒJaccard ä½œä¸ºè¡¥å……
        return authorScore * 0.85 + jaccardScore * 0.15;
      }

      // æå‰ç»ˆæ­¢é˜ˆå€¼ï¼šæ‰¾åˆ°é«˜åˆ†åŒ¹é…å°±åœæ­¢
      const EARLY_STOP_THRESHOLD = 0.9;

      function pickBest(items, scoreFn) {
        let best = null,
          bestScore = -1,
          bestDetails = null;
        for (const it of items) {
          const result = scoreFn(it);
          const sc = typeof result === "object" ? result.total : result;
          const details = typeof result === "object" ? result.details : null;
          if (sc > bestScore) {
            best = it;
            bestScore = sc;
            bestDetails = details;
          }
          // æå‰ç»ˆæ­¢ï¼šæ‰¾åˆ°é«˜åˆ†åŒ¹é…å°±åœæ­¢
          if (bestScore >= EARLY_STOP_THRESHOLD) {
            break;
          }
        }
        return { best, bestScore, bestDetails };
      }

      function esc(s) {
        return (s ?? "").toString().replace(
          /[&<>"']/g,
          (m) =>
            ({
              "&": "&amp;",
              "<": "&lt;",
              ">": "&gt;",
              '"': "&quot;",
              "'": "&#39;",
            }[m])
        );
      }

      /** ---------- BibTeX ç”Ÿæˆ ---------- */
      // ä»…åŸºäºè§£æçš„å¼•ç”¨ç”Ÿæˆ BibTeXï¼ˆä¸è°ƒç”¨ APIï¼‰
      function generateBibTeXFromParsed(parsed) {
        const type = parsed.journal ? "article" : "book";
        const year = parsed.year || "n.d.";
        const title = parsed.title || "";
        const journal = parsed.journal || "";
        const volume = parsed.volume || "";
        const number = parsed.issue || "";
        const pages =
          parsed.firstPage && parsed.lastPage
            ? `${parsed.firstPage}--${parsed.lastPage}`
            : parsed.firstPage || "";

        const doi = parsed.doi || "";
        const url = doi ? `https://doi.org/${doi}` : "";

        // å¤„ç†ä½œè€…
        const authors = (parsed.authors || []).map((a) => {
          // å‡è®¾ä½œè€…å·²ç»æ˜¯å§“æ°æ ¼å¼ï¼Œç›´æ¥ä½¿ç”¨
          return a;
        });

        const authorStr = authors.length > 0 ? authors.join(" and\n  ") : "";

        // ç”Ÿæˆ citation key
        let firstAuthor = authors[0] || "Unknown";
        const firstWord = (title || "").split(/\s+/)[0] || "";
        const cleanWord = firstWord.replace(/[^a-zA-Z0-9]/g, "");
        const citeKey = `${firstAuthor}${year}${cleanWord}`;

        let bibtex = `@${type}{${citeKey},
`;

        if (authorStr)
          bibtex += `  author = {${authorStr}},
`;
        if (title)
          bibtex += `  title = {${title}},
`;
        if (journal)
          bibtex += `  journal = {${journal}},
`;
        if (year)
          bibtex += `  year = {${year}},
`;
        if (volume)
          bibtex += `  volume = {${volume}},
`;
        if (number)
          bibtex += `  number = {${number}},
`;
        if (pages)
          bibtex += `  pages = {${pages}},
`;
        if (doi)
          bibtex += `  doi = {${doi}},
`;
        if (url)
          bibtex += `  url = {${url}},
`;

        // ç§»é™¤æœ«å°¾é€—å·
        bibtex = bibtex.replace(/,\n$/, "\n");
        bibtex += "}";

        return bibtex;
      }

      // ä» OpenAlex/Crossref æ•°æ®ç”Ÿæˆ BibTeX
      function generateBibTeX(result) {
        const { parsed, oaBest, crBest } = result;
        const oa = oaBest?.best;
        const cr = crBest?.best;

        // ä¼˜å…ˆä½¿ç”¨ API è¿”å›çš„åŸå§‹ BibTeX
        const rawBib = oa?.biblio?.raw || cr?.["bibliographic-metadata"]?.raw;
        if (
          rawBib &&
          typeof rawBib === "string" &&
          rawBib.trim().startsWith("@")
        ) {
          // æå– citation key
          const entryMatch = rawBib.match(/@(\w+)\s*\{([^,]+),/);
          if (entryMatch) {
            return rawBib.trim();
          }
        }

        // è‡ªè¡Œæ„å»º BibTeX
        const type = parsed.journal ? "article" : "book";
        const year =
          oa?.publication_year ||
          cr?.issued?.["date-parts"]?.[0]?.[0] ||
          parsed.year ||
          "n.d.";
        const title = oa?.title || cr?.title?.[0] || parsed.title || "";

        // æå–ä½œè€…
        let authors = [];
        if (oa?.authorships) {
          authors = oa.authorships.map((a) => {
            const name = a.author?.display_name || "";
            const parts = name.trim().split(/\s+/);
            if (parts.length >= 2) {
              const last = parts[parts.length - 1];
              const first = parts.slice(0, -1).join(" ");
              return `${last}, ${first}`;
            }
            return name;
          });
        } else if (cr?.author) {
          authors = cr.author
            .map((a) => {
              const family = a.family || "";
              const given = a.given || "";
              return family ? (given ? `${family}, ${given}` : family) : "";
            })
            .filter(Boolean);
        } else if (parsed.authors?.length) {
          authors = parsed.authors;
        }

        const authorStr = authors.length > 0 ? authors.join(" and\n  ") : "";

        const journal =
          oa?.primary_location?.source?.display_name ||
          cr?.["container-title"]?.[0] ||
          parsed.journal ||
          "";

        const volume = oa?.biblio?.volume || cr?.volume || parsed.volume || "";
        const number = oa?.biblio?.issue || cr?.issue || parsed.issue || "";
        const pages =
          oa?.biblio?.first_page && oa?.biblio?.last_page
            ? `${oa.biblio.first_page}--${oa.biblio.last_page}`
            : cr?.page || parsed.firstPage
            ? parsed.firstPage && parsed.lastPage
              ? `${parsed.firstPage}--${parsed.lastPage}`
              : cr?.page || ""
            : "";

        const doi = oa?.doi || cr?.DOI || parsed.doi || "";
        const url = oa?.id || (doi ? `https://doi.org/${doi}` : "");

        // ç”Ÿæˆ citation key: ç¬¬ä¸€ä½œè€…å§“æ°+å¹´ä»½+é¦–è¯
        let firstAuthor = authors[0] || "";
        if (firstAuthor.includes(",")) {
          firstAuthor = firstAuthor.split(",")[0].trim();
        }
        const firstWord = (title || "").split(/\s+/)[0] || "";
        const cleanWord = firstWord.replace(/[^a-zA-Z0-9]/g, "");
        const citeKey = `${firstAuthor}${year}${cleanWord}`;

        let bibtex = `@${type}{${citeKey},
`;

        if (authorStr)
          bibtex += `  author = {${authorStr}},
`;
        if (title)
          bibtex += `  title = {${title}},
`;
        if (journal)
          bibtex += `  journal = {${journal}},
`;
        if (year)
          bibtex += `  year = {${year}},
`;
        if (volume)
          bibtex += `  volume = {${volume}},
`;
        if (number)
          bibtex += `  number = {${number}},
`;
        if (pages)
          bibtex += `  pages = {${pages}},
`;
        if (doi)
          bibtex += `  doi = {${doi}},
`;
        if (url)
          bibtex += `  url = {${url}},
`;

        // ç§»é™¤æœ«å°¾é€—å·
        bibtex = bibtex.replace(/,\n$/, "\n");
        bibtex += "}";

        return bibtex;
      }

      // å¤åˆ¶åˆ°å‰ªè´´æ¿
      async function copyToClipboard(text) {
        try {
          await navigator.clipboard.writeText(text);
          return true;
        } catch (e) {
          // å›é€€æ–¹æ¡ˆ
          const textarea = document.createElement("textarea");
          textarea.value = text;
          textarea.style.position = "fixed";
          textarea.style.opacity = "0";
          document.body.appendChild(textarea);
          textarea.select();
          try {
            document.execCommand("copy");
            document.body.removeChild(textarea);
            return true;
          } catch (e2) {
            document.body.removeChild(textarea);
            return false;
          }
        }
      }

      // ä¸‹è½½æ–‡ä»¶
      function downloadFile(content, filename) {
        const blob = new Blob([content], { type: "text/plain;charset=utf-8" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }

      /** ---------- è§£æå¼•ç”¨ ---------- */
      function parseCitation(raw) {
        // é¢„å¤„ç†ï¼šæ ‡å‡†åŒ–è¾“å…¥
        let s = raw.trim();
        // ç§»é™¤å¼€å¤´çš„åºå·å¦‚ [1], 1., 1)
        s = s.replace(/^\s*\[?\d+[\].):\s]+/, "");
        // æ ‡å‡†åŒ–å„ç§ç©ºç™½å­—ç¬¦
        s = s
          .replace(/[\r\n\t]+/g, " ")
          .replace(/\s+/g, " ")
          .trim();
        // æ ‡å‡†åŒ–å„ç§å¼•å·
        s = s.replace(/[""â€â€ŸÂ«Â»]/g, '"').replace(/[''â€šâ€›]/g, "'");
        // æ ‡å‡†åŒ–å„ç§ç ´æŠ˜å·/è¿å­—ç¬¦
        s = s.replace(/[â€“â€”âˆ’â€â€‘â€’â€•]/g, "-");

        // 1. æå–å¹´ä»½ï¼ˆæ”¯æŒå¤šç§æ ¼å¼ï¼š(2019), 2019, [2019]ï¼‰
        let year = null;
        const yearPatterns = [
          /\((\d{4})\)/, // (2019)
          /\[(\d{4})\]/, // [2019]
          /,\s*(\d{4})\s*[,.:;]/, // , 2019,
          /,\s*(\d{4})\s*$/, // ç»“å°¾çš„å¹´ä»½
          /,\s*[A-Za-z]{3,9}\s+(\d{4})\.?\s*$/, // , May 2022. (IEEE æ ¼å¼)
          /\b(19|20)\d{2}\b/, // ä»»æ„ä½ç½®çš„4ä½å¹´ä»½
        ];
        for (const pat of yearPatterns) {
          const m = s.match(pat);
          if (m) {
            const y = parseInt(m[1] || m[0], 10);
            if (y >= 1900 && y <= 2100) {
              year = y;
              break;
            }
          }
        }

        // 2. æå– DOIï¼ˆæ›´å®½æ¾çš„åŒ¹é…ï¼‰
        const doiMatch = s.match(/\b(10\.\d{4,9}\/[^\s,;"\]>]+)/i);
        const doi = doiMatch ? doiMatch[1].replace(/[.,;>\]]+$/, "") : null;

        // 3. æ£€æµ‹å¼•ç”¨æ ¼å¼ç±»å‹
        const hasChineseMarker =
          /\[(J|M|C|D|N|R|S|P|DB|CP|EB|OL|Z|A|G|K)\]/i.test(s);
        const hasQuotedTitle = /"[^"]{5,}"|ã€Œ[^ã€]{5,}ã€|ã€Š[^ã€‹]{5,}ã€‹/.test(s);
        const hasIEEEStyle =
          /\bvol\.\s*\d+/i.test(s) ||
          /\bno\.\s*\d+/i.test(s) ||
          /\bpp\.\s*\d+/i.test(s);
        // MLA æ ¼å¼ï¼šLastname, Firstname. "Title." Journal, vol. X, no. X, Year, pp. X-X.
        const hasMLAStyle =
          hasQuotedTitle &&
          /,\s*vol\.\s*\d+/i.test(s) &&
          /,\s*\d{4}\s*,/i.test(s);
        // Chicago æ ¼å¼ï¼šFirstname Lastname, "Title," Journal Vol, no. X (Year): Pages.
        const hasChicagoStyle =
          hasQuotedTitle &&
          /,\s*no\.\s*\d+\s*\(\d{4}\)\s*:/i.test(s);
        // APA æ ¼å¼æ£€æµ‹ï¼šæ”¯æŒè¥¿æ–¹åå­—å’Œä¸­æ–‡åå­—
        // è¥¿æ–¹ï¼šAuthor, A. A. (Year). æˆ– ä¸­æ–‡ï¼šä½œè€…å. (Year).
        const hasAPAStyle =
          /^[A-Z][^()]+,\s*[A-Z]\.\s*[A-Z]?\.?\s*(?:\(|\[)?\d{4}(?:\)|\])?\./.test(s) ||
          /^[\u4e00-\u9fa5]{2,4}\.\s*\(\d{4}\)\./.test(s);  // ä¸­æ–‡ä½œè€…å. (å¹´ä»½).
        const hasVancouverStyle =
          /;\s*\d{4}\s*[;:]/i.test(s) || /\.\s*\d{4}\s*;\s*\d+/.test(s) ||
          /\.\s*\d{4}\s+[A-Za-z]{3,9}\s*;\s*\d+/.test(s);  // æ”¯æŒ 2017 Jun;3(2) æ ¼å¼
        // Harvard æ ¼å¼ï¼šAuthor (Year) Title. Journal, Vol(Issue), pp. Pages.
        // æˆ–: Author (Year) 'Title', Journal, Vol(Issue), pp. Pages.
        // æ³¨æ„ï¼šHarvard å¹´ä»½åæ²¡æœ‰å¥å·ï¼ŒAPA å¹´ä»½åæœ‰å¥å·
        const hasHarvardStyle =
          /^[A-Z][^()]+\s*\(\d{4}\)\s*[^.]/.test(s) &&  // å¹´ä»½åä¸æ˜¯å¥å·
          (/,\s*pp?\.\s*\d+/i.test(s) || /,\s*\d+\s*\(\d+\)\s*,/.test(s));
        // Nature/Science æ ¼å¼ï¼šJournal Volume, Pages (Year)
        const hasNatureScienceStyle =
          /[A-Z][A-Za-z.\s&]+\s+\d+,\s*\d+[-â€“â€”]?\d*\s*\(\d{4}\)/.test(s);
        // arXiv æ ¼å¼æ£€æµ‹ï¼šåŒ…å« arXiv æˆ– arxiv.org
        const hasArxivStyle =
          /arXiv/i.test(s) || /arxiv\.org/i.test(s) || /\d{4}\.\d{4,5}/.test(s);

        let title = null;
        let journal = null;
        let authors = [];
        let volume = null,
          issue = null;
        let firstPage = null,
          lastPage = null;
        let publisher = null;
        let format = "é€šç”¨";  // é»˜è®¤æ ¼å¼

        // =========== æ ¼å¼æ£€æµ‹ä¸è§£æ ===========

        if (hasChineseMarker) {
          // ===== ä¸­æ–‡ GB/T 7714 æ ¼å¼è§£æ =====
          // æ ¼å¼ï¼šä½œè€…. æ ‡é¢˜[J]. æœŸåˆŠå, å¹´ä»½, å·(æœŸ): é¡µç .
          format = "GB/T 7714";
          const result = parseChineseGBFormat(s);
          title = result.title;
          journal = result.journal;
          authors = result.authors;
          volume = result.volume;
          issue = result.issue;
          firstPage = result.firstPage;
          lastPage = result.lastPage;
          publisher = result.publisher;
        } else if (hasArxivStyle) {
          // ===== arXiv æ ¼å¼è§£æ =====
          // ä¼˜å…ˆå¤„ç† arXiv å¼•ç”¨ï¼Œé¿å…è¢«å…¶ä»–æ ¼å¼è¯¯è§£æ
          format = "arXiv";
          const result = parseArxivFormat(s);
          title = result.title;
          journal = result.journal;
          authors = result.authors;
          // arXiv é¢„å°æœ¬ä¸æå–å·æœŸé¡µç 
        } else if (hasHarvardStyle) {
          // ===== Harvard æ ¼å¼è§£æ =====
          // æ ¼å¼ï¼šSmith, J.A. (2020) Title. Journal, Vol(Issue), pp. Pages.
          // æˆ–: Author (Year) 'Title', Journal, Vol(Issue), pp. Pages.
          format = "Harvard";
          const result = parseHarvardFormat(s);
          title = result.title;
          journal = result.journal;
          authors = result.authors;
          volume = result.volume;
          issue = result.issue;
          firstPage = result.firstPage;
          lastPage = result.lastPage;
        } else if (hasMLAStyle) {
          // ===== MLA æ ¼å¼è§£æ =====
          // æ ¼å¼ï¼šLastname, Firstname. "Title." Journal, vol. X, no. X, Year, pp. X-X.
          format = "MLA";
          const result = parseMLAFormat(s);
          title = result.title;
          journal = result.journal;
          authors = result.authors;
          volume = result.volume;
          issue = result.issue;
          firstPage = result.firstPage;
          lastPage = result.lastPage;
        } else if (hasChicagoStyle) {
          // ===== Chicago æ ¼å¼è§£æ =====
          // æ ¼å¼ï¼šFirstname Lastname, "Title," Journal Vol, no. X (Year): Pages.
          format = "Chicago";
          const result = parseChicagoFormat(s);
          title = result.title;
          journal = result.journal;
          authors = result.authors;
          volume = result.volume;
          issue = result.issue;
          firstPage = result.firstPage;
          lastPage = result.lastPage;
        } else if (hasIEEEStyle) {
          // ===== IEEE æ ¼å¼è§£æ =====
          // æ ¼å¼ï¼šA. Author, "Title," Journal, vol. X, no. X, pp. X-X, Year.
          format = "IEEE";
          const result = parseIEEEFormat(s);
          title = result.title;
          journal = result.journal;
          authors = result.authors;
          volume = result.volume;
          issue = result.issue;
          firstPage = result.firstPage;
          lastPage = result.lastPage;
        } else if (hasAPAStyle) {
          // ===== APA æ ¼å¼è§£æ =====
          // æ ¼å¼ï¼šAuthor, A. A. (Year). Title. Journal, Volume(Issue), Pages.
          format = "APA";
          const result = parseAPAFormat(s);
          title = result.title;
          journal = result.journal;
          authors = result.authors;
          volume = result.volume;
          issue = result.issue;
          firstPage = result.firstPage;
          lastPage = result.lastPage;
        } else if (hasVancouverStyle) {
          // ===== Vancouver æ ¼å¼è§£æ =====
          // æ ¼å¼ï¼šAuthor. Title. Journal. Year;Volume(Issue):Pages.
          format = "Vancouver";
          const result = parseVancouverFormat(s);
          title = result.title;
          journal = result.journal;
          authors = result.authors;
          volume = result.volume;
          issue = result.issue;
          firstPage = result.firstPage;
          lastPage = result.lastPage;
        } else if (hasNatureScienceStyle) {
          // ===== Nature/Science æ ¼å¼è§£æ =====
          // æ ¼å¼ï¼šAuthor. Title. Journal Volume, Pages (Year).
          // å…ˆå°è¯• Nature æ ¼å¼
          format = "Nature/Science";
          const result = parseNatureFormat(s);
          if (result.title || result.journal) {
            title = result.title;
            journal = result.journal;
            authors = result.authors;
            volume = result.volume;
            issue = result.issue;
            firstPage = result.firstPage;
            lastPage = result.lastPage;
          } else {
            // å°è¯• Science æ ¼å¼
            const sciResult = parseScienceFormat(s);
            title = sciResult.title;
            journal = sciResult.journal;
            authors = sciResult.authors;
            volume = sciResult.volume;
            issue = sciResult.issue;
            firstPage = sciResult.firstPage;
            lastPage = sciResult.lastPage;
          }
        } else {
          // ===== é€šç”¨æ™ºèƒ½è§£æ =====
          format = "é€šç”¨";
          const result = parseGenericFormat(s);
          title = result.title;
          journal = result.journal;
          authors = result.authors;
          volume = result.volume;
          issue = result.issue;
          firstPage = result.firstPage;
          lastPage = result.lastPage;
        }

        // =========== åå¤„ç†å’Œè¡¥å……æå– ===========

        // å¦‚æœè¿˜æ²¡æœ‰æå–åˆ°å·æœŸé¡µç ï¼Œä½¿ç”¨é€šç”¨æ­£åˆ™ï¼ˆarXiv æ ¼å¼è·³è¿‡ï¼‰
        if (format !== "arXiv" && (!volume || !firstPage)) {
          const extracted = extractVolumeIssuePage(s);
          if (!volume && extracted.volume) volume = extracted.volume;
          if (!issue && extracted.issue) issue = extracted.issue;
          if (!firstPage && extracted.firstPage)
            firstPage = extracted.firstPage;
          if (!lastPage && extracted.lastPage) lastPage = extracted.lastPage;
        }

        // æ¸…ç†å’Œæ ‡å‡†åŒ–
        if (title) {
          title = cleanTitle(title);
        }
        if (journal) {
          journal = cleanJournal(journal);
        }
        if (authors.length > 0) {
          authors = cleanAuthors(authors);
        }

        // å¦‚æœæ ‡é¢˜ä¸ºç©ºæˆ–å¤ªçŸ­ï¼Œå°è¯•ä»åŸæ–‡æå–æœ€é•¿çš„æœ‰æ„ä¹‰ç‰‡æ®µ
        if (!title || title.length < 10) {
          title = extractTitleFallback(s, authors, journal) || title;
        }

        return {
          raw: s,
          year,
          doi,
          title,
          journal,
          volume,
          issue,
          firstPage,
          lastPage,
          authors,
          publisher,
          format,
        };
      }

      // ===== ä¸­æ–‡ GB/T 7714 æ ¼å¼è§£æ =====
      function parseChineseGBFormat(s) {
        let title = null,
          journal = null,
          authors = [],
          volume = null,
          issue = null;
        let firstPage = null,
          lastPage = null,
          publisher = null;

        // åŒ¹é…æ–‡çŒ®ç±»å‹æ ‡è®°
        const typeMatch = s.match(/\[([JMCDNRSPZA]|DB|CP|EB|OL)\]/i);
        const typeIdx = typeMatch ? s.indexOf(typeMatch[0]) : -1;

        if (typeIdx !== -1) {
          const beforeType = s.slice(0, typeIdx);
          const afterType = s.slice(typeIdx + typeMatch[0].length);

          // æ ‡é¢˜ï¼šç¬¬ä¸€ä¸ªå¥å·ååˆ°ç±»å‹æ ‡è®°å‰
          const firstDotIdx = beforeType.indexOf(". ");
          if (firstDotIdx !== -1) {
            title = beforeType.slice(firstDotIdx + 2).trim();
          } else {
            // å°è¯•ç”¨ä¸­æ–‡å¥å·
            const cnDotIdx = beforeType.indexOf("ã€‚");
            if (cnDotIdx !== -1) {
              title = beforeType.slice(cnDotIdx + 1).trim();
            } else {
              // æ²¡æœ‰æ˜ç¡®çš„å¥å·åˆ†éš”ï¼Œå°è¯•æŒ‰é€—å·åˆ†å‰²
              const parts = beforeType.split(/[,ï¼Œ]/);
              if (parts.length > 1) {
                authors = [parts[0].trim()];
                title = parts.slice(1).join(",").trim();
              }
            }
          }

          // ä½œè€…ï¼šç¬¬ä¸€ä¸ªå¥å·å‰
          const authorPart =
            firstDotIdx !== -1
              ? beforeType.slice(0, firstDotIdx)
              : beforeType.split(/[,ï¼Œ]/)[0];
          if (authorPart) {
            authors = parseChineseAuthors(authorPart);
          }

          // æœŸåˆŠ/å‡ºç‰ˆä¿¡æ¯
          // æœŸåˆŠæ ¼å¼ï¼š. æœŸåˆŠå, å¹´ä»½, å·(æœŸ): é¡µç 
          // ä¹¦ç±æ ¼å¼ï¼š. å‡ºç‰ˆåœ°: å‡ºç‰ˆç¤¾, å¹´ä»½: é¡µç 
          const journalMatch = afterType.match(/\.\s*([^,ï¼Œ.ã€‚]+?)(?:[,ï¼Œ]|$)/);
          if (journalMatch) {
            const jName = journalMatch[1].trim();
            // åˆ¤æ–­æ˜¯æœŸåˆŠè¿˜æ˜¯å‡ºç‰ˆç¤¾
            if (/å‡ºç‰ˆ|Press|Publisher/i.test(jName)) {
              publisher = jName;
            } else {
              journal = jName;
            }
          }
        } else {
          // æ²¡æœ‰ç±»å‹æ ‡è®°ï¼Œå°è¯•é€šç”¨ä¸­æ–‡æ ¼å¼è§£æ
          // æŒ‰å¥å·åˆ†å‰²
          const parts = s.split(/[.ã€‚]/);
          if (parts.length >= 2) {
            authors = parseChineseAuthors(parts[0]);
            title = parts[1]?.trim();
            if (parts.length >= 3) {
              journal = parts[2]?.split(/[,ï¼Œ]/)[0]?.trim();
            }
          }
        }

        // å·æœŸï¼šæ”¯æŒå¤šç§æ ¼å¼
        // æ ¼å¼1: å¹´ä»½, å·(æœŸ)
        const vi1 = s.match(/[,ï¼Œ]\s*\d{4}\s*[,ï¼Œ]\s*(\d+)\s*\(\s*(\d+)\s*\)/);
        // æ ¼å¼2: å¹´ä»½, å·
        const vi2 = s.match(/[,ï¼Œ]\s*\d{4}\s*[,ï¼Œ]\s*(\d+)\s*(?:[:ï¼š]|$)/);
        // æ ¼å¼3: å·(æœŸ)
        const vi3 = s.match(/[,ï¼Œ]\s*(\d+)\s*\(\s*(\d+)\s*\)\s*[:ï¼š]/);

        if (vi1) {
          volume = vi1[1];
          issue = vi1[2];
        } else if (vi3) {
          volume = vi3[1];
          issue = vi3[2];
        } else if (vi2) {
          volume = vi2[1];
        }

        // é¡µç 
        const pageMatch = s.match(/[:ï¼š]\s*(\d+)\s*[-â€“â€”]\s*(\d+)/);
        if (pageMatch) {
          firstPage = pageMatch[1];
          lastPage = pageMatch[2];
        } else {
          // å•é¡µ
          const singlePage = s.match(/[:ï¼š]\s*(\d+)\s*[.ã€‚]?\s*$/);
          if (singlePage) firstPage = singlePage[1];
        }

        return {
          title,
          journal,
          authors,
          volume,
          issue,
          firstPage,
          lastPage,
          publisher,
        };
      }

      // ===== arXiv æ ¼å¼è§£æ =====
      // æ”¯æŒå¤šç§ arXiv å¼•ç”¨æ ¼å¼ï¼š
      // - MLA: Author, et al. "Title." arXiv, Year, arxiv.org/abs/XXXX.XXXXX.
      // - APA: Author (Year). Title. arXiv preprint arXiv:XXXX.XXXXX.
      // - é€šç”¨: Author. Title. arXiv:XXXX.XXXXX, Year.
      function parseArxivFormat(s) {
        let title = null,
          journal = "arXiv",
          authors = [];

        // ç§»é™¤ arXiv URL å’Œ ID éƒ¨åˆ†ï¼Œé¿å…å¹²æ‰°æ ‡é¢˜æå–
        const cleanedForTitle = s
          .replace(/arxiv\.org\/abs\/\d{4}\.\d{4,5}/gi, "")
          .replace(/arXiv:\s*\d{4}\.\d{4,5}/gi, "")
          .replace(/arXiv\s+preprint\s+arXiv:\s*\d{4}\.\d{4,5}/gi, "")
          .replace(/\d{4}\.\d{4,5}/g, "");

        // å°è¯•æå–å¼•å·å†…çš„æ ‡é¢˜
        const quotedTitle = s.match(/"([^"]+)"/);
        if (quotedTitle) {
          title = quotedTitle[1].trim();

          // ä½œè€…åœ¨å¼•å·å‰
          const quoteStart = s.indexOf(quotedTitle[0]);
          let beforeQuote = s.slice(0, quoteStart).trim();
          beforeQuote = beforeQuote.replace(/[,ï¼Œ.ã€‚]\s*$/, "");
          if (beforeQuote) {
            authors = parseWesternAuthors(beforeQuote);
          }
        } else {
          // æ²¡æœ‰å¼•å·ï¼Œå°è¯•æŒ‰å¥å·åˆ†å‰²
          // æ ¼å¼å¯èƒ½æ˜¯ï¼šAuthor. Title. arXiv:XXXX.XXXXX.
          const parts = cleanedForTitle.split(/\.\s+/).filter(p => p.trim());

          if (parts.length >= 2) {
            // ç¬¬ä¸€éƒ¨åˆ†æ˜¯ä½œè€…
            authors = parseWesternAuthors(parts[0]);

            // ç¬¬äºŒéƒ¨åˆ†æ˜¯æ ‡é¢˜ï¼ˆå¯èƒ½åŒ…å«å¤šä¸ªå¥å·åˆ†éš”çš„éƒ¨åˆ†ï¼‰
            // æ‰¾åˆ°ä¸æ˜¯ "arXiv" çš„éƒ¨åˆ†ä½œä¸ºæ ‡é¢˜
            for (let i = 1; i < parts.length; i++) {
              const part = parts[i].trim();
              if (part && !/^arXiv/i.test(part) && part.length > 5) {
                title = part;
                break;
              }
            }
          }
        }

        // æ¸…ç†æ ‡é¢˜
        if (title) {
          title = title
            .replace(/[,ï¼Œ.ã€‚]+$/, "")
            .replace(/\s+arXiv.*$/i, "")
            .trim();
        }

        return { title, journal, authors };
      }

      // è§£æä¸­æ–‡ä½œè€…
      function parseChineseAuthors(authorStr) {
        if (!authorStr) return [];

        // ç§»é™¤ "ç­‰" "et al"
        authorStr = authorStr
          .replace(/[,ï¼Œ]?\s*ç­‰\s*$/i, "")
          .replace(/et\s+al\.?/gi, "");

        // æŒ‰é€—å·å’Œ"å’Œ"åˆ†å‰²
        const parts = authorStr.split(/[,ï¼Œ]|\s+å’Œ\s+|\s+and\s+/i);

        return parts.map((p) => p.trim()).filter((p) => p && p.length >= 2);
      }

      function parseIEEEFormat(s) {
        let title = null,
          journal = null,
          authors = [],
          volume = null,
          issue = null;
        let firstPage = null,
          lastPage = null;

        const titleMatch = s.match(/"([^"]+)"/);
        if (titleMatch) {
          title = titleMatch[1].replace(/[,ï¼Œ.]$/, "").trim();

          const beforeQuote = s.slice(0, s.indexOf('"')).trim();
          authors = parseWesternAuthors(beforeQuote.replace(/[,ï¼Œ]\s*$/, ""));

          // æœŸåˆŠå’Œå·æœŸåœ¨å¼•å·å
          let afterQuote = s
            .slice(s.indexOf('"', s.indexOf('"') + 1) + 1)
            .trim();
          afterQuote = afterQuote.replace(/^[,ï¼Œ]\s*/, "");

          // æœŸåˆŠåï¼ˆvol. æˆ– no. æˆ–å¹´ä»½å‰çš„éƒ¨åˆ†ï¼‰
          const journalMatch = afterQuote.match(
            /^([^,]+?)(?:\s*[,ï¼Œ]\s*(?:vol\.|no\.|\d{4}))/i
          );
          if (journalMatch) {
            journal = journalMatch[1].trim();
          }
        }

        // vol. X
        const volMatch = s.match(/vol\.\s*(\d+)/i);
        if (volMatch) volume = volMatch[1];

        // no. X
        const noMatch = s.match(/no\.\s*(\d+)/i);
        if (noMatch) issue = noMatch[1];

        // pp. X-X æˆ– pp. X
        const ppMatch = s.match(/pp?\.\s*(\d+)\s*[-â€“â€”]?\s*(\d+)?/i);
        if (ppMatch) {
          firstPage = ppMatch[1];
          lastPage = ppMatch[2] || null;
        }

        return { title, journal, authors, volume, issue, firstPage, lastPage };
      }

      // ===== å¸¦å¼•å·æ ‡é¢˜æ ¼å¼ï¼ˆMLA, Chicago ç­‰ï¼‰=====
      function parseQuotedTitleFormat(s) {
        let title = null,
          journal = null,
          authors = [],
          volume = null,
          issue = null;
        let firstPage = null,
          lastPage = null;

        // æŸ¥æ‰¾å¼•å·ä¸­çš„æ ‡é¢˜
        // æ”¯æŒå¤šç§å¼•å·ï¼š""  ã€Œã€ ã€Šã€‹
        let titleMatch = s.match(/"([^"]{5,})"/);
        if (!titleMatch) titleMatch = s.match(/ã€Œ([^ã€]{5,})ã€/);
        if (!titleMatch) titleMatch = s.match(/ã€Š([^ã€‹]{5,})ã€‹/);

        if (titleMatch) {
          title = titleMatch[1].replace(/[,ï¼Œ.ã€‚]$/, "").trim();
          const quoteStart = s.indexOf(titleMatch[0]);
          const quoteEnd = quoteStart + titleMatch[0].length;

          // ä½œè€…ï¼ˆå¼•å·å‰ï¼‰
          let beforeQuote = s.slice(0, quoteStart).trim();
          beforeQuote = beforeQuote.replace(/[,ï¼Œ.ã€‚]\s*$/, "");
          if (beforeQuote) {
            authors = parseWesternAuthors(beforeQuote);
          }

          // å¼•å·åçš„å†…å®¹
          let afterQuote = s.slice(quoteEnd).trim();
          afterQuote = afterQuote.replace(/^[,ï¼Œ.ã€‚]\s*/, "");

          // å°è¯•å¤šç§æœŸåˆŠåŒ¹é…æ¨¡å¼
          // æ¨¡å¼1: Journal Vol, Pages (Year)
          const p1 = afterQuote.match(
            /^([A-Za-z][A-Za-z.\s&]+?)\s+(\d+)\s*[,ï¼Œ]\s*(\d+)\s*[-â€“â€”]\s*(\d+)\s*\(\d{4}\)/
          );
          // æ¨¡å¼2: Journal, Vol(Issue), Pages
          const p2 = afterQuote.match(
            /^([A-Za-z][A-Za-z.\s&,]+?)\s*[,ï¼Œ]\s*(\d+)\s*\(\s*(\d+)\s*\)\s*[,ï¼Œ:ï¼š]\s*(\d+)\s*[-â€“â€”]\s*(\d+)/
          );
          // æ¨¡å¼3: Journal Vol.Issue (Year): Pages
          const p3 = afterQuote.match(
            /^([A-Za-z][A-Za-z.\s&]+?)\s+(\d+)\.(\d+)\s*\(\d{4}\)\s*[:ï¼š]\s*(\d+)\s*[-â€“â€”]\s*(\d+)/
          );
          // æ¨¡å¼4: Journal (Year) Vol: Pages
          const p4 = afterQuote.match(
            /^([A-Za-z][A-Za-z.\s&]+?)\s*\(\d{4}\)\s*(\d+)\s*[:ï¼š]\s*(\d+)\s*[-â€“â€”]?\s*(\d+)?/
          );

          if (p1) {
            journal = p1[1].trim();
            volume = p1[2];
            firstPage = p1[3];
            lastPage = p1[4];
          } else if (p2) {
            journal = p2[1].trim();
            volume = p2[2];
            issue = p2[3];
            firstPage = p2[4];
            lastPage = p2[5];
          } else if (p3) {
            journal = p3[1].trim();
            volume = p3[2];
            issue = p3[3];
            firstPage = p3[4];
            lastPage = p3[5];
          } else if (p4) {
            journal = p4[1].trim();
            volume = p4[2];
            firstPage = p4[3];
            lastPage = p4[4];
          } else {
            // å°è¯•æå–æœŸåˆŠåï¼ˆåˆ°æ•°å­—æˆ–é€—å·ä¸ºæ­¢ï¼‰
            const jMatch = afterQuote.match(
              /^([A-Za-z][A-Za-z.\s&]+?)(?:\s+\d|[,ï¼Œ]|\()/
            );
            if (jMatch) {
              journal = jMatch[1].trim();
            }
          }
        }

        return { title, journal, authors, volume, issue, firstPage, lastPage };
      }

      // ===== MLA æ ¼å¼è§£æ =====
      // æ ¼å¼ï¼šLastname, Firstname. "Title." Journal, vol. X, no. X, Year, pp. X-X.
      function parseMLAFormat(s) {
        let title = null,
          journal = null,
          authors = [],
          volume = null,
          issue = null;
        let firstPage = null,
          lastPage = null;

        // æå–å¼•å·å†…çš„æ ‡é¢˜
        const titleMatch = s.match(/"([^"]+)"/);
        if (titleMatch) {
          title = titleMatch[1].trim();

          const quoteStart = s.indexOf(titleMatch[0]);
          const quoteEnd = quoteStart + titleMatch[0].length;

          // ä½œè€…ï¼ˆå¼•å·å‰ï¼‰
          let beforeQuote = s.slice(0, quoteStart).trim();
          beforeQuote = beforeQuote.replace(/[,ï¼Œ.ã€‚]\s*$/, "");
          if (beforeQuote) {
            authors = parseWesternAuthors(beforeQuote);
          }

          // å¼•å·åçš„å†…å®¹
          let afterQuote = s.slice(quoteEnd).trim();
          afterQuote = afterQuote.replace(/^[,ï¼Œ.ã€‚]\s*/, "");

          // MLA æ ¼å¼ï¼šJournal, vol. X, no. X, Year, pp. X-X.
          const mlaMatch = afterQuote.match(
            /^([^,]+),\s*vol\.\s*(\d+)(?:,\s*no\.\s*(\d+))?(?:,\s*\d{4})?(?:,\s*pp?\.\s*(\d+)\s*[-â€“â€”]\s*(\d+))?/i
          );
          if (mlaMatch) {
            journal = mlaMatch[1].trim();
            volume = mlaMatch[2];
            issue = mlaMatch[3] || null;
            firstPage = mlaMatch[4] || null;
            lastPage = mlaMatch[5] || null;
          } else {
            // å°è¯•æå–æœŸåˆŠå
            const jMatch = afterQuote.match(/^([^,]+)/);
            if (jMatch) {
              journal = jMatch[1].trim();
            }
          }
        }

        return { title, journal, authors, volume, issue, firstPage, lastPage };
      }

      // ===== Chicago æ ¼å¼è§£æ =====
      // æ ¼å¼ï¼šFirstname Lastname, "Title," Journal Vol, no. X (Year): Pages.
      function parseChicagoFormat(s) {
        let title = null,
          journal = null,
          authors = [],
          volume = null,
          issue = null;
        let firstPage = null,
          lastPage = null;

        // æå–å¼•å·å†…çš„æ ‡é¢˜
        const titleMatch = s.match(/"([^"]+)"/);
        if (titleMatch) {
          title = titleMatch[1].trim();

          const quoteStart = s.indexOf(titleMatch[0]);
          const quoteEnd = quoteStart + titleMatch[0].length;

          // ä½œè€…ï¼ˆå¼•å·å‰ï¼‰
          let beforeQuote = s.slice(0, quoteStart).trim();
          beforeQuote = beforeQuote.replace(/[,ï¼Œ]\s*$/, "");
          if (beforeQuote) {
            authors = parseWesternAuthors(beforeQuote);
          }

          // å¼•å·åçš„å†…å®¹
          let afterQuote = s.slice(quoteEnd).trim();
          afterQuote = afterQuote.replace(/^[,ï¼Œ]\s*/, "");

          // Chicago æ ¼å¼ï¼šJournal Vol, no. X (Year): Pages.
          const chicagoMatch = afterQuote.match(
            /^([A-Za-z][A-Za-z.\s&]+?)\s+(\d+)(?:,\s*no\.\s*(\d+))?\s*\(\d{4}\)\s*:\s*(\d+)\s*[-â€“â€”]?\s*(\d+)?/i
          );
          if (chicagoMatch) {
            journal = chicagoMatch[1].trim();
            volume = chicagoMatch[2];
            issue = chicagoMatch[3] || null;
            firstPage = chicagoMatch[4] || null;
            lastPage = chicagoMatch[5] || null;
          } else {
            // å°è¯•æå–æœŸåˆŠå
            const jMatch = afterQuote.match(/^([A-Za-z][A-Za-z.\s&]+?)(?:\s+\d|\()/);
            if (jMatch) {
              journal = jMatch[1].trim();
            }
          }
        }

        return { title, journal, authors, volume, issue, firstPage, lastPage };
      }

      // ===== APA æ ¼å¼è§£æ =====
      function parseAPAFormat(s) {
        let title = null,
          journal = null,
          authors = [],
          volume = null,
          issue = null;
        let firstPage = null,
          lastPage = null;

        // APA: Author, A. A., & Author, B. B. (Year). Title. Journal, Volume(Issue), Pages. doi
        // ä¸­æ–‡ APA: ä½œè€…å. (å¹´ä»½). æ ‡é¢˜. æœŸåˆŠå, å·(æœŸ), é¡µç . doi

        // å…ˆç§»é™¤æœ«å°¾çš„ URL/DOI é“¾æ¥
        const cleanedS = s.replace(/\s*https?:\/\/[^\s]+\s*$/i, '').trim();

        // æŸ¥æ‰¾å¹´ä»½ä½ç½® (Year). æ ¼å¼
        const yearMatch = cleanedS.match(/\((\d{4})\)\./);
        if (yearMatch) {
          const yearIdx = cleanedS.indexOf(yearMatch[0]);

          // ä½œè€…ï¼ˆå¹´ä»½å‰ï¼‰
          const authorPart = cleanedS.slice(0, yearIdx).trim();

          // æ£€æµ‹æ˜¯å¦æ˜¯ä¸­æ–‡ä½œè€…
          const isChinese = /^[\u4e00-\u9fa5]/.test(authorPart);
          if (isChinese) {
            // ä¸­æ–‡ä½œè€…ï¼šå¯èƒ½æ˜¯ "ä½œè€…å." æˆ– "ä½œè€…1, ä½œè€…2."
            const cleanAuthor = authorPart.replace(/\.\s*$/, '').trim();
            authors = cleanAuthor.split(/[,ï¼Œã€]\s*/).map(a => a.trim()).filter(Boolean);
          } else {
            authors = parseWesternAuthors(authorPart);
          }

          // å¹´ä»½åçš„å†…å®¹
          const afterYear = cleanedS.slice(yearIdx + yearMatch[0].length).trim();

          // æŒ‰å¥å·åˆ†å‰²ï¼ˆæ’é™¤ URLï¼‰
          // æ³¨æ„ï¼šä¸­æ–‡æ ‡é¢˜å¯èƒ½åŒ…å«è‹±æ–‡å¥å·ï¼Œéœ€è¦æ›´æ™ºèƒ½çš„åˆ†å‰²
          const parts = afterYear.split(/\.\s+/).filter(p => !p.startsWith('http'));

          if (parts.length >= 1) {
            // ç¬¬ä¸€éƒ¨åˆ†æ˜¯æ ‡é¢˜
            title = parts[0].trim();
          }

          if (parts.length >= 2) {
            // ç¬¬äºŒéƒ¨åˆ†æ˜¯æœŸåˆŠä¿¡æ¯
            const journalPart = parts[1];
            // Journal, Volume(Issue), Pages
            // æ”¯æŒä¸­æ–‡æœŸåˆŠåå’Œé¡µç æ ¼å¼
            const jMatch = journalPart.match(
              /^([^,ï¼Œ]+)[,ï¼Œ]\s*(\d+)(?:\((\d+)\))?[,ï¼Œ]?\s*(\d+)?\s*[-â€“â€”]?\s*(\d+)?/
            );
            if (jMatch) {
              journal = jMatch[1].trim();
              volume = jMatch[2];
              issue = jMatch[3] || null;
              firstPage = jMatch[4] || null;
              lastPage = jMatch[5] || null;
            } else {
              // åªæœ‰æœŸåˆŠå
              journal = journalPart.split(/[,ï¼Œ]/)[0].trim();
            }
          } else if (parts.length === 1) {
            // æ ‡é¢˜å’ŒæœŸåˆŠåœ¨åŒä¸€éƒ¨åˆ†ï¼Œå°è¯•åˆ†å‰²
            // æ ¼å¼å¯èƒ½æ˜¯ï¼šæ ‡é¢˜. æœŸåˆŠå, å·(æœŸ), é¡µç 
            const combinedMatch = parts[0].match(
              /^(.+?)[.ã€‚]\s*([^,ï¼Œ.ã€‚]+)[,ï¼Œ]\s*(\d+)\s*\(\s*(\d+)\s*\)[,ï¼Œ]?\s*(\d+)?/
            );
            if (combinedMatch) {
              title = combinedMatch[1].trim();
              journal = combinedMatch[2].trim();
              volume = combinedMatch[3];
              issue = combinedMatch[4];
              firstPage = combinedMatch[5] || null;
            }
          }
        } else {
          // æ²¡æœ‰æ ‡å‡†çš„å¹´ä»½æ ¼å¼ï¼Œå°è¯•é€šç”¨è§£æ
          return parseGenericFormat(s);
        }

        return { title, journal, authors, volume, issue, firstPage, lastPage };
      }

      // ===== Vancouver æ ¼å¼è§£æ =====
      function parseVancouverFormat(s) {
        let title = null,
          journal = null,
          authors = [],
          volume = null,
          issue = null;
        let firstPage = null,
          lastPage = null;

        // Vancouver: Author. Title. Journal. Year;Volume(Issue):Pages.
        // æˆ–: Author. Title. Journal. Year Month;Volume(Issue):Pages.

        // æŒ‰å¥å·åˆ†å‰²
        const parts = s.split(/\.\s+/);

        if (parts.length >= 2) {
          // ç¬¬ä¸€éƒ¨åˆ†ï¼šä½œè€…
          authors = parseWesternAuthors(parts[0]);

          // ç¬¬äºŒéƒ¨åˆ†ï¼šæ ‡é¢˜
          if (parts.length >= 2) {
            title = parts[1].trim();
          }

          // ç¬¬ä¸‰éƒ¨åˆ†åŠä¹‹åï¼šæœŸåˆŠå’Œå…ƒæ•°æ®
          if (parts.length >= 3) {
            // æ£€æŸ¥ parts[2] æ˜¯å¦åŒ…å«å¹´ä»½å’Œå·æœŸä¿¡æ¯
            const journalPart = parts[2];
            // Journal. Year;Vol(Issue):Pages æˆ– Journal. Year Month;Vol(Issue):Pages
            const jMatch = journalPart.match(
              /^([^.;]+?)(?:\.\s*|\s+)?(\d{4})(?:\s+[A-Za-z]{3,9})?\s*;\s*(\d+)(?:\((\d+)\))?:?\s*(\d+)?\s*[-â€“â€”]?\s*(\d+)?/
            );
            if (jMatch) {
              journal = jMatch[1].trim();
              volume = jMatch[3];
              issue = jMatch[4] || null;
              firstPage = jMatch[5] || null;
              lastPage = jMatch[6] || null;
            } else {
              // æœŸåˆŠåå¯èƒ½åœ¨ parts[2]ï¼Œå¹´ä»½/å·æœŸåœ¨ parts[3]
              journal = journalPart.split(/\s*[.;]\s*|\s+\d{4}/)[0].trim();

              // æ£€æŸ¥ parts[3] æ˜¯å¦æœ‰å¹´ä»½å’Œå·æœŸä¿¡æ¯
              if (parts.length >= 4) {
                const metaPart = parts[3];
                // Year;Vol(Issue):Pages æˆ– Year Month;Vol(Issue):Pages
                const metaMatch = metaPart.match(
                  /^(\d{4})(?:\s+[A-Za-z]{3,9})?\s*;\s*(\d+)(?:\((\d+)\))?:?\s*(\d+)?\s*[-â€“â€”]?\s*(\d+)?/
                );
                if (metaMatch) {
                  volume = metaMatch[2];
                  issue = metaMatch[3] || null;
                  firstPage = metaMatch[4] || null;
                  lastPage = metaMatch[5] || null;
                }
              }
            }
          }
        }

        // è¡¥å……æå–å·æœŸé¡µç ï¼ˆæ”¯æŒå¸¦æœˆä»½çš„æ ¼å¼ï¼‰
        const viMatch = s.match(/(\d{4})(?:\s+[A-Za-z]{3,9})?\s*;\s*(\d+)\s*(?:\(\s*(\d+)\s*\))?/);
        if (viMatch && !volume) {
          volume = viMatch[2];
          issue = viMatch[3] || null;
        }

        const ppMatch = s.match(/[:]\s*(\d+)\s*[-â€“â€”]\s*(\d+)/);
        if (ppMatch && !firstPage) {
          firstPage = ppMatch[1];
          lastPage = ppMatch[2];
        }

        return { title, journal, authors, volume, issue, firstPage, lastPage };
      }

      // ===== Harvard æ ¼å¼è§£æ =====
      // æ ¼å¼ï¼šSmith, J.A. (2020) Deep learning in medical imaging. Nature Medicine, 26(3), pp. 317-325.
      function parseHarvardFormat(s) {
        let title = null,
          journal = null,
          authors = [],
          volume = null,
          issue = null;
        let firstPage = null,
          lastPage = null;

        // Harvard: Author, A.A. (Year) Title. Journal, Volume(Issue), pp. Pages.
        // æˆ–: Author, A.A. (Year) 'Title', Journal, Volume(Issue), pp. Pages.

        // æŸ¥æ‰¾å¹´ä»½ä½ç½® (Year)
        const yearMatch = s.match(/\((\d{4})\)/);
        if (yearMatch) {
          const yearIdx = s.indexOf(yearMatch[0]);

          // ä½œè€…ï¼ˆå¹´ä»½å‰ï¼‰
          const authorPart = s.slice(0, yearIdx).trim();
          authors = parseWesternAuthors(authorPart);

          // å¹´ä»½åçš„å†…å®¹
          let afterYear = s.slice(yearIdx + yearMatch[0].length).trim();

          // æŸ¥æ‰¾æ ‡é¢˜ï¼ˆåˆ°ç¬¬ä¸€ä¸ªå¥å·æˆ–å¼•å·ç»“æŸï¼‰
          // æ”¯æŒå¸¦å¼•å·çš„æ ‡é¢˜
          const quotedTitle = afterYear.match(/^['"]([^'"]+)['"]/);
          if (quotedTitle) {
            title = quotedTitle[1].trim();
            afterYear = afterYear.slice(quotedTitle[0].length).trim();
            afterYear = afterYear.replace(/^[,.\s]+/, "");
          } else {
            // ä¸å¸¦å¼•å·çš„æ ‡é¢˜ï¼ˆåˆ°å¥å·ä¸ºæ­¢ï¼‰
            const titleEnd = afterYear.indexOf(". ");
            if (titleEnd !== -1) {
              title = afterYear.slice(0, titleEnd).trim();
              afterYear = afterYear.slice(titleEnd + 2).trim();
            }
          }

          // æœŸåˆŠä¿¡æ¯ï¼šJournal, Volume(Issue), pp. Pages
          const journalMatch = afterYear.match(
            /^([^,]+),\s*(\d+)(?:\((\d+)\))?(?:,\s*pp?\.\s*(\d+)[-â€“â€”]?(\d+)?)?/
          );
          if (journalMatch) {
            journal = journalMatch[1].trim();
            volume = journalMatch[2];
            issue = journalMatch[3] || null;
            firstPage = journalMatch[4] || null;
            lastPage = journalMatch[5] || null;
          } else {
            // åªæœ‰æœŸåˆŠå
            const jMatch = afterYear.match(/^([^,.\d]+)/);
            if (jMatch) {
              journal = jMatch[1].trim();
            }
          }
        } else {
          // æ²¡æœ‰æ ‡å‡†çš„å¹´ä»½æ ¼å¼ï¼Œå°è¯•é€šç”¨è§£æ
          return parseGenericFormat(s);
        }

        return { title, journal, authors, volume, issue, firstPage, lastPage };
      }

      // ===== Nature æ ¼å¼è§£æ =====
      // æ ¼å¼ï¼šSmith, J. A. Deep learning in medical imaging. Nature Medicine 26, 317â€“325 (2020).
      // æˆ–ï¼šSmith, J. A. et al. Title. Nature 600, 123-128 (2021).
      function parseNatureFormat(s) {
        let title = null,
          journal = null,
          authors = [],
          volume = null,
          issue = null;
        let firstPage = null,
          lastPage = null;

        // Nature æ ¼å¼ç‰¹å¾ï¼šæœŸåˆŠååç›´æ¥è·Ÿå·å·ï¼ˆæ— é€—å·ï¼‰ï¼Œé¡µç åè·Ÿå¹´ä»½
        // ç­–ç•¥ï¼šä»åå¾€å‰æ‰¾ "Journal Volume, Pages (Year)" æ¨¡å¼
        // æœŸåˆŠåé™åˆ¶ä¸º1-4ä¸ªå•è¯ï¼ˆæ¯ä¸ªå•è¯é¦–å­—æ¯å¤§å†™ï¼‰
        const naturePattern = s.match(
          /([A-Z][a-z]+(?:\s+[A-Z][a-z]+){0,3})\s+(\d+),\s*(\d+)[-â€“â€”](\d+)\s*\((\d{4})\)\s*\.?\s*$/
        );

        if (naturePattern) {
          journal = naturePattern[1].trim();
          volume = naturePattern[2];
          firstPage = naturePattern[3];
          lastPage = naturePattern[4];

          // æ‰¾åˆ°æœŸåˆŠååœ¨åŸå­—ç¬¦ä¸²ä¸­çš„ä½ç½®
          const journalIdx = s.lastIndexOf(journal);
          const beforeJournal = s.slice(0, journalIdx).trim();

          // ç§»é™¤æœ«å°¾çš„å¥å·
          const cleanBefore = beforeJournal.replace(/\.\s*$/, '');

          // æŒ‰å¥å·åˆ†å‰²ä½œè€…å’Œæ ‡é¢˜
          const lastDotIdx = cleanBefore.lastIndexOf(". ");
          if (lastDotIdx !== -1) {
            const authorPart = cleanBefore.slice(0, lastDotIdx);
            title = cleanBefore.slice(lastDotIdx + 2).trim();
            authors = parseWesternAuthors(authorPart.replace(/\s+et\s+al\.?/gi, ""));
          } else {
            // å°è¯•æ‰¾åˆ°ä½œè€…å’Œæ ‡é¢˜çš„åˆ†ç•Œ
            const parts = cleanBefore.split(/\.\s+/);
            if (parts.length >= 2) {
              authors = parseWesternAuthors(parts[0].replace(/\s+et\s+al\.?/gi, ""));
              title = parts.slice(1).join(". ").trim();
            }
          }
        } else {
          // å°è¯•å¦ä¸€ç§ Nature æ ¼å¼ï¼šæ²¡æœ‰é¡µç èŒƒå›´
          const naturePattern2 = s.match(
            /([A-Z][a-z]+(?:\s+[A-Z][a-z]+){0,3})\s+(\d+),\s*(\d+)\s*\((\d{4})\)\s*\.?\s*$/
          );
          if (naturePattern2) {
            journal = naturePattern2[1].trim();
            volume = naturePattern2[2];
            firstPage = naturePattern2[3];

            const journalIdx = s.lastIndexOf(journal);
            const beforeJournal = s.slice(0, journalIdx).trim();
            const cleanBefore = beforeJournal.replace(/\.\s*$/, '');

            const lastDotIdx = cleanBefore.lastIndexOf(". ");
            if (lastDotIdx !== -1) {
              const authorPart = cleanBefore.slice(0, lastDotIdx);
              title = cleanBefore.slice(lastDotIdx + 2).trim();
              authors = parseWesternAuthors(authorPart.replace(/\s+et\s+al\.?/gi, ""));
            }
          } else {
            return parseGenericFormat(s);
          }
        }

        return { title, journal, authors, volume, issue, firstPage, lastPage };
      }

      // ===== Science æ ¼å¼è§£æ =====
      // æ ¼å¼ï¼šJ. A. Smith, Deep learning in medical imaging. Science 368, 1234-1238 (2020).
      // æˆ–ï¼šJ. A. Smith et al., Title. Science 368, 1234 (2020).
      function parseScienceFormat(s) {
        let title = null,
          journal = null,
          authors = [],
          volume = null,
          issue = null;
        let firstPage = null,
          lastPage = null;

        // Science æ ¼å¼ä¸ Nature ç±»ä¼¼ï¼Œä½†ä½œè€…åé€šå¸¸æ˜¯ "F. Lastname" æ ¼å¼
        // åŒ¹é…æ¨¡å¼ï¼šJournal Volume, Pages (Year)
        const sciencePattern = s.match(
          /([A-Z][A-Za-z.\s&]+?)\s+(\d+),\s*(\d+)[-â€“â€”]?(\d+)?\s*\((\d{4})\)/
        );

        if (sciencePattern) {
          journal = sciencePattern[1].trim();
          volume = sciencePattern[2];
          firstPage = sciencePattern[3];
          lastPage = sciencePattern[4] || null;

          // æ‰¾åˆ°æœŸåˆŠååœ¨åŸå­—ç¬¦ä¸²ä¸­çš„ä½ç½®
          const journalIdx = s.indexOf(sciencePattern[0]);
          const beforeJournal = s.slice(0, journalIdx).trim();

          // Science æ ¼å¼ï¼šä½œè€…, æ ‡é¢˜.
          // æŸ¥æ‰¾æœ€åä¸€ä¸ªå¥å·ï¼ˆæ ‡é¢˜ç»“å°¾ï¼‰
          const lastDotIdx = beforeJournal.lastIndexOf(".");
          if (lastDotIdx !== -1) {
            const beforeDot = beforeJournal.slice(0, lastDotIdx).trim();

            // æŸ¥æ‰¾ä½œè€…å’Œæ ‡é¢˜çš„åˆ†ç•Œï¼ˆé€šå¸¸æ˜¯é€—å·åè·Ÿå¤§å†™å­—æ¯å¼€å¤´çš„æ ‡é¢˜ï¼‰
            // æ¨¡å¼ï¼šAuthors, Title
            const commaMatch = beforeDot.match(/^(.+?),\s+([A-Z][^,].*)$/);
            if (commaMatch) {
              authors = parseWesternAuthors(commaMatch[1].replace(/\s+et\s+al\.?/gi, ""));
              title = commaMatch[2].trim();
            } else {
              // å°è¯•æŒ‰å¥å·åˆ†å‰²
              const parts = beforeDot.split(/\.\s+/);
              if (parts.length >= 2) {
                authors = parseWesternAuthors(parts[0].replace(/\s+et\s+al\.?/gi, ""));
                title = parts.slice(1).join(". ").trim();
              } else {
                title = beforeDot;
              }
            }
          }
        } else {
          return parseGenericFormat(s);
        }

        return { title, journal, authors, volume, issue, firstPage, lastPage };
      }

      // ===== é€šç”¨æ™ºèƒ½è§£æ =====
      function parseGenericFormat(s) {
        let title = null,
          journal = null,
          authors = [],
          volume = null,
          issue = null;
        let firstPage = null,
          lastPage = null;

        // 0. å…ˆç§»é™¤æœ«å°¾çš„ URL/DOI é“¾æ¥
        const cleanedS = s.replace(/\s*https?:\/\/[^\s]+\s*$/i, '').trim();

        // 0.1 æ£€æµ‹æ˜¯å¦æ˜¯"æœŸåˆŠè¡Œ"æ ¼å¼ï¼ˆå¦‚ APA å¼•ç”¨çš„ç¬¬äºŒè¡Œï¼‰
        // æ ¼å¼ï¼šJournal Name, Volume(Issue), Pages
        const journalLineMatch = cleanedS.match(
          /^([A-Z][A-Za-z\s&]+),\s*(\d+)\s*\((\d+)\)\s*,\s*(\d+)\s*[-â€“â€”]\s*(\d+)/
        );
        if (journalLineMatch) {
          journal = journalLineMatch[1].trim();
          volume = journalLineMatch[2];
          issue = journalLineMatch[3];
          firstPage = journalLineMatch[4];
          lastPage = journalLineMatch[5];
          // è¿™ç§æƒ…å†µä¸‹æ²¡æœ‰æ ‡é¢˜å’Œä½œè€…
          return { title, journal, authors, volume, issue, firstPage, lastPage };
        }

        // 1. å…ˆæå–æœŸåˆŠç¼©å†™æ¨¡å¼ï¼ˆå¦‚ J. Comput. Phys. 225ï¼‰
        // åŒ¹é…ï¼šå¤šä¸ª"å•è¯+ç‚¹"ç»„åˆï¼Œåè·Ÿå·å·
        const journalAbbrMatch = cleanedS.match(
          /([A-Z][a-z]*\.(?:\s*[A-Z][a-z]*\.)+)\s*(\d+)\s*(?:\((\d+)\))?/
        );
        if (journalAbbrMatch) {
          journal = journalAbbrMatch[1].trim();
          volume = journalAbbrMatch[2];
          issue = journalAbbrMatch[3] || null;
        }

        // 2. æ‰¾åˆ°æœŸåˆŠåœ¨åŸå­—ç¬¦ä¸²ä¸­çš„ä½ç½®ï¼Œæå–æœŸåˆŠä¹‹å‰çš„éƒ¨åˆ†
        let beforeJournal = cleanedS;
        if (journal) {
          const journalIdx = cleanedS.indexOf(journal);
          if (journalIdx > 0) {
            beforeJournal = cleanedS.slice(0, journalIdx).trim();
            // ç§»é™¤æœ«å°¾çš„å¥å·
            beforeJournal = beforeJournal.replace(/\.\s*$/, "");
          }
        }

        // 3. åœ¨ beforeJournal ä¸­æ‰¾åˆ°ä½œè€…å’Œæ ‡é¢˜çš„åˆ†ç•Œ
        // ç­–ç•¥ï¼šæ‰¾åˆ° "X. " åé¢è·Ÿç€ "å¤§å†™å­—æ¯å¼€å¤´çš„é•¿å•è¯ï¼ˆ>=4å­—æ¯ï¼‰" çš„ä½ç½®
        // è¿™é€šå¸¸æ˜¯æ ‡é¢˜çš„å¼€å§‹ï¼ˆä½œè€…ç¼©å†™åè·Ÿæ ‡é¢˜é¦–è¯ï¼‰
        const titleStartMatch = beforeJournal.match(
          /([A-Z])\.\s+([A-Z][a-z]{3,})/
        );
        if (titleStartMatch) {
          const matchIdx = beforeJournal.indexOf(titleStartMatch[0]);
          // ä½œè€…éƒ¨åˆ†ï¼šä»å¼€å¤´åˆ°åŒ¹é…ä½ç½® + å•å­—æ¯ + ç‚¹
          const authorPart = beforeJournal
            .slice(0, matchIdx + titleStartMatch[1].length + 1)
            .trim();
          // æ ‡é¢˜éƒ¨åˆ†ï¼šä»é•¿å•è¯å¼€å§‹
          const titlePart = beforeJournal
            .slice(matchIdx + titleStartMatch[1].length + 2)
            .trim();

          authors = parseWesternAuthors(authorPart);
          title = titlePart;
        } else {
          // å›é€€ï¼šæŒ‰ç¬¬ä¸€ä¸ªå¥å·+ç©ºæ ¼åˆ†å‰²
          const firstDotIdx = beforeJournal.indexOf(". ");
          if (firstDotIdx > 0) {
            authors = parseWesternAuthors(beforeJournal.slice(0, firstDotIdx));
            title = beforeJournal.slice(firstDotIdx + 2);
          } else {
            // æ²¡æœ‰æœŸåˆŠçš„æƒ…å†µï¼Œä½¿ç”¨åŸæ¥çš„åˆ†å‰²é€»è¾‘
            const parts = cleanedS.split(/\.\s+/).filter(p => !p.startsWith('http'));
            if (parts.length >= 2) {
              if (looksLikeAuthors(parts[0])) {
                authors = parseWesternAuthors(parts[0]);
                title = parts[1];
              } else {
                title = parts[0];
              }
              // å°è¯•ä»åç»­éƒ¨åˆ†æå–æœŸåˆŠ
              if (!journal && parts.length >= 3) {
                const jMatch = parts[2].match(/^([^,\d]+)/);
                if (jMatch && !jMatch[1].startsWith('http')) {
                  journal = jMatch[1].trim();
                }
              }
            } else {
              title = beforeJournal;
            }
          }
        }

        return { title, journal, authors, volume, issue, firstPage, lastPage };
      }

      // æŒ‰é€—å·åˆ†å‰²çš„æ ¼å¼
      function parseCommaSeparatedFormat(s) {
        let title = null,
          journal = null,
          authors = [],
          volume = null,
          issue = null;
        let firstPage = null,
          lastPage = null;

        const parts = s.split(/,\s*/);

        // ç¬¬ä¸€éƒ¨åˆ†é€šå¸¸æ˜¯ä½œè€…æˆ–æ ‡é¢˜
        if (parts.length >= 1) {
          if (looksLikeAuthors(parts[0])) {
            authors = parseWesternAuthors(parts[0]);
            if (parts.length >= 2) title = parts[1];
          } else {
            title = parts[0];
          }
        }

        return { title, journal, authors, volume, issue, firstPage, lastPage };
      }

      // åˆ¤æ–­æ˜¯å¦åƒä½œè€…
      function looksLikeAuthors(s) {
        if (!s) return false;
        // åŒ…å« "and" æˆ–å¤šä¸ªé€—å·åˆ†éš”çš„åå­—
        if (/\s+and\s+/i.test(s)) return true;
        // åŒ…å«ç¼©å†™å A. B.
        if (/[A-Z]\.\s*[A-Z]?\.?/.test(s)) return true;
        // å§“, å æ ¼å¼
        if (/^[A-Z][a-z]+,\s*[A-Z]/.test(s)) return true;
        // ä¸­æ–‡ä½œè€…
        if (/^[\u4e00-\u9fa5]{2,4}(?:[,ï¼Œ][\u4e00-\u9fa5]{2,4})*/.test(s))
          return true;
        return false;
      }

      // åˆ¤æ–­æ˜¯å¦åƒæœŸåˆŠ
      function looksLikeJournal(s) {
        if (!s) return false;
        // åŒ…å«å…¸å‹æœŸåˆŠè¯æ±‡
        if (
          /\b(Journal|Review|Letters|Proceedings|Trans|Conf|Ann|Sci|Research)\b/i.test(
            s
          )
        )
          return true;
        // åŒ…å«ç¼©å†™ (å¸¦ç‚¹çš„å•è¯)
        if (/[A-Z][a-z]*\.\s*[A-Z]/.test(s)) return true;
        // åŒ…å«å·æœŸä¿¡æ¯
        if (/\d+\s*\(\d+\)/.test(s)) return true;
        return false;
      }

      // åˆ†æå¥å­ç±»å‹
      function analyzePart(s) {
        if (looksLikeAuthors(s)) return { type: "author", content: s };
        if (looksLikeJournal(s)) return { type: "journal", content: s };
        return { type: "unknown", content: s };
      }

      // è§£æè¥¿æ–¹ä½œè€…å
      function parseWesternAuthors(s) {
        if (!s) return [];

        // æ¸…ç†
        s = s
          .replace(/et\s+al\.?/gi, "")
          .replace(/\s*&\s*/g, " and ")
          .replace(/[,ï¼Œ]\s*$/, "")
          .trim();

        // æŒ‰ and/é€—å· åˆ†å‰²
        // æ³¨æ„ï¼šé€—å·å¯èƒ½åœ¨åå­—å†…éƒ¨ï¼ˆLastname, Firstnameï¼‰ï¼Œéœ€è¦ç‰¹æ®Šå¤„ç†

        let authors = [];

        // æ£€æµ‹æ˜¯å¦æ˜¯ "Lastname, Firstname" æ ¼å¼
        if (/^[A-Z][a-z]+,\s*[A-Z]/.test(s)) {
          // å…ˆæŒ‰ and åˆ†å‰²
          const andParts = s.split(/\s+and\s+/i);
          for (const part of andParts) {
            // æ¯ä¸ªéƒ¨åˆ†å¯èƒ½æœ‰å¤šä¸ªä½œè€…ç”¨åˆ†å·åˆ†éš”
            const semicolonParts = part.split(/;\s*/);
            for (const sp of semicolonParts) {
              // å¤„ç† "Zhang, J., Liu, P., Zhang, F, Song, Q" è¿™ç§æ ¼å¼
              // ç­–ç•¥ï¼šåŒ¹é… "Lastname, Initial(s)." æˆ– "Lastname, Initial(s)" æ¨¡å¼
              // ä½¿ç”¨æ­£åˆ™åŒ¹é…æ¯ä¸ªä½œè€…
              const authorPattern = /([A-Z][a-z]+),\s*([A-Z][A-Za-z.]*(?:\s+[A-Z][A-Za-z.]*)*)/g;
              let match;
              let lastIndex = 0;
              let foundAuthors = [];

              while ((match = authorPattern.exec(sp)) !== null) {
                foundAuthors.push(`${match[1]}, ${match[2]}`);
                lastIndex = authorPattern.lastIndex;
              }

              if (foundAuthors.length > 0) {
                authors.push(...foundAuthors);
              } else if (sp.trim()) {
                authors.push(sp.trim());
              }
            }
          }
        } else {
          // æ™®é€šæ ¼å¼ï¼šæŒ‰ and å’Œé€—å·åˆ†å‰²
          authors = s
            .split(/,\s*(?:and\s+)?|\s+and\s+/i)
            .map((a) => a.trim())
            .filter(Boolean);
        }

        return authors.filter((a) => a.length >= 2);
      }

      // æå–å·æœŸé¡µç ï¼ˆé€šç”¨ï¼‰
      function extractVolumeIssuePage(s) {
        let volume = null,
          issue = null,
          firstPage = null,
          lastPage = null;

        // æ£€æµ‹æ˜¯å¦æ˜¯ arXiv å¼•ç”¨ï¼ˆè·³è¿‡ arXiv ID çš„å·æœŸæå–ï¼‰
        const isArxivRef = /arXiv/i.test(s) || /arxiv\.org/i.test(s);

        // æ¨¡å¼1: Vol(Issue) - æ’é™¤ arXiv ID æ ¼å¼
        const vi1 = s.match(/(\d+)\s*\(\s*(\d+)\s*\)/);
        if (vi1 && !isArxivRef) {
          volume = vi1[1];
          issue = vi1[2];
        }

        // æ¨¡å¼2: vol. X, no. Y
        const vi2 = s.match(/vol\.\s*(\d+)/i);
        if (vi2 && !volume) volume = vi2[1];
        const vi3 = s.match(/no\.\s*(\d+)/i);
        if (vi3) issue = vi3[1];

        // æ¨¡å¼3: Vol.Issue - æ’é™¤ arXiv ID æ ¼å¼ï¼ˆå¦‚ 1706.03762ï¼‰
        if (!isArxivRef) {
          const vi4 = s.match(/\b(\d+)\.(\d+)\b/);
          if (vi4 && !volume) {
            // æ’é™¤ arXiv ID æ ¼å¼ï¼ˆ4ä½æ•°.4-5ä½æ•°ï¼‰
            const p1 = vi4[1], p2 = vi4[2];
            if (!(p1.length === 4 && p2.length >= 4 && p2.length <= 5)) {
              volume = p1;
              issue = p2;
            }
          }
        }

        // é¡µç æ¨¡å¼
        // pp. X-Y æˆ– p. X
        const pp1 = s.match(/pp?\.\s*(\d+)\s*[-â€“â€”]\s*(\d+)/i);
        if (pp1) {
          firstPage = pp1[1];
          lastPage = pp1[2];
        }

        // : X-Y
        const pp2 = s.match(/[:ï¼š]\s*(\d+)\s*[-â€“â€”]\s*(\d+)/);
        if (pp2 && !firstPage) {
          firstPage = pp2[1];
          lastPage = pp2[2];
        }

        // é€šç”¨ X-Y (æ’é™¤å¹´ä»½èŒƒå›´)
        const pp3 = s.match(/\b(\d{1,5})\s*[-â€“â€”]\s*(\d{1,5})\b/);
        if (pp3 && !firstPage) {
          const n1 = parseInt(pp3[1], 10);
          const n2 = parseInt(pp3[2], 10);
          // æ’é™¤å¹´ä»½èŒƒå›´ (1900-2100)
          if (!(n1 >= 1900 && n1 <= 2100 && n2 >= 1900 && n2 <= 2100)) {
            firstPage = pp3[1];
            lastPage = pp3[2];
          }
        }

        return { volume, issue, firstPage, lastPage };
      }

      // æ¸…ç†æ ‡é¢˜
      function cleanTitle(title) {
        if (!title) return null;
        return title
          .replace(/\s+/g, " ")
          .replace(/^["'"ã€Œã€Š]+/, "")
          .replace(/["'"ã€ã€‹]+$/, "")
          .replace(/[,ï¼Œ.ã€‚]+$/, "")
          .trim();
      }

      // æ¸…ç†æœŸåˆŠå
      function cleanJournal(journal) {
        if (!journal) return null;
        return journal
          .replace(/\s+/g, " ")
          .replace(/[,ï¼Œ.ã€‚:ï¼š]+$/, "")
          .replace(/^\s*in\s+/i, "")
          .trim();
      }

      // æ¸…ç†ä½œè€…åˆ—è¡¨
      function cleanAuthors(authors) {
        return authors
          .map((a) => a.replace(/[,ï¼Œ.ã€‚]+$/, "").trim())
          .filter((a) => a && a.length >= 2 && !/^\d+$/.test(a));
      }

      // æ ‡é¢˜å›é€€æå–
      function extractTitleFallback(s, authors, journal) {
        // ç§»é™¤ä½œè€…å’ŒæœŸåˆŠéƒ¨åˆ†ï¼Œå‰©ä¸‹çš„å¯èƒ½æ˜¯æ ‡é¢˜
        let remaining = s;

        for (const author of authors) {
          remaining = remaining.replace(author, "");
        }
        if (journal) {
          remaining = remaining.replace(journal, "");
        }

        // ç§»é™¤å¹´ä»½ã€å·æœŸã€é¡µç 
        remaining = remaining
          .replace(/\(?\d{4}\)?/g, "")
          .replace(/\d+\s*\(\d+\)/g, "")
          .replace(/\d+\s*[-â€“â€”]\s*\d+/g, "")
          .replace(/vol\.\s*\d+/gi, "")
          .replace(/no\.\s*\d+/gi, "")
          .replace(/pp?\.\s*\d+/gi, "");

        // æ¸…ç†æ ‡ç‚¹å’Œå¤šä½™ç©ºæ ¼
        remaining = remaining
          .replace(/[,ï¼Œ.ã€‚;ï¼›:ï¼š\[\]()ï¼ˆï¼‰]+/g, " ")
          .replace(/\s+/g, " ")
          .trim();

        // å¦‚æœå‰©ä½™å†…å®¹è¶³å¤Ÿé•¿ï¼Œå¯èƒ½æ˜¯æ ‡é¢˜
        if (remaining.length >= 15) {
          return remaining;
        }

        return null;
      }

      /** ---------- API æŸ¥è¯¢ ---------- */
      async function queryOpenAlex(p, mailto, isArxiv) {
        let url = new URL("https://api.openalex.org/works");
        url.searchParams.set("per-page", "10");  // å‡å°‘è¿”å›æ•°é‡
        if (mailto) url.searchParams.set("mailto", mailto);

        if (p.doi) {
          url.searchParams.set("filter", `doi:${p.doi.toLowerCase()}`);
        } else {
          url.searchParams.set("search", p.title || p.raw);
          if (isArxiv) {
            // arXiv å¼•ç”¨ï¼šä½¿ç”¨æ¥æºè¿‡æ»¤å™¨ï¼Œä¸ä½¿ç”¨å¹´ä»½è¿‡æ»¤ï¼ˆé¢„å°æœ¬å¯èƒ½æ›´æ–°ï¼‰
            url.searchParams.set("filter", "indexed_in:arxiv");
          } else if (p.year) {
            url.searchParams.set("filter", `publication_year:${p.year}`);
          }
        }

        const r = await fetch(url.toString());
        if (!r.ok) throw new Error("OpenAlex è¯·æ±‚å¤±è´¥: " + r.status);
        return await r.json();
      }

      async function queryCrossref(p, mailto, isArxiv) {
        // arXiv å¼•ç”¨è·³è¿‡ Crossref æŸ¥è¯¢ï¼ˆCrossref å¯¹ arXiv é¢„å°æœ¬æ”¶å½•ä¸å…¨ï¼‰
        if (isArxiv && !p.doi) {
          return { message: { items: [] } };
        }

        // âœ… DOIï¼šç²¾ç¡®å–å›
        if (p.doi) {
          const doiEnc = encodeURIComponent(p.doi.toLowerCase());
          const url = new URL(`https://api.crossref.org/works/${doiEnc}`);
          if (mailto) url.searchParams.set("mailto", mailto);

          const r = await fetch(url.toString(), {
            headers: { Accept: "application/json" },
          });
          if (!r.ok) throw new Error("Crossref DOI ç²¾ç¡®æŸ¥è¯¢å¤±è´¥: " + r.status);

          const one = await r.json();
          // ç»Ÿä¸€æˆä½ ç°æœ‰çš„è¿”å›ç»“æ„ï¼šcr.message.items
          return { message: { items: [one.message] } };
        }

        // åŸæ¥çš„ï¼šæ¨¡ç³Šæ£€ç´¢
        let url = new URL("https://api.crossref.org/works");
        url.searchParams.set("rows", "15");  // å‡å°‘è¿”å›æ•°é‡
        if (mailto) url.searchParams.set("mailto", mailto);

        if (p.title) url.searchParams.set("query.bibliographic", p.title);
        if (p.authors && p.authors[0])
          url.searchParams.set("query.author", p.authors[0]);
        if (p.year)
          url.searchParams.set(
            "filter",
            `from-pub-date:${p.year}-01-01,until-pub-date:${p.year}-12-31`
          );

        const r = await fetch(url.toString(), {
          headers: { Accept: "application/json" },
        });
        if (!r.ok) throw new Error("Crossref è¯·æ±‚å¤±è´¥: " + r.status);
        return await r.json();
      }

      /** ---------- æ‰“åˆ† ---------- */
      // arXiv ä¸“ç”¨è¯„åˆ†ï¼ˆç§»é™¤æœŸåˆŠã€å·æœŸé¡µç ï¼‰
      function scoreOpenAlexWorkArxiv(p, w) {
        const t = jaccard(p.title, w.title || "");
        const y = p.year && w.publication_year === p.year ? 1 : 0;
        const workAuthors = w.authorships || [];
        const a = authorSimilarity(p.authors, workAuthors);

        // arXiv æƒé‡ï¼šæ ‡é¢˜ 60%ï¼Œä½œè€… 25%ï¼Œå¹´ä»½ 15%
        const total = 0.60 * t + 0.25 * a + 0.15 * y;

        return {
          total,
          details: {
            title: { score: t, weight: 0.60, weighted: 0.60 * t },
            author: { score: a, weight: 0.25, weighted: 0.25 * a },
            year: { score: y, weight: 0.15, weighted: 0.15 * y },
          },
        };
      }

      function scoreOpenAlexWork(p, w) {
        const t = jaccard(p.title, w.title || "");
        const y = p.year && w.publication_year === p.year ? 1 : 0;
        const j = journalSimilarity(
          p.journal,
          w.primary_location?.source?.display_name || ""
        );
        const v =
          p.volume &&
          w.biblio?.volume &&
          String(w.biblio.volume) === String(p.volume)
            ? 1
            : 0;
        const i =
          p.issue &&
          w.biblio?.issue &&
          String(w.biblio.issue) === String(p.issue)
            ? 1
            : 0;
        const fp =
          p.firstPage &&
          w.biblio?.first_page &&
          String(w.biblio.first_page) === String(p.firstPage)
            ? 1
            : 0;
        const lp =
          p.lastPage &&
          w.biblio?.last_page &&
          String(w.biblio.last_page) === String(p.lastPage)
            ? 1
            : 0;

        const workAuthors = w.authorships || [];
        const a = authorSimilarity(p.authors, workAuthors);

        const total =
          0.45 * t +
          0.15 * a +
          0.12 * j +
          0.1 * y +
          0.06 * v +
          0.04 * i +
          0.04 * fp +
          0.04 * lp;

        // è¿”å›è¯¦ç»†è¯„åˆ†ä¿¡æ¯
        return {
          total,
          details: {
            title: { score: t, weight: 0.45, weighted: 0.45 * t },
            author: { score: a, weight: 0.15, weighted: 0.15 * a },
            journal: { score: j, weight: 0.12, weighted: 0.12 * j },
            year: { score: y, weight: 0.1, weighted: 0.1 * y },
            volume: { score: v, weight: 0.06, weighted: 0.06 * v },
            issue: { score: i, weight: 0.04, weighted: 0.04 * i },
            firstPage: { score: fp, weight: 0.04, weighted: 0.04 * fp },
            lastPage: { score: lp, weight: 0.04, weighted: 0.04 * lp },
          },
        };
      }

      // arXiv ä¸“ç”¨ Crossref è¯„åˆ†ï¼ˆç§»é™¤æœŸåˆŠã€å·æœŸé¡µç ï¼‰
      function scoreCrossrefItemArxiv(p, it) {
        const title = it.title && it.title[0] ? it.title[0] : "";
        const issuedYear = it.issued?.["date-parts"]?.[0]?.[0];

        const t = jaccard(p.title, title);
        const y = p.year && issuedYear === p.year ? 1 : 0;
        const crAuthors = it.author || [];
        const a = authorSimilarity(p.authors, crAuthors);

        // arXiv æƒé‡ï¼šæ ‡é¢˜ 60%ï¼Œä½œè€… 25%ï¼Œå¹´ä»½ 15%
        const total = 0.60 * t + 0.25 * a + 0.15 * y;

        return {
          total,
          details: {
            title: { score: t, weight: 0.60, weighted: 0.60 * t },
            author: { score: a, weight: 0.25, weighted: 0.25 * a },
            year: { score: y, weight: 0.15, weighted: 0.15 * y },
          },
        };
      }

      function scoreCrossrefItem(p, it) {
        const title = it.title && it.title[0] ? it.title[0] : "";
        const container =
          it["container-title"] && it["container-title"][0]
            ? it["container-title"][0]
            : "";
        const issuedYear = it.issued?.["date-parts"]?.[0]?.[0];

        const t = jaccard(p.title, title);
        const j = journalSimilarity(p.journal, container);
        const y = p.year && issuedYear === p.year ? 1 : 0;

        const crAuthors = it.author || [];
        const a = authorSimilarity(p.authors, crAuthors);

        const v =
          p.volume && it.volume && String(it.volume) === String(p.volume)
            ? 1
            : 0;
        const i =
          p.issue && it.issue && String(it.issue) === String(p.issue) ? 1 : 0;
        const page = it.page || "";
        const fp = p.firstPage && page.includes(p.firstPage) ? 1 : 0;
        const lp = p.lastPage && page.includes(p.lastPage) ? 1 : 0;

        const total =
          0.45 * t +
          0.15 * a +
          0.12 * j +
          0.1 * y +
          0.06 * v +
          0.04 * i +
          0.04 * fp +
          0.04 * lp;

        // è¿”å›è¯¦ç»†è¯„åˆ†ä¿¡æ¯
        return {
          total,
          details: {
            title: { score: t, weight: 0.45, weighted: 0.45 * t },
            author: { score: a, weight: 0.15, weighted: 0.15 * a },
            journal: { score: j, weight: 0.12, weighted: 0.12 * j },
            year: { score: y, weight: 0.1, weighted: 0.1 * y },
            volume: { score: v, weight: 0.06, weighted: 0.06 * v },
            issue: { score: i, weight: 0.04, weighted: 0.04 * i },
            firstPage: { score: fp, weight: 0.04, weighted: 0.04 * fp },
            lastPage: { score: lp, weight: 0.04, weighted: 0.04 * lp },
          },
        };
      }

      function getVerdict(score) {
        if (score >= 0.78)
          return { level: "high", text: "é«˜å¯ä¿¡", desc: "å¼ºåŒ¹é…" };
        if (score >= 0.55)
          return { level: "medium", text: "ä¸­å¯ä¿¡", desc: "éœ€æ ¸å¯¹" };
        return { level: "low", text: "ä½å¯ä¿¡", desc: "å¯èƒ½ä¼ªé€ " };
      }

      /** ---------- å•æ¡æ ¡éªŒ ---------- */
      async function verifySingle(raw, mailto) {
        // æ£€æŸ¥æ˜¯å¦å¯ç”¨ AI è§£æ
        const useAi = localStorage.getItem(AI_ENABLED_KEY) === "true";
        let p;

        if (useAi) {
          // å°è¯• AI è§£æ
          p = await parseWithAI(raw);
          if (!p) {
            // AI è§£æå¤±è´¥ï¼Œå›é€€åˆ°è§„åˆ™è§£æ
            p = parseCitation(raw);
          }
        } else {
          p = parseCitation(raw);
        }

        // å¤–éƒ¨æ£€æµ‹æ˜¯å¦æ˜¯ arXiv ç›¸å…³å¼•ç”¨ï¼ˆä¼ å…¥ä¸¤ä¸ª query å‡½æ•°ï¼‰
        const isArxiv = /arXiv/i.test(raw) || /\d{4}\.\d{4,5}/.test(raw);

        const [oa, cr] = await Promise.all([
          queryOpenAlex(p, mailto, isArxiv).catch((e) => ({ __error: e.message })),
          queryCrossref(p, mailto, isArxiv).catch((e) => ({ __error: e.message })),
        ]);

        const oaItems = oa?.results || [];
        const crItems = cr?.message?.items || [];

        // æ ¹æ®æ˜¯å¦æ˜¯ arXiv é€‰æ‹©è¯„åˆ†å‡½æ•°
        const oaScoreFn = isArxiv ? scoreOpenAlexWorkArxiv : scoreOpenAlexWork;
        const crScoreFn = isArxiv ? scoreCrossrefItemArxiv : scoreCrossrefItem;

        const oaBest = pickBest(oaItems, (w) => oaScoreFn(p, w));
        const crBest = pickBest(crItems, (it) => crScoreFn(p, it));

        const oaScore = oaBest?.best ? oaBest.bestScore : 0;
        const crScore = crBest?.best ? crBest.bestScore : 0;

        // åˆ¤æ–­æœ‰æ•ˆæ•°æ®æºæ•°é‡ï¼ˆå¾—åˆ† > 0.1 è§†ä¸ºæœ‰æ•ˆåŒ¹é…ï¼‰
        const oaValid = oaScore > 0.1;
        const crValid = crScore > 0.1;

        let combined;
        let combinedDetails;

        if (oaValid && crValid) {
          // ä¸¤ä¸ªæ•°æ®æºéƒ½æœ‰åŒ¹é…ï¼šåŠ æƒè®¡ç®—
          combined = Math.max(oaScore, crScore) * 0.6 + Math.min(oaScore, crScore) * 0.4;
          combinedDetails = {
            openAlex: {
              score: oaScore,
              weight: oaScore >= crScore ? 0.6 : 0.4,
              weighted: oaScore >= crScore ? oaScore * 0.6 : oaScore * 0.4,
            },
            crossref: {
              score: crScore,
              weight: crScore > oaScore ? 0.6 : 0.4,
              weighted: crScore > oaScore ? crScore * 0.6 : crScore * 0.4,
            },
          };
        } else if (oaValid) {
          // åªæœ‰ OpenAlex æœ‰åŒ¹é…ï¼šç›´æ¥ä½¿ç”¨è¯¥åˆ†æ•°
          combined = oaScore;
          combinedDetails = {
            openAlex: { score: oaScore, weight: 1.0, weighted: oaScore },
            crossref: { score: crScore, weight: 0, weighted: 0 },
          };
        } else if (crValid) {
          // åªæœ‰ Crossref æœ‰åŒ¹é…ï¼šç›´æ¥ä½¿ç”¨è¯¥åˆ†æ•°
          combined = crScore;
          combinedDetails = {
            openAlex: { score: oaScore, weight: 0, weighted: 0 },
            crossref: { score: crScore, weight: 1.0, weighted: crScore },
          };
        } else {
          // ä¸¤ä¸ªéƒ½æ²¡æœ‰æœ‰æ•ˆåŒ¹é…
          combined = Math.max(oaScore, crScore);
          combinedDetails = {
            openAlex: { score: oaScore, weight: 0.5, weighted: oaScore * 0.5 },
            crossref: { score: crScore, weight: 0.5, weighted: crScore * 0.5 },
          };
        }

        return {
          raw,
          parsed: p,
          oaBest,
          crBest,
          oaScore,
          crScore,
          combined,
          combinedDetails,
          verdict: getVerdict(combined),
          isArxiv,  // æ ‡è®°æ˜¯å¦ä¸º arXiv å¼•ç”¨
        };
      }

      /** ---------- UI æ¸²æŸ“ ---------- */
      // ç”Ÿæˆè¯„åˆ†è¯¦æƒ… tooltip HTML
      function renderScoreTooltip(details) {
        if (!details) return "";

        const labels = {
          title: "æ ‡é¢˜",
          author: "ä½œè€…",
          journal: "æœŸåˆŠ",
          year: "å¹´ä»½",
          volume: "å·å·",
          issue: "æœŸå·",
          firstPage: "é¦–é¡µ",
          lastPage: "æœ«é¡µ",
        };

        const getScoreClass = (score) => {
          if (score >= 0.8) return "good";
          if (score >= 0.5) return "medium";
          return "bad";
        };

        let rows = "";
        let total = 0;
        for (const [key, val] of Object.entries(details)) {
          total += val.weighted;
          rows += `
      <div class="score-tooltip-row">
        <span class="score-tooltip-label">${labels[key]} (${(
            val.weight * 100
          ).toFixed(0)}%)</span>
        <span class="score-tooltip-value ${getScoreClass(
          val.score
        )}">${val.score.toFixed(3)} â†’ ${val.weighted.toFixed(3)}</span>
      </div>
    `;
        }
        rows += `
    <div class="score-tooltip-row">
      <span class="score-tooltip-label">æ€»åˆ†</span>
      <span class="score-tooltip-value ${getScoreClass(total)}">${total.toFixed(
          3
        )}</span>
    </div>
  `;

        return `<div class="score-tooltip">${rows}</div>`;
      }

      // ç”Ÿæˆç»¼åˆè¯„åˆ† tooltip HTML
      function renderCombinedTooltip(combinedDetails, oaDetails, crDetails) {
        if (!combinedDetails) return "";

        const getScoreClass = (score) => {
          if (score >= 0.78) return "good";
          if (score >= 0.55) return "medium";
          return "bad";
        };

        const oaScore = combinedDetails.openAlex.score;
        const crScore = combinedDetails.crossref.score;

        // è®¡ç®—ç»¼åˆå¾—åˆ†
        const combined = Math.max(oaScore, crScore) * 0.6 + Math.min(oaScore, crScore) * 0.4;

        // åˆ¤æ–­æ’å
        const getRank = (score) => {
          if (score >= Math.max(oaScore, crScore)) return "(ä¸»)";
          return "(æ¬¡)";
        };

        let rows = `
    <div class="score-tooltip-row" style="padding-bottom: 8px; margin-bottom: 4px; border-bottom: 1px solid rgba(255,255,255,0.15);">
      <span class="score-tooltip-label" style="font-weight: 600; color: rgba(255,255,255,0.9);">
        <span style="display: inline-block; width: 8px; height: 8px; border-radius: 50%; background: linear-gradient(135deg, #10b981, #34d399); margin-right: 6px; box-shadow: 0 0 6px rgba(16, 185, 129, 0.4);"></span>
        ç»¼åˆè¯„åˆ†å…¬å¼
      </span>
      <span class="score-tooltip-value" style="background: transparent; font-size: 10px;">maxÃ—0.6 + minÃ—0.4</span>
    </div>
    <div class="score-tooltip-row">
      <span class="score-tooltip-label">
        <span style="display: inline-block; width: 6px; height: 6px; border-radius: 50%; background: linear-gradient(135deg, #4f46e5, #818cf8); margin-right: 6px;"></span>
        OpenAlex ${oaScore >= crScore ? "(ä¸»)" : "(æ¬¡)"}
      </span>
      <span class="score-tooltip-value ${getScoreClass(oaScore)}">${oaScore.toFixed(3)} Ã— ${combinedDetails.openAlex.weight.toFixed(1)} = ${combinedDetails.openAlex.weighted.toFixed(3)}</span>
    </div>
    <div class="score-tooltip-row">
      <span class="score-tooltip-label">
        <span style="display: inline-block; width: 6px; height: 6px; border-radius: 50%; background: linear-gradient(135deg, #f59e0b, #fbbf24); margin-right: 6px;"></span>
        Crossref ${crScore > oaScore ? "(ä¸»)" : "(æ¬¡)"}
      </span>
      <span class="score-tooltip-value ${getScoreClass(crScore)}">${crScore.toFixed(3)} Ã— ${combinedDetails.crossref.weight.toFixed(1)} = ${combinedDetails.crossref.weighted.toFixed(3)}</span>
    </div>`;

        rows += `
    <div class="score-tooltip-row">
      <span class="score-tooltip-label">ç»¼åˆå¾—åˆ†</span>
      <span class="score-tooltip-value ${getScoreClass(combined)}">${combined.toFixed(3)}</span>
    </div>
  `;

        return `<div class="score-tooltip" style="min-width: 280px;">${rows}</div>`;
      }

      function renderResult(result, index) {
        const {
          raw,
          parsed,
          oaBest,
          crBest,
          oaScore,
          crScore,
          combined,
          combinedDetails,
          verdict,
          isArxiv,
        } = result;
        const oa = oaBest?.best;
        const cr = crBest?.best;
        const oaDetails = oaBest?.bestDetails;
        const crDetails = crBest?.bestDetails;

        // æ ¼å¼åŒ– OpenAlex ä½œè€…
        const formatOaAuthors = (authorships) => {
          if (!authorships || authorships.length === 0) return "-";
          return authorships.map(a => {
            const name = a.author?.display_name || a.raw_author_name || "";
            // å¤„ç† OpenAlex ä¸­æ–‡åå­—æ ¼å¼ "çˆ½ è–›" -> "è–›çˆ½"
            const parts = name.trim().split(/\s+/);
            if (parts.length === 2) {
              const [p1, p2] = parts;
              const isChinese = (s) => /^[\u4e00-\u9fa5]+$/.test(s);
              if (isChinese(p1) && isChinese(p2)) {
                // å¦‚æœç¬¬äºŒéƒ¨åˆ†æ˜¯å•å­—ï¼ˆå§“ï¼‰ï¼Œæ ¼å¼æ˜¯ "å å§“"
                if (p2.length === 1) return p2 + p1;
                // å¦‚æœç¬¬ä¸€éƒ¨åˆ†æ˜¯å•å­—ï¼ˆå§“ï¼‰ï¼Œæ ¼å¼æ˜¯ "å§“ å"
                if (p1.length === 1) return p1 + p2;
              }
            }
            return name;
          }).join(", ");
        };

        // æ ¼å¼åŒ– Crossref ä½œè€…
        const formatCrAuthors = (authors) => {
          if (!authors || authors.length === 0) return "-";
          return authors.map(a => {
            const family = a.family || "";
            const given = a.given || "";
            // æ£€æµ‹ä¸­æ–‡åå­—
            const isChinese = (s) => /^[\u4e00-\u9fa5]+$/.test(s.trim());
            if (isChinese(family) || isChinese(given)) {
              return family + given;
            }
            return given ? `${given} ${family}` : family;
          }).join(", ");
        };

        // è·å–ç»¼åˆè¯„åˆ†è¯¦æƒ…ï¼ˆå–ä¸¤ä¸ªæ•°æ®æºä¸­è¾ƒé«˜çš„åˆ†æ•°ï¼‰
        const getFieldScore = (field) => {
          const oaFieldScore = oaDetails?.[field]?.score ?? 0;
          const crFieldScore = crDetails?.[field]?.score ?? 0;
          return Math.max(oaFieldScore, crFieldScore);
        };

        // åˆ¤æ–­å­—æ®µæ˜¯å¦ä½åˆ†ï¼ˆ< 0.5ï¼‰å¹¶è¿”å›æ ·å¼
        const getLowScoreStyle = (field) => {
          const score = getFieldScore(field);
          return score < 0.5 ? 'color: var(--danger);' : '';
        };

        // è·å– OpenAlex å­—æ®µçš„ä½åˆ†æ ·å¼
        const getOaLowScoreStyle = (field) => {
          const score = oaDetails?.[field]?.score ?? 0;
          return score < 0.5 ? 'color: var(--danger);' : '';
        };

        // è·å– Crossref å­—æ®µçš„ä½åˆ†æ ·å¼
        const getCrLowScoreStyle = (field) => {
          const score = crDetails?.[field]?.score ?? 0;
          return score < 0.5 ? 'color: var(--danger);' : '';
        };

        return `
    <div class="result-item" data-index="${index}">
      <div class="result-header" onclick="toggleResult(${index})">
        <div class="result-index">${index + 1}</div>
        <div class="result-title">${esc(parsed.title || raw.slice(0, 80))}</div>
        <span class="format-badge">${esc(parsed.format || "é€šç”¨")}</span>
        <div class="score-tooltip-wrapper result-score-wrapper" onclick="event.stopPropagation()">
          <div class="result-score ${verdict.level}">${
          verdict.text
        } ${combined.toFixed(2)}</div>
          ${renderCombinedTooltip(combinedDetails, oaDetails, crDetails)}
        </div>
        <div class="result-toggle">
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <polyline points="6 9 12 15 18 9"></polyline>
          </svg>
        </div>
      </div>
      <div class="result-details">
        <div class="detail-section">
          <h4>è§£æå­—æ®µ</h4>
          <div class="detail-grid">
            <div class="detail-label">åŸå§‹å¼•ç”¨</div>
            <div class="detail-value" style="font-size:12px;color:var(--text-muted)">${esc(
              raw
            )}</div>
            <div class="detail-label">æ ‡é¢˜</div>
            <div class="detail-value">${esc(parsed.title || "-")}</div>
            <div class="detail-label">ä½œè€…</div>
            <div class="detail-value">${esc(
              (parsed.authors || []).join(", ") || "-"
            )}</div>
            <div class="detail-label">æœŸåˆŠ/å‡ºç‰ˆç¤¾</div>
            <div class="detail-value">${esc(parsed.journal || "-")}</div>
            <div class="detail-label">å¹´ä»½</div>
            <div class="detail-value">${esc(parsed.year || "-")}</div>
            <div class="detail-label">å·(æœŸ):é¡µç </div>
            <div class="detail-value">${esc(parsed.volume || "-")}(${esc(
          parsed.issue || "-"
        )}):${esc(parsed.firstPage || "-")}-${esc(parsed.lastPage || "-")}</div>
            <div class="detail-label">DOI</div>
            <div class="detail-value">${esc(parsed.doi || "æœªæä¾›")}</div>
          </div>
        </div>

        <div class="sources-grid">
          <div class="source-card">
            <h4>
              <div class="score-tooltip-wrapper">
                <span class="source-badge openalex">OpenAlex</span>
                <span class="score-inline">åŒ¹é…åˆ† ${oaScore.toFixed(3)}</span>
                ${renderScoreTooltip(oaDetails)}
              </div>
              ${
                oa
                  ? `<a href="${esc(oa.id)}" target="_blank" class="link-badge">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path>
                  <polyline points="15 3 21 3 21 9"></polyline>
                  <line x1="10" y1="14" x2="21" y2="3"></line>
                </svg>
                è¯¦æƒ…
              </a>`
                  : ""
              }
            </h4>
            ${
              oa
                ? `
              <div class="detail-grid">
                <div class="detail-label">æ ‡é¢˜</div>
                <div class="detail-value" style="${getOaLowScoreStyle('title')}">${esc(oa.title || "-")}</div>
                <div class="detail-label">ä½œè€…</div>
                <div class="detail-value" style="${getOaLowScoreStyle('author')}">${esc(formatOaAuthors(oa.authorships))}</div>
                <div class="detail-label">æœŸåˆŠ/å‡ºç‰ˆç¤¾</div>
                <div class="detail-value" style="${getOaLowScoreStyle('journal')}">${esc(
                  oa.primary_location?.source?.display_name || "-"
                )}</div>
                <div class="detail-label">å¹´ä»½</div>
                <div class="detail-value" style="${getOaLowScoreStyle('year')}">${esc(
                  oa.publication_year || "-"
                )}</div>
                <div class="detail-label">å·æœŸé¡µ</div>
                <div class="detail-value" style="${getOaLowScoreStyle('volume')}${getOaLowScoreStyle('firstPage')}">${esc(
                  oa.biblio?.volume || "-"
                )}(${esc(oa.biblio?.issue || "-")}):${esc(
                    oa.biblio?.first_page || "-"
                  )}-${esc(oa.biblio?.last_page || "-")}</div>
                <div class="detail-label">DOI</div>
                <div class="detail-value">${
                  oa.doi
                    ? `<a href="https://doi.org/${esc(
                        oa.doi.replace("https://doi.org/", "")
                      )}" target="_blank">${esc(oa.doi)}</a>`
                    : "-"
                }</div>
              </div>
            `
                : `<div style="color:var(--text-muted);font-size:13px;padding:20px 0;text-align:center;">æœªæ‰¾åˆ°åŒ¹é…ç»“æœ</div>`
            }
          </div>

          <div class="source-card">
            <h4>
              <div class="score-tooltip-wrapper">
                <span class="source-badge crossref">Crossref</span>
                <span class="score-inline">åŒ¹é…åˆ† ${crScore.toFixed(3)}</span>
                ${renderScoreTooltip(crDetails)}
              </div>
            </h4>
            ${
              cr
                ? `
              <div class="detail-grid">
                <div class="detail-label">æ ‡é¢˜</div>
                <div class="detail-value" style="${getCrLowScoreStyle('title')}">${esc(
                  (cr.title && cr.title[0]) || "-"
                )}</div>
                <div class="detail-label">ä½œè€…</div>
                <div class="detail-value" style="${getCrLowScoreStyle('author')}">${esc(formatCrAuthors(cr.author))}</div>
                <div class="detail-label">æœŸåˆŠ/å‡ºç‰ˆç¤¾</div>
                <div class="detail-value" style="${getCrLowScoreStyle('journal')}">${esc(
                  (cr["container-title"] && cr["container-title"][0]) || "-"
                )}</div>
                <div class="detail-label">å¹´ä»½</div>
                <div class="detail-value" style="${getCrLowScoreStyle('year')}">${esc(
                  cr.issued?.["date-parts"]?.[0]?.[0] || "-"
                )}</div>
                <div class="detail-label">å·æœŸé¡µ</div>
                <div class="detail-value" style="${getCrLowScoreStyle('volume')}${getCrLowScoreStyle('firstPage')}">${esc(cr.volume || "-")}(${esc(
                    cr.issue || "-"
                  )}):${esc(cr.page || "-")}</div>
                <div class="detail-label">DOI</div>
                <div class="detail-value">${
                  cr.DOI
                    ? `<a href="https://doi.org/${esc(
                        cr.DOI
                      )}" target="_blank">${esc(cr.DOI)}</a>`
                    : "-"
                }</div>
              </div>
            `
                : isArxiv
                  ? `<div style="color:var(--text-muted);font-size:13px;padding:20px 0;text-align:center;">arXiv é¢„å°æœ¬ä¸æ£€ç´¢ Crossref</div>`
                  : `<div style="color:var(--text-muted);font-size:13px;padding:20px 0;text-align:center;">æœªæ‰¾åˆ°åŒ¹é…ç»“æœ</div>`
            }
          </div>
        </div>

        <div class="detail-section">
          <div class="detail-actions">
            <span class="btn-tooltip-wrapper">
              <button class="btn btn-extract btn-small" onclick="copyBibTeX(${index}, this)">
                <svg width="13" height="13" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5">
                  <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                  <path d="M5 15H4a2 2 0 01-2-2V4a2 2 0 012-2h9a2 2 0 012 2v1"></path>
                </svg>
                å¤åˆ¶ BibTeX
              </button>
              <span class="btn-tooltip">å¤åˆ¶æ­¤æ¡ç›®çš„ BibTeX</span>
            </span>
          </div>
        </div>
      </div>
    </div>
  `;
      }

      function toggleResult(index) {
        const item = document.querySelector(
          `.result-item[data-index="${index}"]`
        );
        if (item) item.classList.toggle("expanded");
      }

      function updateStats(results) {
        const total = results.length;
        const high = results.filter((r) => r.verdict.level === "high").length;
        const medium = results.filter(
          (r) => r.verdict.level === "medium"
        ).length;
        const low = results.filter((r) => r.verdict.level === "low").length;

        document.getElementById("statTotal").textContent = total;
        document.getElementById("statHigh").textContent = high;
        document.getElementById("statMedium").textContent = medium;
        document.getElementById("statLow").textContent = low;
        document.getElementById("summary").classList.add("active");

        // æ˜¾ç¤ºå¯¼å‡ºåŒºåŸŸ
        if (total > 0) {
          document.getElementById("exportSection").classList.add("active");
        }

        // ä¿å­˜ç»“æœåˆ°å…¨å±€å˜é‡ä¾›å¯¼å‡ºä½¿ç”¨
        window.currentResults = results;

        // æ ¡éªŒå®Œæˆåï¼Œå¦‚æœæœ‰é«˜å¯ä¿¡æ¡ç›®ï¼Œé»˜è®¤é€‰æ‹©"é«˜å¯ä¿¡"
        if (!window.extractedMode && high > 0) {
          exportMode = "high";
          document
            .querySelectorAll(".export-option")
            .forEach((o) => o.classList.remove("active"));
          document
            .querySelector(".export-option[data-value='high']")
            .classList.add("active");
        } else {
          switchToAll();
        }
      }

      function updateProgress(current, total, status) {
        const percent = total > 0 ? (current / total) * 100 : 0;
        document.getElementById("progressFill").style.width = percent + "%";
        document.getElementById(
          "progressCount"
        ).textContent = `${current} / ${total}`;
        document.getElementById("progressStatus").textContent = status;
      }

      /** ---------- ä¸»é€»è¾‘ ---------- */
      document.getElementById("run").addEventListener("click", async () => {
        const btn = document.getElementById("run");
        const resultsDiv = document.getElementById("results");
        const progressDiv = document.getElementById("progress");
        const summaryDiv = document.getElementById("summary");

        const rawText = document.getElementById("citation").value;
        const mailto = document.getElementById("mailto").value.trim();

        // è§£æå¤šè¡Œï¼Œè¿‡æ»¤ç©ºè¡Œ
        const lines = rawText
          .split("\n")
          .map((l) => l.trim())
          .filter(Boolean);

        if (lines.length === 0) {
          resultsDiv.innerHTML = `
      <div class="card empty-state">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
          <path d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"/>
        </svg>
        <div>è¯·è¾“å…¥è‡³å°‘ä¸€æ¡å¼•ç”¨</div>
      </div>
    `;
          return;
        }

        // é‡ç½®UI
        btn.disabled = true;
        const originalText = btn.textContent;
        btn.innerHTML = `<span class="loading-spinner"></span> æ ¡éªŒä¸­...`;
        resultsDiv.innerHTML = "";
        summaryDiv.classList.remove("active");
        progressDiv.classList.add("active");
        updateProgress(0, lines.length, "å‡†å¤‡ä¸­...");

        // æ¸…é™¤æå–æ¨¡å¼ï¼Œæ ¡éªŒå®Œæˆåå°†ä½¿ç”¨æ ¡éªŒç»“æœç”Ÿæˆ BibTeX
        window.extractedMode = false;

        // è·å–å¹¶å‘æ•°
        const concurrency = parseInt(document.getElementById("concurrency").value, 10) || 5;

        // åˆ›å»ºç»“æœæ•°ç»„ï¼ˆä¿æŒé¡ºåºï¼‰
        const results = new Array(lines.length).fill(null);
        let completedCount = 0;

        // å…ˆåˆ›å»ºæ‰€æœ‰å ä½ç¬¦
        for (let i = 0; i < lines.length; i++) {
          resultsDiv.innerHTML += `<div class="processing-item" id="processing-${i}">ç­‰å¾…æ ¡éªŒï¼š${esc(
            lines[i].slice(0, 60)
          )}...</div>`;
        }

        // å¹¶å‘å¤„ç†å‡½æ•°
        async function processItem(index) {
          const line = lines[index];

          // æ›´æ–°å ä½ç¬¦çŠ¶æ€
          const placeholder = document.getElementById(`processing-${index}`);
          if (placeholder) {
            placeholder.textContent = `æ­£åœ¨æ ¡éªŒï¼š${line.slice(0, 60)}...`;
          }

          try {
            const result = await verifySingle(line, mailto);
            results[index] = result;

            // æ›¿æ¢å ä½ä¸ºçœŸå®ç»“æœ
            if (placeholder) {
              placeholder.outerHTML = renderResult(result, index);
            }
          } catch (e) {
            const errorResult = {
              raw: line,
              parsed: parseCitation(line),
              oaBest: null,
              crBest: null,
              oaScore: 0,
              crScore: 0,
              combined: 0,
              verdict: { level: "low", text: "é”™è¯¯", desc: e.message },
            };
            results[index] = errorResult;

            if (placeholder) {
              placeholder.outerHTML = renderResult(errorResult, index);
            }
          }

          completedCount++;
          updateProgress(completedCount, lines.length, `å·²å®Œæˆ ${completedCount}/${lines.length} æ¡`);
        }

        // å¹¶å‘æ§åˆ¶å™¨
        async function runWithConcurrency(tasks, limit) {
          const executing = new Set();

          for (const task of tasks) {
            const promise = task().then(() => {
              executing.delete(promise);
            });
            executing.add(promise);

            if (executing.size >= limit) {
              await Promise.race(executing);
            }
          }

          await Promise.all(executing);
        }

        // åˆ›å»ºä»»åŠ¡åˆ—è¡¨
        const tasks = lines.map((_, index) => () => processItem(index));

        // æ‰§è¡Œå¹¶å‘è¯·æ±‚
        await runWithConcurrency(tasks, concurrency);

        updateProgress(lines.length, lines.length, "æ ¡éªŒå®Œæˆ");
        updateStats(results);

        btn.disabled = false;
        btn.textContent = originalText;

        // éšè—è¿›åº¦æ¡
        setTimeout(() => {
          progressDiv.classList.remove("active");
        }, 1000);
      });

      document.getElementById("clear").addEventListener("click", () => {
        document.getElementById("citation").value = "";
        document.getElementById("results").innerHTML = "";
        document.getElementById("summary").classList.remove("active");
        document.getElementById("progress").classList.remove("active");
        document.getElementById("exportSection").classList.remove("active");
        window.currentResults = [];
      });

      /** ---------- BibTeX å¯¼å‡ºåŠŸèƒ½ ---------- */
      // æ˜¾ç¤ºæç¤ºæ¶ˆæ¯
      function showToast(message) {
        const toast = document.getElementById("toast");
        toast.textContent = message;
        toast.classList.add("show");
        setTimeout(() => toast.classList.remove("show"), 2000);
      }

      // å¯¼å‡ºæ¨¡å¼ï¼šall æˆ– high
      let exportMode = "all";

      // é€‰æ‹©å™¨åˆ‡æ¢
      document.querySelectorAll(".export-option").forEach((option) => {
        option.addEventListener("click", () => {
          document
            .querySelectorAll(".export-option")
            .forEach((o) => o.classList.remove("active"));
          option.classList.add("active");
          exportMode = option.dataset.value;
        });
      });

      // åˆ‡æ¢åˆ°å…¨éƒ¨æ¨¡å¼
      function switchToAll() {
        exportMode = "all";
        document
          .querySelectorAll(".export-option")
          .forEach((o) => o.classList.remove("active"));
        document
          .querySelector(".export-option[data-value='all']")
          .classList.add("active");
      }

      // è·å–è¦å¯¼å‡ºçš„ç»“æœå’Œæ™ºèƒ½æç¤ºä¿¡æ¯
      function getResultsForExport() {
        const results = window.currentResults || [];
        if (results.length === 0)
          return { results: [], message: "æš‚æ— ç»“æœ", needSwitch: false };

        // æå–æ¨¡å¼ä¸‹æ²¡æœ‰é«˜å¯ä¿¡æ¦‚å¿µ
        if (window.extractedMode && results[0]?.isExtracted) {
          if (exportMode === "high") {
            return {
              results: [],
              message: "æœªç»è¿‡æ ¡éªŒï¼Œæ— é«˜å¯ä¿¡æ¡ç›®",
              needSwitch: true,
            };
          }
          return { results, message: "", needSwitch: false };
        }

        if (exportMode === "high") {
          const highResults = results.filter((r) => r.verdict.level === "high");
          if (highResults.length === 0) {
            const medium = results.filter(
              (r) => r.verdict.level === "medium"
            ).length;
            const low = results.filter((r) => r.verdict.level === "low").length;
            if (medium > 0 || low > 0) {
              return {
                results: [],
                message: `æ— é«˜å¯ä¿¡æ¡ç›®ï¼ˆ${medium}ä¸­å¯ä¿¡/${low}ä½å¯ä¿¡ï¼‰`,
                needSwitch: true,
              };
            }
            return { results: [], message: "æ— é«˜å¯ä¿¡æ¡ç›®", needSwitch: true };
          }
          return { results: highResults, message: "", needSwitch: false };
        }

        return { results, message: "", needSwitch: false };
      }

      // ç”Ÿæˆ BibTeX å­—ç¬¦ä¸²
      function generateBibTeXString(results) {
        if (results.length === 0) return "";

        const isExtractedMode = window.extractedMode && results[0]?.isExtracted;
        return results
          .map((r) =>
            isExtractedMode
              ? generateBibTeXFromParsed(r.parsed)
              : generateBibTeX(r)
          )
          .join("\n\n");
      }

      // ä¸‹è½½ BibTeX
      document.getElementById("exportBib").addEventListener("click", () => {
        const { results, message, needSwitch } = getResultsForExport();
        if (results.length === 0) {
          showToast(message);
          if (needSwitch) switchToAll();
          return;
        }

        const allBibtex = generateBibTeXString(results);
        const filename = `citations_${new Date()
          .toISOString()
          .slice(0, 10)}.bib`;
        downloadFile(allBibtex, filename);
        showToast(`å·²ä¸‹è½½ ${results.length} æ¡ BibTeX`);
      });

      // å¤åˆ¶ BibTeX
      document.getElementById("copyBib").addEventListener("click", async () => {
        const { results, message, needSwitch } = getResultsForExport();
        if (results.length === 0) {
          showToast(message);
          if (needSwitch) switchToAll();
          return;
        }

        const allBibtex = generateBibTeXString(results);
        const success = await copyToClipboard(allBibtex);

        if (success) {
          showToast(`å·²å¤åˆ¶ ${results.length} æ¡ BibTeX`);
        } else {
          showToast("å¤åˆ¶å¤±è´¥ï¼Œè¯·é‡è¯•");
        }
      });

      // å¤åˆ¶å•ä¸ª BibTeXï¼ˆç»“æœé¡¹å†…ï¼‰
      async function copyBibTeX(index, button) {
        const results = window.currentResults || [];
        if (!results[index]) return;

        const isExtracted = window.extractedMode && results[index]?.isExtracted;
        const bibtex = isExtracted
          ? generateBibTeXFromParsed(results[index].parsed)
          : generateBibTeX(results[index]);
        const success = await copyToClipboard(bibtex);

        if (success) {
          const originalText = button.innerHTML;
          button.innerHTML = `<svg width="13" height="13" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5"><polyline points="20 6 9 17 4 12"></polyline></svg> å·²å¤åˆ¶`;
          setTimeout(() => (button.innerHTML = originalText), 2000);
        } else {
          showToast("å¤åˆ¶å¤±è´¥ï¼Œè¯·é‡è¯•");
        }
      }

      // æå– BibTeXï¼ˆä¸è°ƒç”¨ APIï¼‰
      document.getElementById("extractBib").addEventListener("click", async () => {
        const btn = document.getElementById("extractBib");
        const rawText = document.getElementById("citation").value;
        const resultsDiv = document.getElementById("results");
        const summaryDiv = document.getElementById("summary");
        const exportSection = document.getElementById("exportSection");
        const progressDiv = document.getElementById("progress");

        const lines = rawText
          .split("\n")
          .map((l) => l.trim())
          .filter(Boolean);

        if (lines.length === 0) {
          resultsDiv.innerHTML = `
      <div class="card empty-state">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
          <path d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"/>
        </svg>
        <div>è¯·è¾“å…¥è‡³å°‘ä¸€æ¡å¼•ç”¨</div>
      </div>
    `;
          return;
        }

        // æ£€æŸ¥æ˜¯å¦å¯ç”¨ AI è§£æ
        const useAi = localStorage.getItem(AI_ENABLED_KEY) === "true";

        // å¦‚æœå¯ç”¨ AIï¼Œæ˜¾ç¤ºè¿›åº¦æ¡
        if (useAi) {
          btn.disabled = true;
          const originalText = btn.textContent;
          btn.innerHTML = `<span class="loading-spinner"></span> AI è§£æä¸­...`;
          resultsDiv.innerHTML = "";
          progressDiv.classList.add("active");
          updateProgress(0, lines.length, "AI è§£æä¸­...");
        }

        // ç”Ÿæˆä»…è§£æçš„ç»“æœï¼ˆä¸è°ƒç”¨ APIï¼‰
        const results = [];
        for (let i = 0; i < lines.length; i++) {
          const line = lines[i];
          let parsed;

          if (useAi) {
            updateProgress(i, lines.length, `AI è§£æç¬¬ ${i + 1} æ¡...`);
            parsed = await parseWithAI(line);
            if (!parsed) {
              // AI è§£æå¤±è´¥ï¼Œå›é€€åˆ°è§„åˆ™è§£æ
              parsed = parseCitation(line);
            }
          } else {
            parsed = parseCitation(line);
          }

          results.push({
            raw: line,
            parsed: parsed,
            oaBest: null,
            crBest: null,
            oaScore: 0,
            crScore: 0,
            combined: 0,
            verdict: { level: "medium", text: "æœªæ ¡éªŒ", desc: "åŸºäºè§£æ" },
            isExtracted: true, // æ ‡è®°ä¸ºä»…æå–ï¼Œæœªæ ¡éªŒ
          });
        }

        // æ¢å¤æŒ‰é’®çŠ¶æ€
        if (useAi) {
          btn.disabled = false;
          btn.innerHTML = `ç”Ÿæˆ BibTeX`;
          updateProgress(lines.length, lines.length, "è§£æå®Œæˆ");
          setTimeout(() => progressDiv.classList.remove("active"), 1000);
        }

        // æ˜¾ç¤ºç»“æœ
        resultsDiv.innerHTML = results
          .map((r, i) => renderExtractedResult(r, i))
          .join("");

        // æ›´æ–°ç»Ÿè®¡
        const total = results.length;
        document.getElementById("statTotal").textContent = total;
        document.getElementById("statHigh").textContent = "-";
        document.getElementById("statMedium").textContent = "-";
        document.getElementById("statLow").textContent = "-";
        summaryDiv.classList.add("active");
        exportSection.classList.add("active");

        // ä¿å­˜ç»“æœåˆ°å…¨å±€å˜é‡
        window.currentResults = results;
        window.extractedMode = true; // æ ‡è®°å½“å‰ä¸ºæå–æ¨¡å¼

        // æå–æ¨¡å¼ä¸‹é‡ç½®é€‰æ‹©å™¨ä¸º"å…¨éƒ¨"
        exportMode = "all";
        document
          .querySelectorAll(".export-option")
          .forEach((o) => o.classList.remove("active"));
        document
          .querySelector(".export-option[data-value='all']")
          .classList.add("active");
      });

      // æ¸²æŸ“ä»…æå–çš„ç»“æœï¼ˆä¸è°ƒç”¨ APIï¼‰
      function renderExtractedResult(result, index) {
        const { raw, parsed } = result;

        return `
    <div class="result-item" data-index="${index}">
      <div class="result-header" onclick="toggleResult(${index})">
        <div class="result-index">${index + 1}</div>
        <div class="result-title">${esc(parsed.title || raw.slice(0, 80))}</div>
        <div class="result-score medium">æœªæ ¡éªŒ</div>
        <div class="result-toggle">
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <polyline points="6 9 12 15 18 9"></polyline>
          </svg>
        </div>
      </div>
      <div class="result-details">
        <div class="detail-section">
          <h4>è§£æå­—æ®µ</h4>
          <div class="detail-grid">
            <div class="detail-label">åŸå§‹å¼•ç”¨</div>
            <div class="detail-value" style="font-size:12px;color:var(--text-muted)">${esc(
              raw
            )}</div>
            <div class="detail-label">æ ‡é¢˜</div>
            <div class="detail-value">${esc(parsed.title || "-")}</div>
            <div class="detail-label">ä½œè€…</div>
            <div class="detail-value">${esc(
              (parsed.authors || []).join(", ") || "-"
            )}</div>
            <div class="detail-label">æœŸåˆŠ</div>
            <div class="detail-value">${esc(parsed.journal || "-")}</div>
            <div class="detail-label">å¹´ä»½</div>
            <div class="detail-value">${esc(parsed.year || "-")}</div>
            <div class="detail-label">å·(æœŸ):é¡µç </div>
            <div class="detail-value">${esc(parsed.volume || "-")}(${esc(
          parsed.issue || "-"
        )}):${esc(parsed.firstPage || "-")}-${esc(parsed.lastPage || "-")}</div>
            <div class="detail-label">DOI</div>
            <div class="detail-value">${esc(parsed.doi || "æœªæä¾›")}</div>
          </div>
        </div>

        <div class="detail-section">
          <h4> BibTeX é¢„è§ˆ</h4>
          <pre style="background:var(--bg);padding:12px;border-radius:8px;font-size:12px;overflow-x:auto;max-height:200px;overflow-y:auto;border:1px solid var(--border);">${esc(
            generateBibTeXFromParsed(parsed)
          )}</pre>
        </div>

        <div class="detail-section">
          <div class="detail-actions">
            <span class="btn-tooltip-wrapper">
              <button class="btn btn-extract btn-small" onclick="copyExtractedBib(${index}, this)">
                <svg width="13" height="13" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5">
                  <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                  <path d="M5 15H4a2 2 0 01-2-2V4a2 2 0 012-2h9a2 2 0 012 2v1"></path>
                </svg>
                å¤åˆ¶ BibTeX
              </button>
              <span class="btn-tooltip">å¤åˆ¶æ­¤æ¡ç›®çš„ BibTeX</span>
            </span>
          </div>
        </div>
      </div>
    </div>
  `;
      }

      // å¤åˆ¶æå–æ¨¡å¼çš„å•ä¸ª BibTeX
      async function copyExtractedBib(index, button) {
        const results = window.currentResults || [];
        if (!results[index]) return;

        const bibtex = generateBibTeXFromParsed(results[index].parsed);
        const success = await copyToClipboard(bibtex);

        if (success) {
          const originalText = button.innerHTML;
          button.innerHTML = `<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="20 6 9 17 4 12"></polyline></svg> å·²å¤åˆ¶`;
          setTimeout(() => (button.innerHTML = originalText), 2000);
        } else {
          showToast("å¤åˆ¶å¤±è´¥ï¼Œè¯·é‡è¯•");
        }
      }

      // é»˜è®¤å±•å¼€ç¬¬ä¸€ä¸ªç»“æœ
      window.toggleResult = toggleResult;
      window.copyBibTeX = copyBibTeX;
      window.copyExtractedBib = copyExtractedBib;

      /** ---------- å¼¹çª—å’Œåé¦ˆ ---------- */
      // æ‰“å¼€æ‰“åˆ†æ ‡å‡†å¼¹çª—
      function openScoreRulesModal() {
        document.getElementById("scoreRulesModal").classList.add("show");
        document.body.style.overflow = "hidden";
      }

      // å…³é—­æ‰“åˆ†æ ‡å‡†å¼¹çª—
      function closeScoreRulesModal() {
        document.getElementById("scoreRulesModal").classList.remove("show");
        document.body.style.overflow = "";
      }

      // æ‰“å¼€æ ¼å¼ç¤ºä¾‹å¼¹çª—
      function openFormatGuideModal() {
        document.getElementById("formatGuideModal").classList.add("show");
        document.body.style.overflow = "hidden";
      }

      // å…³é—­æ ¼å¼ç¤ºä¾‹å¼¹çª—
      function closeFormatGuideModal() {
        document.getElementById("formatGuideModal").classList.remove("show");
        document.body.style.overflow = "";
      }

      // ç‚¹å‡»é®ç½©å…³é—­å¼¹çª—
      document
        .getElementById("scoreRulesModal")
        .addEventListener("click", (e) => {
          if (e.target === e.currentTarget) {
            closeScoreRulesModal();
          }
        });

      document
        .getElementById("formatGuideModal")
        .addEventListener("click", (e) => {
          if (e.target === e.currentTarget) {
            closeFormatGuideModal();
          }
        });

      // ESC é”®å…³é—­å¼¹çª—
      document.addEventListener("keydown", (e) => {
        if (e.key === "Escape") {
          closeScoreRulesModal();
          closeFormatGuideModal();
          closeAiConfigModal();
        }
      });

      // ç»‘å®šæŒ‰é’®äº‹ä»¶
      document
        .getElementById("showScoreRules")
        .addEventListener("click", openScoreRulesModal);
      document
        .getElementById("showFormatGuide")
        .addEventListener("click", openFormatGuideModal);
      document.getElementById("feedback").addEventListener("click", () => {
        window.open(
          "https://github.com/QAbot-zh/citation-checker/issues",
          "_blank"
        );
      });

      window.closeScoreRulesModal = closeScoreRulesModal;
      window.closeFormatGuideModal = closeFormatGuideModal;

      /** ---------- AI é…ç½®åŠŸèƒ½ ---------- */

      // åŠ è½½ AI é…ç½®
      function loadAiConfig() {
        try {
          const config = localStorage.getItem(AI_CONFIG_KEY);
          return config ? JSON.parse(config) : null;
        } catch (e) {
          return null;
        }
      }

      // ä¿å­˜ AI é…ç½®
      function saveAiConfig() {
        const baseUrl = document.getElementById("aiBaseUrl").value.trim();
        const apiKey = document.getElementById("aiApiKey").value.trim();
        const model = document.getElementById("aiModel").value.trim();
        const temperature = parseFloat(document.getElementById("aiTemperature").value);

        if (!baseUrl || !apiKey) {
          showToast("è¯·å¡«å†™ API Base URL å’Œ API Key");
          return;
        }

        const config = { baseUrl, apiKey, model: model || "gpt-4o-mini", temperature };
        localStorage.setItem(AI_CONFIG_KEY, JSON.stringify(config));

        updateAiConfigUI();
        showToast("AI é…ç½®å·²ä¿å­˜");
      }

      // æ¸…é™¤ AI é…ç½®
      function clearAiConfig() {
        localStorage.removeItem(AI_CONFIG_KEY);
        localStorage.removeItem(AI_ENABLED_KEY);

        document.getElementById("aiBaseUrl").value = "";
        document.getElementById("aiApiKey").value = "";
        document.getElementById("aiModel").value = "gpt-4o-mini";
        document.getElementById("aiTemperature").value = "0.1";
        document.getElementById("aiTempValue").textContent = "0.1";

        updateAiConfigUI();
        showToast("AI é…ç½®å·²æ¸…é™¤");
      }

      // æµ‹è¯• AI è¿æ¥
      async function testAiConfig() {
        const baseUrl = document.getElementById("aiBaseUrl").value.trim();
        const apiKey = document.getElementById("aiApiKey").value.trim();
        const model = document.getElementById("aiModel").value.trim() || "gpt-4o-mini";

        if (!baseUrl || !apiKey) {
          showToast("è¯·å…ˆå¡«å†™ API Base URL å’Œ API Key");
          return;
        }

        showToast("æ­£åœ¨æµ‹è¯•è¿æ¥...");

        try {
          const response = await fetch(`${baseUrl}/chat/completions`, {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              "Authorization": `Bearer ${apiKey}`
            },
            body: JSON.stringify({
              model: model,
              messages: [{ role: "user", content: "Hi" }],
              max_tokens: 5
            })
          });

          if (response.ok) {
            showToast("è¿æ¥æˆåŠŸï¼");
          } else {
            const error = await response.json().catch(() => ({}));
            showToast(`è¿æ¥å¤±è´¥: ${error.error?.message || response.status}`);
          }
        } catch (e) {
          showToast(`è¿æ¥å¤±è´¥: ${e.message}`);
        }
      }

      // æ›´æ–° AI é…ç½® UI
      function updateAiConfigUI() {
        const config = loadAiConfig();
        const statusEl = document.getElementById("aiConfigStatus");
        const checkbox = document.getElementById("useAiParsing");
        const tooltip = document.getElementById("aiTooltip");
        const enabled = localStorage.getItem(AI_ENABLED_KEY) === "true";

        if (config && config.apiKey) {
          statusEl.className = "ai-status configured";
          statusEl.innerHTML = `<span class="ai-status-dot"></span><span>å·²é…ç½®: ${config.model || "gpt-4o-mini"}</span>`;
          checkbox.disabled = false;
          checkbox.checked = enabled;
          tooltip.style.display = "none";  // å·²é…ç½®ï¼Œéšè— tooltip

          // å¡«å……è¡¨å•
          document.getElementById("aiBaseUrl").value = config.baseUrl || "";
          document.getElementById("aiApiKey").value = config.apiKey || "";
          document.getElementById("aiModel").value = config.model || "gpt-4o-mini";
          document.getElementById("aiTemperature").value = config.temperature ?? 0.1;
          document.getElementById("aiTempValue").textContent = config.temperature ?? 0.1;
        } else {
          statusEl.className = "ai-status not-configured";
          statusEl.innerHTML = `<span class="ai-status-dot"></span><span>æœªé…ç½® API</span>`;
          checkbox.disabled = true;
          checkbox.checked = false;
          tooltip.style.display = "";  // æœªé…ç½®ï¼Œæ˜¾ç¤º tooltip
        }
      }

      // æ‰“å¼€ AI é…ç½®å¼¹çª—
      function openAiConfigModal() {
        updateAiConfigUI();
        document.getElementById("aiConfigModal").classList.add("show");
        document.body.style.overflow = "hidden";
      }

      // å…³é—­ AI é…ç½®å¼¹çª—
      function closeAiConfigModal() {
        document.getElementById("aiConfigModal").classList.remove("show");
        document.body.style.overflow = "";
      }

      // AI è§£æå¼•ç”¨
      async function parseWithAI(raw) {
        const config = loadAiConfig();
        if (!config || !config.apiKey) {
          return null;
        }

        const prompt = `è¯·è§£æä»¥ä¸‹å­¦æœ¯å¼•ç”¨ï¼Œæå–å­—æ®µå¹¶ä»¥ JSON æ ¼å¼è¿”å›ã€‚åªè¿”å› JSONï¼Œä¸è¦å…¶ä»–å†…å®¹ã€‚

å¼•ç”¨æ–‡æœ¬ï¼š
${raw}

è¯·æå–ä»¥ä¸‹å­—æ®µï¼ˆå¦‚æœæ— æ³•è¯†åˆ«åˆ™è®¾ä¸º nullï¼‰ï¼š
- title: è®ºæ–‡/ä¹¦ç±æ ‡é¢˜
- authors: ä½œè€…åˆ—è¡¨ï¼ˆæ•°ç»„æ ¼å¼ï¼Œå¦‚ ["å¼ ä¸‰", "æå››"]ï¼‰
- year: å‘è¡¨å¹´ä»½ï¼ˆæ•°å­—ï¼‰
- journal: æœŸåˆŠåæˆ–å‡ºç‰ˆç¤¾
- volume: å·å·
- issue: æœŸå·
- firstPage: èµ·å§‹é¡µç 
- lastPage: ç»“æŸé¡µç 
- doi: DOI æ ‡è¯†ç¬¦ï¼ˆæ³¨æ„åŒºåˆ† arxiv idï¼ŒarXiv ID å¦‚ 1706.03762 ä¸æ˜¯ DOIï¼ŒarXiv çš„ DOI æ ¼å¼å¦‚ 10.48550/arXiv.xxxx ä¹Ÿä¸è¦æå–ï¼Œä»…è¯†åˆ«æ˜æ˜¾çš„ doi é“¾æ¥ï¼‰

è¿”å›æ ¼å¼ç¤ºä¾‹ï¼š
{"title": "...", "authors": ["..."], "year": 2020, "journal": "...", "volume": "1", "issue": "2", "firstPage": "10", "lastPage": "20", "doi": null}`;

        try {
          const response = await fetch(`${config.baseUrl}/chat/completions`, {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              "Authorization": `Bearer ${config.apiKey}`
            },
            body: JSON.stringify({
              model: config.model || "gpt-4o-mini",
              messages: [{ role: "user", content: prompt }],
              temperature: config.temperature ?? 0.1
            })
          });

          if (!response.ok) {
            console.error("AI è§£æå¤±è´¥:", response.status);
            return null;
          }

          const data = await response.json();
          const content = data.choices?.[0]?.message?.content || "";

          // æå– JSON
          const jsonMatch = content.match(/\{[\s\S]*\}/);
          if (jsonMatch) {
            const parsed = JSON.parse(jsonMatch[0]);
            return {
              raw: raw,
              title: parsed.title || null,
              authors: Array.isArray(parsed.authors) ? parsed.authors : [],
              year: parsed.year ? parseInt(parsed.year, 10) : null,
              journal: parsed.journal || null,
              volume: parsed.volume ? String(parsed.volume) : null,
              issue: parsed.issue ? String(parsed.issue) : null,
              firstPage: parsed.firstPage ? String(parsed.firstPage) : null,
              lastPage: parsed.lastPage ? String(parsed.lastPage) : null,
              doi: parsed.doi || null,
              format: "AI è§£æ"
            };
          }
        } catch (e) {
          console.error("AI è§£æé”™è¯¯:", e);
        }

        return null;
      }

      // æ¸©åº¦æ»‘å—äº‹ä»¶
      document.getElementById("aiTemperature").addEventListener("input", (e) => {
        document.getElementById("aiTempValue").textContent = e.target.value;
      });

      // AI å¤é€‰æ¡†äº‹ä»¶
      document.getElementById("useAiParsing").addEventListener("change", (e) => {
        localStorage.setItem(AI_ENABLED_KEY, e.target.checked ? "true" : "false");
      });

      // æ‰“å¼€é…ç½®é“¾æ¥
      document.getElementById("openAiConfig").addEventListener("click", openAiConfigModal);

      // AI é…ç½®å¼¹çª—ç‚¹å‡»é®ç½©å…³é—­
      document.getElementById("aiConfigModal").addEventListener("click", (e) => {
        if (e.target === e.currentTarget) {
          closeAiConfigModal();
        }
      });

      // é¡µé¢åŠ è½½æ—¶åˆå§‹åŒ– AI é…ç½® UI
      updateAiConfigUI();

      // åˆå§‹åŒ–å¹¶å‘æ•°é…ç½®
      const savedConcurrency = localStorage.getItem(CONCURRENCY_KEY);
      if (savedConcurrency) {
        const val = parseInt(savedConcurrency, 10);
        if (val >= 1 && val <= 20) {
          document.getElementById("concurrency").value = val;
        }
      }

      // å¹¶å‘æ•°æ”¹å˜æ—¶ä¿å­˜åˆ° localStorage
      document.getElementById("concurrency").addEventListener("change", (e) => {
        const val = parseInt(e.target.value, 10);
        if (val >= 1 && val <= 20) {
          localStorage.setItem(CONCURRENCY_KEY, val);
        }
      });

      window.closeAiConfigModal = closeAiConfigModal;
      window.saveAiConfig = saveAiConfig;
      window.clearAiConfig = clearAiConfig;
      window.testAiConfig = testAiConfig;
    </script>
  </body>
</html>
